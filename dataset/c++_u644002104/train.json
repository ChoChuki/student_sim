[
    {
        "problem_id": "p03433",
        "question": "Score: 100 points\n\nProblem Statement\nE869120 has A 1-yen coins and infinitely many 500-yen coins.\nDetermine if he can pay exactly N yen using only these coins.\n\nConstraints\n\nN is an integer between 1 and 10000 (inclusive).\nA is an integer between 0 and 1000 (inclusive).\n\nInput\nInput is given from Standard Input in the following format:\nN\nA\n\nOutput\nIf E869120 can pay exactly N yen using only his 1-yen and 500-yen coins, print Yes; otherwise, print No.\n\nSample Input 12018\n218\n\nSample Output 1Yes\n\nWe can pay 2018 yen with four 500-yen coins and 18 1-yen coins, so the answer is Yes.\n\nSample Input 22763\n0\n\nSample Output 2No\n\nWhen we have no 1-yen coins, we can only pay a multiple of 500 yen using only 500-yen coins. Since 2763 is not a multiple of 500, we cannot pay this amount.\n\nSample Input 337\n514\n\nSample Output 3Yes",
        "desc": "This C++ problem assesses understanding of greedy algorithms and modular arithmetic by requiring determination of whether a specific amount can be formed using a limited number of 1-yen coins and unlimited 500-yen coins. It is categorized as a medium difficulty level problem.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int N, A, E;\n  cin >> N;\n  cin >> A;\n  E = N % 500;\n  if (E != 0) {\n    if (A - E >= 0){\n      cout << \"Yes\" << endl;\n    }\n    else {\n      cout << \"No\" << endl;\n    }\n  }\n  else {\n    cout << \"No\" << endl;\n  }\n}",
        "error_desc": "1. The code incorrectly outputs \"No\" when `N` is a multiple of 500, but it should output \"Yes\"."
    },
    {
        "problem_id": "p03424",
        "question": "Score : 200 points\n\nProblem StatementIn Japan, people make offerings called hina arare, colorful crackers, on March 3.\nWe have a bag that contains N hina arare. (From here, we call them arare.)\nIt is known that the bag either contains arare in three colors: pink, white and green, or contains arare in four colors: pink, white, green and yellow.\nWe have taken out the arare in the bag one by one, and the color of the i-th arare was S_i, where colors are represented as follows - pink: P, white: W, green: G, yellow: Y.\nIf the number of colors of the arare in the bag was three, print Three; if the number of colors was four, print Four.\n\nConstraints\n1 \\leq N \\leq 100\nS_i is P, W, G or Y.\nThere always exist i, j and k such that S_i=P, S_j=W and S_k=G.\n\nInputInput is given from Standard Input in the following format:\nN\nS_1 S_2 ... S_N\n\nOutputIf the number of colors of the arare in the bag was three, print Three; if the number of colors was four, print Four.\n\nSample Input 16\nG W Y P Y W\n\nSample Output 1Four\n\nThe bag contained arare in four colors, so you should print Four.\n\nSample Input 29\nG W W G P W P G G\n\nSample Output 2Three\n\nThe bag contained arare in three colors, so you should print Three.\n\nSample Input 38\nP Y W G Y W Y Y\n\nSample Output 3Four",
        "desc": "This C++ problem requires identifying whether a sequence of given color codes contains three or four distinct colors, utilizing concepts such as array manipulation and set operations for unique element counting. It is classified as an easy to medium difficulty level problem.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int N;\n  string S;\n  bool p = false, w = false, g = false, y = false;\n  cin >> N;\n  for (int i = 0; i < N; i++) {\n    cin >> S;\n    if (S == \"P\") {\n      p = true;\n    }\n    if (S == \"W\") {\n      w = true;\n    }\n    if (S == \"G\") {\n      g = true;\n    }\n    if (S == \"Y\") {\n      y = true;\n    }\n  }\n  if (p && w && g && y) {\n    cout << \"Four\" << endl;\n  }\n  else {\n    cout << \"Three\" << endl;\n  }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03720",
        "question": "Score : 200 points\n\nProblem StatementThere are N cities and M roads.\nThe i-th road (1≤i≤M) connects two cities a_i and b_i (1≤a_i,b_i≤N) bidirectionally.\nThere may be more than one road that connects the same pair of two cities.\nFor each city, how many roads are connected to the city?\n\nConstraints\n2≤N,M≤50\n1≤a_i,b_i≤N\na_i ≠ b_i\nAll input values are integers.\n\nInputInput is given from Standard Input in the following format:  \nN M\na_1 b_1\n:  \na_M b_M\n\nOutputPrint the answer in N lines.\nIn the i-th line (1≤i≤N), print the number of roads connected to city i.\n\nSample Input 14 3\n1 2\n2 3\n1 4\n\nSample Output 12\n2\n1\n1\n\nCity 1 is connected to the 1-st and 3-rd roads.\nCity 2 is connected to the 1-st and 2-nd roads.\nCity 3 is connected to the 2-nd road.\nCity 4 is connected to the 3-rd road.\n\nSample Input 22 5\n1 2\n2 1\n1 2\n2 1\n1 2\n\nSample Output 25\n5\n\nSample Input 38 8\n1 2\n3 4\n1 5\n2 8\n3 7\n5 2\n4 1\n6 8\n\nSample Output 33\n3\n2\n2\n2\n1\n1\n2",
        "desc": "This problem involves counting the number of roads connected to each city in an undirected graph, testing fundamental concepts such as graph representation and frequency counting in C++. It is classified as an **Easy** difficulty level.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int N, M, a, b;\n  cin >> N >> M;\n  vector<int> vec(N);\n  for (int i = 0; i < M; i++) {\n    cin >> a >> b;\n    for (int j = 0; j < N; j++) {\n      if (a == j + 1 || b == j + 1) {\n        vec.at(j) += 1;\n      }\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    cout << vec.at(i) << endl;\n  }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03434",
        "question": "Score: 200 points\n\nProblem Statement\nWe have N cards. A number a_i is written on the i-th card.\nAlice and Bob will play a game using these cards. In this game, Alice and Bob alternately take one card. Alice goes first.\nThe game ends when all the cards are taken by the two players, and the score of each player is the sum of the numbers written on the cards he/she has taken. When both players take the optimal strategy to maximize their scores, find Alice's score minus Bob's score.\n\nConstraints\n\nN is an integer between 1 and 100 (inclusive).\na_i \\ (1 \\leq i \\leq N) is an integer between 1 and 100 (inclusive).\n\nInput\nInput is given from Standard Input in the following format:  \nN\na_1 a_2 a_3 ... a_N\n\nOutput\nPrint Alice's score minus Bob's score when both players take the optimal strategy to maximize their scores.\n\nSample Input 12\n3 1\n\nSample Output 12\n\nFirst, Alice will take the card with 3. Then, Bob will take the card with 1.\nThe difference of their scores will be 3 - 1 = 2.\n\nSample Input 23\n2 7 4\n\nSample Output 25\n\nFirst, Alice will take the card with 7. Then, Bob will take the card with 4. Lastly, Alice will take the card with 2. The difference of their scores will be 7 - 4 + 2 = 5. The difference of their scores will be 3 - 1 = 2.\n\nSample Input 34\n20 18 2 18\n\nSample Output 318",
        "desc": "This C++ problem involves determining the optimal score difference in a two-player card game by implementing dynamic programming or game theory strategies. It tests concepts such as dynamic programming, optimal strategy formulation, and understanding of turn-based game mechanics, and is considered to be of intermediate difficulty.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int N, a, a_sum = 0, b_sum = 0;\n  cin >> N;\n  vector<int> card(N);\n  for (int i = 0; i < N; i++) {\n    cin >> a;\n    card.at(i) = a;\n  }\n  sort(card.begin(), card.end(), greater<int>());\n  for (int i = 0; i < N; i++) {\n    if (i == 0 || i % 2 == 0) {\n      a_sum += card.at(i);\n    }\n    else {\n      b_sum += card.at(i);\n    }\n  }\n    cout <<  a_sum - b_sum << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03030",
        "question": "Score : 200 points\n\nProblem StatementYou have decided to write a book introducing good restaurants.\nThere are N restaurants that you want to introduce: Restaurant 1, Restaurant 2, ..., Restaurant N. Restaurant i is in city S_i, and your assessment score of that restaurant on a 100-point scale is P_i.\nNo two restaurants have the same score.\nYou want to introduce the restaurants in the following order:\n\nThe restaurants are arranged in lexicographical order of the names of their cities.\nIf there are multiple restaurants in the same city, they are arranged in descending order of score.\n\nPrint the identification numbers of the restaurants in the order they are introduced in the book.\n\nConstraints\n1 ≤ N ≤ 100\nS is a string of length between 1 and 10 (inclusive) consisting of lowercase English letters.\n0 ≤ P_i ≤ 100\nP_i is an integer.\nP_i ≠ P_j (1 ≤ i &lt; j ≤ N)\n\nInputInput is given from Standard Input in the following format:\nN\nS_1 P_1\n:\nS_N P_N\n\nOutputPrint N lines. The i-th line (1 ≤ i ≤ N) should contain the identification number of the restaurant that is introduced i-th in the book.\n\nSample Input 16\nkhabarovsk 20\nmoscow 10\nkazan 50\nkazan 35\nmoscow 60\nkhabarovsk 40\n\nSample Output 13\n4\n6\n1\n5\n2\n\nThe lexicographical order of the names of the three cities is kazan &lt; khabarovsk &lt; moscow. For each of these cities, the restaurants in it are introduced in descending order of score. Thus, the restaurants are introduced in the order 3,4,6,1,5,2.\n\nSample Input 210\nyakutsk 10\nyakutsk 20\nyakutsk 30\nyakutsk 40\nyakutsk 50\nyakutsk 60\nyakutsk 70\nyakutsk 80\nyakutsk 90\nyakutsk 100\n\nSample Output 210\n9\n8\n7\n6\n5\n4\n3\n2\n1",
        "desc": "This C++ problem involves sorting a list of restaurants first by the lexicographical order of their city names and then by descending scores within the same city, requiring the tracking of their original identification numbers. It tests knowledge of sorting with multiple criteria, string manipulation, and the use of data structures to maintain order, and is classified as medium difficulty.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int N;\n  cin >> N;\n  vector<tuple<string, int, int>> r(N);\n  for (int i = 0; i < N; i++) {\n    string s;\n    int p;\n    cin >> s >> p;\n    r.at(i) = make_tuple(s, p * (-1), i+1);\n  }\n  sort(r.begin(), r.end());\n  for (int i = 0; i < N; i++) {\n    int a, p;\n    string s;\n    tie(s, p, a) = r.at(i);  \n    cout << a << endl;\n  }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03473",
        "question": "Score : 100 points\n\nProblem StatementHow many hours do we have until New Year at M o'clock (24-hour notation) on 30th, December?\n\nConstraints\n1≤M≤23\nM is an integer.\n\nInputInput is given from Standard Input in the following format:\nM\n\nOutputIf we have x hours until New Year at M o'clock on 30th, December, print x.\n\nSample Input 121\n\nSample Output 127\n\nWe have 27 hours until New Year at 21 o'clock on 30th, December.\n\nSample Input 212\n\nSample Output 236",
        "desc": "This C++ problem involves calculating the number of hours remaining until New Year from a specified hour on December 30th, testing the programmer’s ability to perform basic arithmetic operations and handle input/output. It is classified as an **easy** difficulty level problem.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int m;\n  cin >> m;\n  cout << (24 - m) + 24 << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03563",
        "question": "Score : 100 points\n\nProblem StatementTakahashi is a user of a site that hosts programming contests.\nWhen a user competes in a contest, the rating of the user (not necessarily an integer) changes according to the performance of the user, as follows:  \n\nLet the current rating of the user be a.\nSuppose that the performance of the user in the contest is b.\nThen, the new rating of the user will be the avarage of a and b.\n\nFor example, if a user with rating 1 competes in a contest and gives performance 1000, his/her new rating will be 500.5, the average of 1 and 1000.\nTakahashi's current rating is R, and he wants his rating to be exactly G after the next contest.\nFind the performance required to achieve it.  \n\nConstraints\n0 \\leq R, G \\leq 4500\nAll input values are integers.\n\nInputInput is given from Standard Input in the following format:\nR\nG\n\nOutputPrint the performance required to achieve the objective.\n\nSample Input 12002\n2017\n\nSample Output 12032\n\nTakahashi's current rating is 2002.\nIf his performance in the contest is 2032, his rating will be the average of 2002 and 2032, which is equal to the desired rating, 2017.\n\nSample Input 24500\n0\n\nSample Output 2-4500\n\nAlthough the current and desired ratings are between 0 and 4500, the performance of a user can be below 0.",
        "desc": "The problem asks for computing the necessary contest performance value so that the average of the current rating \\( R \\) and the performance \\( b \\) equals a desired rating \\( G \\). It assesses understanding of basic algebra and input/output operations in C++, and is classified as an easy-level programming challenge.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int r, m;\n  cin >> r >> m;\n  cout <<  2 * m - r << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03597",
        "question": "Score : 100 points\n\nProblem StatementWe have an N \\times N square grid.\nWe will paint each square in the grid either black or white.\nIf we paint exactly A squares white, how many squares will be painted black?\n\nConstraints\n1 \\leq N \\leq 100\n0 \\leq A \\leq N^2\n\nInputsInput is given from Standard Input in the following format:\nN\nA\n\nOutputsPrint the number of squares that will be painted black.\n\nSample Input 13\n4\n\nSample Output 15\n\nThere are nine squares in a 3 \\times 3 square grid.\nFour of them will be painted white, so the remaining five squares will be painted black.\n\nSample Input 219\n100\n\nSample Output 2261\n\nSample Input 310\n0\n\nSample Output 3100\n\nAs zero squares will be painted white, all the squares will be painted black.",
        "desc": "This C++ problem requires calculating the number of black squares in an N×N grid by subtracting a given number of white squares (A) from the total squares. It tests fundamental arithmetic operations and basic input/output handling, making it an easy-level question.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, a;\n  cin >> n >> a;\n  cout <<  n * n - a << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03455",
        "question": "Score : 100 points\n\nProblem StatementAtCoDeer the deer found two positive integers, a and b.\nDetermine whether the product of a and b is even or odd.\n\nConstraints\n1 ≤ a,b ≤ 10000\na and b are integers.\n\nInputInput is given from Standard Input in the following format:\na b\n\nOutputIf the product is odd, print Odd; if it is even, print Even.\n\nSample Input 13 4\n\nSample Output 1Even\n\nAs 3 × 4 = 12 is even, print Even.\n\nSample Input 21 21\n\nSample Output 2Odd\n\nAs 1 × 21 = 21 is odd, print Odd.",
        "desc": "This C++ problem assesses understanding of basic arithmetic operations and the use of conditional statements to determine the parity (even or odd) of a product of two integers. It is classified as an easy-level question, making it suitable for beginners learning fundamental programming concepts.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int a, b, c;\n  cin >> a >> b;\n  if ((a * b) % 2 == 0) {\n    cout << \"Even\" << endl;\n  } \n  else {\n    cout << \"Odd\" << endl;\n  }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03494",
        "question": "Score : 200 points\n\nProblem StatementThere are N positive integers written on a blackboard: A_1, ..., A_N.\nSnuke can perform the following operation when all integers on the blackboard are even:\n\nReplace each integer X on the blackboard by X divided by 2.\n\nFind the maximum possible number of operations that Snuke can perform.\n\nConstraints\n1 \\leq N \\leq 200\n1 \\leq A_i \\leq 10^9\n\nInputInput is given from Standard Input in the following format:\nN\nA_1 A_2 ... A_N\n\nOutputPrint the maximum possible number of operations that Snuke can perform.\n\nSample Input 13\n8 12 40\n\nSample Output 12\n\nInitially, [8, 12, 40] are written on the blackboard.\nSince all those integers are even, Snuke can perform the operation.\nAfter the operation is performed once, [4, 6, 20] are written on the blackboard.\nSince all those integers are again even, he can perform the operation.\nAfter the operation is performed twice, [2, 3, 10] are written on the blackboard.\nNow, there is an odd number 3 on the blackboard, so he cannot perform the operation any more.\nThus, Snuke can perform the operation at most twice.\n\nSample Input 24\n5 6 8 10\n\nSample Output 20\n\nSince there is an odd number 5 on the blackboard already in the beginning, Snuke cannot perform the operation at all.\n\nSample Input 36\n382253568 723152896 37802240 379425024 404894720 471526144\n\nSample Output 38",
        "desc": "This C++ problem asks for the maximum number of times a list of positive integers can be simultaneously halved, requiring the implementation of bit manipulation or factor-counting techniques to determine the minimum number of divisible by two across all numbers. It tests understanding of integer operations and efficient looping, and is considered to have an easy to medium difficulty level.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int N, d = 0;\n  int count = 0;\n  bool s = true;\n  cin >> N;\n  for (int i = 0; i < N; i++) {\n    int a, c;\n    cin >> a;\n    c = a;\n    while (s) {\n      if (c % 2 == 0 && c != 0) {\n        c = c / 2;\n        count++;\n      }\n      else {\n        s = false;\n      }\n    }\n    s = true;\n    if (count == 0) {\n      cout << count << endl;\n      break;\n    } \n    else {\n      if (count > d) {\n        d = count;\n      }\n      else {\n        cout << count << endl;\n        break;\n      }\n    }\n    count = 0;\n  }\n}",
        "error_desc": "1. The program calculates the maximum number of divisions by two for a single number instead of finding the minimum across all numbers.\n2. It prematurely outputs the count and breaks the loop when encountering the first number that cannot be divided further.\n3. The condition `c != 0` is unnecessary since all input numbers are positive integers.\n4. The use of the boolean variable `s` incorrectly controls the while loop, causing improper termination of the division process."
    },
    {
        "problem_id": "p03470",
        "question": "Score : 200 points\n\nProblem StatementAn X-layered kagami mochi (X ≥ 1) is a pile of X round mochi (rice cake) stacked vertically where each mochi (except the bottom one) has a smaller diameter than that of the mochi directly below it. For example, if you stack three mochi with diameters of 10, 8 and 6 centimeters from bottom to top in this order, you have a 3-layered kagami mochi; if you put just one mochi, you have a 1-layered kagami mochi.\nLunlun the dachshund has N round mochi, and the diameter of the i-th mochi is d_i centimeters. When we make a kagami mochi using some or all of them, at most how many layers can our kagami mochi have?\n\nConstraints\n1 ≤ N ≤ 100\n1 ≤ d_i ≤ 100\nAll input values are integers.\n\nInputInput is given from Standard Input in the following format:\nN\nd_1\n:\nd_N\n\nOutputPrint the maximum number of layers in a kagami mochi that can be made.\n\nSample Input 14\n10\n8\n8\n6\n\nSample Output 13\n\nIf we stack the mochi with diameters of 10, 8 and 6 centimeters from bottom to top in this order, we have a 3-layered kagami mochi, which is the maximum number of layers.\n\nSample Input 23\n15\n15\n15\n\nSample Output 21\n\nWhen all the mochi have the same diameter, we can only have a 1-layered kagami mochi.\n\nSample Input 37\n50\n30\n50\n100\n50\n80\n30\n\nSample Output 34",
        "desc": "This C++ problem asks for the maximum number of layers in a kagami mochi by finding the longest strictly decreasing subsequence of mochi diameters, using dynamic programming or similar algorithms. It tests understanding of sequence handling and optimization techniques, and is rated as medium difficulty.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int N;\n  cin >> N;\n  vector<int> mochi(N);\n  for (int i = 0; i < N; i++) {\n    cin >> mochi.at(i);\n  }\n  sort(mochi.begin(), mochi.end(), greater<int>());\n  mochi.erase(unique(mochi.begin(), mochi.end()), mochi.end());\n  cout << mochi.size() << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02772",
        "question": "Score: 200 points\n\nProblem Statement\nYou are an immigration officer in the Kingdom of AtCoder. The document carried by an immigrant has some number of integers written on it, and you need to check whether they meet certain criteria.\nAccording to the regulation, the immigrant should be allowed entry to the kingdom if and only if the following condition is satisfied:\n\nAll even numbers written on the document are divisible by 3 or 5.\n\nIf the immigrant should be allowed entry according to the regulation, output APPROVED; otherwise, print DENIED.\n\nNotes\n\nThe condition in the statement can be rephrased as \"If x is an even number written on the document, x is divisible by 3 or 5\".\nHere \"if\" and \"or\" are logical terms.\n\nConstraints\n\nAll values in input are integers.\n1 \\leq N \\leq 100\n1 \\leq A_i \\leq 1000\n\nInput\nInput is given from Standard Input in the following format:\nN\nA_1 A_2 \\dots A_N\n\nOutput\nIf the immigrant should be allowed entry according to the regulation, print APPROVED; otherwise, print DENIED.\n\nSample Input 15\n6 7 9 10 31\n\nSample Output 1APPROVED\n\nThe even numbers written on the document are 6 and 10.\nAll of them are divisible by 3 or 5, so the immigrant should be allowed entry.\n\nSample Input 23\n28 27 24\n\nSample Output 2DENIED\n\n28 violates the condition, so the immigrant should not be allowed entry.",
        "desc": "This C++ problem requires iterating through an array of integers and using conditional statements with modulo operations to verify that every even number is divisible by either 3 or 5, subsequently outputting \"APPROVED\" or \"DENIED\". It tests fundamental concepts such as loops, conditionals, and arithmetic operations, and is considered to have an easy to medium difficulty level.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int N;\n  cin >> N;\n  vector<int> a(N);\n  for (int i = 0; i < N; i++) {\n    cin >>  a[i];\n  }\n  bool jug = false;\n  for (int i = 0; i < N; i++) {\n    if (a[i] % 2 == 0) {\n      if (a[i] % 3 == 0 || a[i] % 5 == 0) {\n        jug = true;\n      }\n      else {\n        jug = false;\n        break;\n      }\n    }\n  }\n  if (jug) {\n    cout << \"APPROVED\" << endl;\n  }\n  else {\n    cout << \"DENIED\" << endl;\n  }\n}",
        "error_desc": "1. The boolean variable `jug` is initialized to `false`, causing the program to output \"DENIED\" when there are no even numbers.\n2. The program does not include the test case number before \"APPROVED\" or \"DENIED\" in the output.\n3. The program incorrectly sets `jug` to `true` upon finding any even number divisible by 3 or 5, instead of ensuring all even numbers meet the condition."
    },
    {
        "problem_id": "p02778",
        "question": "Score : 200 points\n\nProblem Statement\nGiven is a string S. Replace every character in S with x and print the result.\n\nConstraints\n\nS is a string consisting of lowercase English letters.\nThe length of S is between 1 and 100 (inclusive).\n\nInput\nInput is given from Standard Input in the following format:\nS\n\nOutput\nReplace every character in S with x and print the result.\n\nSample Input 1sardine\n\nSample Output 1xxxxxxx\n\nReplacing every character in S with x results in xxxxxxx.\n\nSample Input 2xxxx\n\nSample Output 2xxxx\n\nSample Input 3gone\n\nSample Output 3xxxx",
        "desc": "This C++ problem assesses understanding of string manipulation and iteration by requiring the replacement of every character in a given string with 'x'. It is categorized as an easy, beginner-level exercise suitable for those new to programming.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  string S;\n  cin >> S;\n  for (int i = 0; i < S.size(); i++) {\n    S.at(i) = 'x';\n  }\n  cout << S << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02790",
        "question": "Score : 200 points\n\nProblem StatementGiven are 1-digit positive integers a and b. Consider these two strings: the concatenation of b copies of the digit a, and the concatenation of a copies of the digit b. Which of these is lexicographically smaller?\n\nConstraints\n1 \\leq a \\leq 9\n1 \\leq b \\leq 9\na and b are integers.\n\nInputInput is given from Standard Input in the following format:\na b\n\nOutputPrint the lexicographically smaller of the two strings. (If the two strings are equal, print one of them.)\n\nSample Input 14 3\n\nSample Output 13333\n\nWe have two strings 444 and 3333. Between them, 3333 is the lexicographically smaller.\n\nSample Input 27 7\n\nSample Output 27777777",
        "desc": "This C++ problem requires creating and comparing two strings by concatenating one digit multiple times, testing skills in string manipulation and lexicographical comparison. It is considered to have an easy to intermediate difficulty level.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int a, b, c, d;\n  cin >> a >> b;\n  if (a > b) {\n    c = a;\n    d = b;\n  }\n  else {\n    c = b;\n    d = a;\n  }\n  for (int i = 0; i < c; i++) {\n    cout << d;\n  }\n  cout << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02830",
        "question": "Score : 200 points\n\nProblem StatementGiven are strings s and t of length N each, both consisting of lowercase English letters.\nLet us form a new string by alternating the characters of S and the characters of T, as follows: the first character of S, the first character of T, the second character of S, the second character of T, ..., the N-th character of S, the N-th character of T. Print this new string.\n\nConstraints\n1 \\leq N \\leq 100\n|S| = |T| = N\nS and T are strings consisting of lowercase English letters.\n\nInputInput is given from Standard Input in the following format:\nN\nS T\n\nOutputPrint the string formed.\n\nSample Input 12\nip cc\n\nSample Output 1icpc\n\nSample Input 28\nhmhmnknk uuuuuuuu\n\nSample Output 2humuhumunukunuku\n\nSample Input 35\naaaaa aaaaa\n\nSample Output 3aaaaaaaaaa",
        "desc": "This problem requires merging two equal-length strings by alternating their characters, testing fundamental string manipulation and loop control in C++. It is classified as an easy-level programming challenge.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int N;\n  cin >> N;\n  string a, b, S;\n  cin >> a >> b;\n  for (int i = 0; i < N; i++) {\n    char c_a = a.at(i);\n    char c_b = b.at(i);\n    S = S + c_a + c_b;\n  }\n  cout << S << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02848",
        "question": "Score : 200 points\n\nProblem StatementWe have a string S consisting of uppercase English letters. Additionally, an integer N will be given.\nShift each character of S by N in alphabetical order (see below), and print the resulting string.\nWe assume that A follows Z. For example, shifting A by 2 results in C (A \\to B \\to C), and shifting Y by 3 results in B (Y \\to Z \\to A \\to B).\n\nConstraints\n0 \\leq N \\leq 26\n1 \\leq |S| \\leq 10^4\nS consists of uppercase English letters.\n\nInputInput is given from Standard Input in the following format:\nN\nS\n\nOutputPrint the string resulting from shifting each character of S by N in alphabetical order.\n\nSample Input 12\nABCXYZ\n\nSample Output 1CDEZAB\n\nNote that A follows Z.\n\nSample Input 20\nABCXYZ\n\nSample Output 2ABCXYZ\n\nSample Input 313\nABCDEFGHIJKLMNOPQRSTUVWXYZ\n\nSample Output 3NOPQRSTUVWXYZABCDEFGHIJKLM",
        "desc": "This C++ problem assesses string manipulation and character arithmetic, specifically shifting uppercase letters with wrap-around using modular operations. It is classified as a medium difficulty level, suitable for programmers with intermediate knowledge of string handling and basic algorithm implementation.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  char s[10010];\n  cin >> n;\n  cin >> s;\n  int len = strlen(s);\n  for (int i = 0; i < len; i++) {\n    int x = s[i] -'A';\n    x = (x + n) % 26;\n    cout << char('A' + x);\n  }\n  cout << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02812",
        "question": "Score : 200 points\n\nProblem StatementWe have a string S of length N consisting of uppercase English letters.\nHow many times does ABC occur in S as contiguous subsequences (see Sample Inputs and Outputs)?\n\nConstraints\n3 \\leq N \\leq 50\nS consists of uppercase English letters.\n\nInputInput is given from Standard Input in the following format:\nN\nS\n\nOutputPrint number of occurrences of ABC in S as contiguous subsequences.\n\nSample Input 110\nZABCDBABCQ\n\nSample Output 12\n\nTwo contiguous subsequences of S are equal to ABC: the 2-nd through 4-th characters, and the 7-th through 9-th characters.\n\nSample Input 219\nTHREEONEFOURONEFIVE\n\nSample Output 20\n\nNo contiguous subsequences of S are equal to ABC.\n\nSample Input 333\nABCCABCBABCCABACBCBBABCBCBCBCABCB\n\nSample Output 35",
        "desc": "This C++ problem involves counting the number of times the exact substring \"ABC\" appears consecutively within a given string, testing skills in string traversal and pattern matching. It is classified as a medium difficulty level due to the need for careful implementation within the specified constraints.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  string s;;\n  cin >> n >> s;\n  int ans = 0;\n  for (int i = 0; i < n - 3; i++) {\n    if (s[i] == 'A' && s[i + 1] == 'B' && s[i + 2] == 'C') ans++;\n  }\n  cout << ans << endl;\n}",
        "error_desc": "1. The loop condition uses `i < n - 3` instead of `i < n - 2`, causing some \"ABC\" substrings to be missed.\n2. As a result, the program does not check the last possible substring when `n` is exactly 3.\n3. There is an unnecessary extra semicolon after the declaration of `string s`."
    },
    {
        "problem_id": "p02880",
        "question": "Score : 200 points\n\nProblem StatementHaving learned the multiplication table, Takahashi can multiply two integers between 1 and 9 (inclusive) together.\nGiven an integer N, determine whether N can be represented as the product of two integers between 1 and 9. If it can, print Yes; if it cannot, print No.\n\nConstraints\n1 \\leq N \\leq 100\nN is an integer.\n\nInputInput is given from Standard Input in the following format:\nN\n\nOutputIf N can be represented as the product of two integers between 1 and 9 (inclusive), print Yes; if it cannot, print No.\n\nSample Input 110\n\nSample Output 1Yes\n\n10 can be represented as, for example, 2 \\times 5.\n\nSample Input 250\n\nSample Output 2No\n\n50 cannot be represented as the product of two integers between 1 and 9.\n\nSample Input 381\n\nSample Output 3Yes",
        "desc": "This C++ problem assesses the ability to determine if a given integer \\( N \\) (1 ≤ \\( N \\) ≤ 100) can be expressed as the product of two single-digit integers (1–9). It tests fundamental concepts in loops and factorization, and is categorized as an easy-level challenge.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n  bool jug = false;\n  for (int i = 1; i < 10; i++) {\n    for (int j = 1; j < 10; j++) {\n      if (i * j == n) {\n        jug = true;\n      }\n    }\n  }\n  if (jug) {\n    cout << \"Yes\" << endl;\n  } \n  else {\n    cout << \"No\" << endl;\n  }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02886",
        "question": "Score : 200 points\n\nProblem StatementIt's now the season of TAKOYAKI FESTIVAL!\nThis year, N takoyaki (a ball-shaped food with a piece of octopus inside) will be served. The deliciousness of the i-th takoyaki is d_i.\nAs is commonly known, when you eat two takoyaki of deliciousness x and y together, you restore x \\times y health points.\nThere are \\frac{N \\times (N - 1)}{2} ways to choose two from the N takoyaki served in the festival. For each of these choices, find the health points restored from eating the two takoyaki, then compute the sum of these \\frac{N \\times (N - 1)}{2} values.\n\nConstraints\nAll values in input are integers.\n2 \\leq N \\leq 50\n0 \\leq d_i \\leq 100\n\nInputInput is given from Standard Input in the following format:\nN\nd_1 d_2 ... d_N\n\nOutputPrint the sum of the health points restored from eating two takoyaki over all possible choices of two takoyaki from the N takoyaki served.\n\nSample Input 13\n3 1 2\n\nSample Output 111\n\nThere are three possible choices:\n\nEat the first and second takoyaki. You will restore 3 health points.\nEat the second and third takoyaki. You will restore 2 health points.\nEat the first and third takoyaki. You will restore 6 health points.\n\nThe sum of these values is 11.\n\nSample Input 27\n5 0 7 8 3 3 2\n\nSample Output 2312",
        "desc": "The problem requires iterating through all unique pairs of an array of integers to calculate and sum the products of each pair, testing understanding of nested loops and combinatorial pair generation in C++. It is considered to have a medium difficulty level.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n  vector<int> d(n);\n  for (int i = 0; i < n; i++) {\n    cin >> d.at(i);\n  }\n  int sum = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j <  n; j++) {\n      sum += d.at(i) * d.at(j);\n    }\n  }\n  cout << sum << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03086",
        "question": "Score : 200 points\n\nProblem StatementYou are given a string S consisting of uppercase English letters. Find the length of the longest ACGT string that is a substring (see Notes) of S.\nHere, a ACGT string is a string that contains no characters other than A, C, G and T.\n\nNotesA substring of a string T is a string obtained by removing zero or more characters from the beginning and the end of T.\nFor example, the substrings of ATCODER include TCO, AT, CODER, ATCODER and  (the empty string), but not AC.\n\nConstraints\nS is a string of length between 1 and 10 (inclusive).\nEach character in S is an uppercase English letter.\n\nInputInput is given from Standard Input in the following format:\nS\n\nOutputPrint the length of the longest ACGT string that is a substring of S.\n\nSample Input 1ATCODER\n\nSample Output 13\n\nAmong the ACGT strings that are substrings of ATCODER, the longest one is ATC.\n\nSample Input 2HATAGAYA\n\nSample Output 25\n\nAmong the ACGT strings that are substrings of HATAGAYA, the longest one is ATAGA.\n\nSample Input 3SHINJUKU\n\nSample Output 30\n\nAmong the ACGT strings that are substrings of SHINJUKU, the longest one is  (the empty string).",
        "desc": "This problem assesses knowledge of string manipulation, substring extraction, and character filtering in C++. It is classified as a medium difficulty challenge, requiring the ability to iterate through the string to identify and determine the longest contiguous substring containing only the characters A, C, G, and T.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  string S;\n  vector<int> jug(10);\n  cin >> S;\n  for (int i = 0; i < S.size(); i++) {\n    for (int j = i; j < S.size(); j++) {\n      if (S.at(j) == 'A' || S.at(j) == 'C' || S.at(j) == 'G' || S.at(j) == 'T') {\n        jug.at(i)++;\n      }\n      else {\n        break;\n      }\n    }  \n  }\n  sort(jug.begin(), jug.end(), greater<>());\n  cout << jug.at(0) << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03106",
        "question": "Score : 200 points\n\nProblem StatementYou are given positive integers A and B.\nFind the K-th largest positive integer that divides both A and B.\nThe input guarantees that there exists such a number.\n\nConstraints\nAll values in input are integers.\n1 \\leq A, B \\leq 100\nThe K-th largest positive integer that divides both A and B exists.\nK \\geq 1\n\nInputInput is given from Standard Input in the following format:\nA B K\n\nOutputPrint the K-th largest positive integer that divides both A and B.\n\nSample Input 18 12 2\n\nSample Output 12\n\nThree positive integers divides both 8 and 12: 1, 2 and 4.\nAmong them, the second largest is 2.\n\nSample Input 2100 50 4\n\nSample Output 25\n\nSample Input 31 1 1\n\nSample Output 31",
        "desc": "This C++ problem asks for finding the K-th largest common divisor of two given integers, testing concepts such as determining common factors and implementing sorting or ordered selection. It is considered to be of moderate difficulty.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int a, b, k, d = 0;\n  vector<int> vec;\n  cin >> a >> b >> k;\n  if (a > b) {\n    d = b;\n  }\n  else {\n    d = a;\n  }\n  for (int i = 1; i <= d; i++) {\n    if (a % i == 0 && b % i == 0) {\n      vec.push_back(i);\n    }\n  }\n  sort(vec.begin(), vec.end(), greater<>());\n  cout << vec.at(k-1) << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02952",
        "question": "Score : 200 points\n\nProblem StatementGiven is an integer N. Find the number of positive integers less than or equal to N that have an odd number of digits (in base ten without leading zeros).\n\nConstraints\n1 \\leq N \\leq 10^5\n\nInputInput is given from Standard Input in the following format:\nN\n\nOutputPrint the number of positive integers less than or equal to N that have an odd number of digits.\n\nSample Input 111\n\nSample Output 19\n\nAmong the positive integers less than or equal to 11, nine integers have an odd number of digits: 1, 2, \\ldots, 9.\n\nSample Input 2136\n\nSample Output 246\n\nIn addition to 1, 2, \\ldots, 9, another 37 integers also have an odd number of digits: 100, 101, \\ldots, 136.\n\nSample Input 3100000\n\nSample Output 390909",
        "desc": "This C++ problem asks to calculate how many positive integers up to a given N have an odd number of digits, testing understanding of digit counting and range-based logic. It is considered an easy to medium difficulty level challenge.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n  int ans = 0;\n  for (int i = 0; i <= n; i++) {\n    int cnt = 0;\n    int num = i;\n    while (num > 0) {\n      cnt++;\n      num /= 10;\n    }\n    if (cnt % 2 == 1) {\n      ans++;\n    }\n  }\n  cout << ans << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03281",
        "question": "Score: 200 points\n\nProblem Statement\nThe number 105 is quite special - it is odd but still it has eight divisors.\nNow, your task is this: how many odd numbers with exactly eight positive divisors are there between 1 and N (inclusive)?\n\nConstraints\n\nN is an integer between 1 and 200 (inclusive).\n\nInput\nInput is given from Standard Input in the following format:\nN\n\nOutput\nPrint the count.\n\nSample Input 1105\n\nSample Output 11\n\nAmong the numbers between 1 and 105, the only number that is odd and has exactly eight divisors is 105.\n\nSample Input 27\n\nSample Output 20\n\n1 has one divisor. 3, 5 and 7 are all prime and have two divisors. Thus, there is no number that satisfies the condition.",
        "desc": "This C++ problem requires understanding of number theory concepts such as divisor counting and prime factorization to identify odd numbers with exactly eight divisors within a range. It is classified as medium difficulty, testing the ability to implement efficient iteration and conditional logic within given constraints.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n  vector<int> jug(n);\n  int count = 0;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) {\n      if (i % j == 0 && i % 2 == 1) {\n        jug.at(i-1)++;\n      }  \n    }\n    if (jug.at(i-1) == 8) {\n      count = 1;\n    }\n  } \n  cout << count << endl;\n}",
        "error_desc": "1. The program assigns `count = 1` instead of incrementing `count` when an odd number with exactly eight divisors is found.\n2. The inner loop unnecessarily iterates `j` up to `n` instead of up to `i`, causing redundant computations.\n3. The program outputs `count` as 1 if any qualifying number exists, rather than the total number of such numbers."
    },
    {
        "problem_id": "p02861",
        "question": "Score : 300 points\n\nProblem StatementThere are N towns in a coordinate plane. Town i is located at coordinates (x_i, y_i). The distance between Town i and Town j is \\sqrt{\\left(x_i-x_j\\right)^2+\\left(y_i-y_j\\right)^2}.\nThere are N! possible paths to visit all of these towns once. Let the length of a path be the distance covered when we start at the first town in the path, visit the second, third, \\dots, towns, and arrive at the last town (assume that we travel in a straight line from a town to another). Compute the average length of these N! paths.\n\nConstraints\n2 \\leq N \\leq 8\n-1000 \\leq x_i \\leq 1000\n-1000 \\leq y_i \\leq 1000\n\\left(x_i, y_i\\right) \\neq \\left(x_j, y_j\\right) (if i \\neq j)\n(Added 21:12 JST) All values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nN\nx_1 y_1\n:\nx_N y_N\n\nOutputPrint the average length of the paths.\nYour output will be judges as correct when the absolute difference from the judge's output is at most 10^{-6}.\n\nSample Input 13\n0 0\n1 0\n0 1\n\nSample Output 12.2761423749\n\nThere are six paths to visit the towns: 1 → 2 → 3, 1 → 3 → 2, 2 → 1 → 3, 2 → 3 → 1, 3 → 1 → 2, and 3 → 2 → 1.\nThe length of the path 1 → 2 → 3 is \\sqrt{\\left(0-1\\right)^2+\\left(0-0\\right)^2} + \\sqrt{\\left(1-0\\right)^2+\\left(0-1\\right)^2} = 1+\\sqrt{2}.\nBy calculating the lengths of the other paths in this way, we see that the average length of all routes is:\n\\frac{\\left(1+\\sqrt{2}\\right)+\\left(1+\\sqrt{2}\\right)+\\left(2\\right)+\\left(1+\\sqrt{2}\\right)+\\left(2\\right)+\\left(1+\\sqrt{2}\\right)}{6} = 2.276142...\n\nSample Input 22\n-879 981\n-866 890\n\nSample Output 291.9238815543\n\nThere are two paths to visit the towns: 1 → 2 and 2 → 1. These paths have the same length.\n\nSample Input 38\n-406 10\n512 859\n494 362\n-955 -475\n128 553\n-986 -885\n763 77\n449 310\n\nSample Output 37641.9817824387",
        "desc": "This problem involves calculating the average length of all possible permutations of visiting N towns on a coordinate plane, testing knowledge of permutation generation, computational geometry (distance calculations), and brute-force enumeration techniques. It is categorized as a medium difficulty level problem, suitable for intermediate C++ programmers.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint n, x[10], y[10];\ndouble dist(int i, int j) {\n  double dx = x[i] - x[j];\n  double dy = y[i] - y[j];\n  return sqrt(pow(dx, 2) + pow(dy, 2));\n}\nint main() {\n  cin >> n;\n  vector<int> v(n); \n  for (int i = 1; i <= n; i++) cin >> x[i] >> y[i];\n  for(int i = 0; i < n; i++) v[i] = i + 1;\n  double sum = 0.0;  \n  do {\n    for (int i = 0; i < n - 1; i++) {\n      sum += dist(v[i], v[i+1]);\n    }  \n  } while(next_permutation(v.begin(), v.end()));\n  int fac = 1;\n  for (int i = 2; i <= n; i++) {\n    fac *= i;\n  }\n  cout << fixed << setprecision(10) << sum /fac << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02813",
        "question": "Score : 300 points\n\nProblem StatementWe have two permutations P and Q of size N (that is, P and Q are both rearrangements of (1,~2,~...,~N)).\nThere are N! possible permutations of size N. Among them, let P and Q be the a-th and b-th lexicographically smallest permutations, respectively. Find |a - b|.\n\nNotesFor two sequences X and Y, X is said to be lexicographically smaller than Y if and only if there exists an integer k such that X_i = Y_i~(1 \\leq i &lt; k) and X_k &lt; Y_k.\n\nConstraints\n2 \\leq N \\leq 8\nP and Q are permutations of size N.\n\nInputInput is given from Standard Input in the following format:\nN\nP_1 P_2 ... P_N\nQ_1 Q_2 ... Q_N\n\nOutputPrint |a - b|.\n\nSample Input 13\n1 3 2\n3 1 2\n\nSample Output 13\n\nThere are 6 permutations of size 3: (1,~2,~3), (1,~3,~2), (2,~1,~3), (2,~3,~1), (3,~1,~2), and (3,~2,~1). Among them, (1,~3,~2) and (3,~1,~2) come 2-nd and 5-th in lexicographical order, so the answer is |2 - 5| = 3.\n\nSample Input 28\n7 3 5 4 2 1 6 8\n3 8 2 5 4 6 7 1\n\nSample Output 217517\n\nSample Input 33\n1 2 3\n1 2 3\n\nSample Output 30",
        "desc": "This problem requires determining the lexicographical ranks of two given permutations and calculating the absolute difference between these ranks. It tests concepts related to permutations, lexicographical ordering, and efficient rank computation methods, and is categorized as a **hard** difficulty level.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n  vector<int> P(n), Q(n), A(n), B(n); \n  for (int i = 0; i < n; i++) cin >> P.at(i);\n  for (int i = 0; i < n; i++) cin >> Q.at(i);\n  for (int i = 0; i < n; i++) A.at(i) = i + 1;\n  int count = 0, x = 0, y = 0;\n  do {\n    count++;\n    for (int i = 0; i < n; i++) B.at(i) = A.at(i);\n    if (B == P) x = count;\n    if (B == Q) y = count;\n  } while(next_permutation(A.begin(), A.end()));\n  cout << abs(x - y) << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02621",
        "question": "Score : 100 points\n\nProblem StatementGiven an integer a as input, print the value a + a^2 + a^3.\n\nConstraints\n1 \\leq a \\leq 10\na is an integer.\n\nInputInput is given from Standard Input in the following format:\na\n\nOutputPrint the value a + a^2 + a^3 as an integer.\n\nSample Input 12\n\nSample Output 114\n\nWhen a = 2, we have a + a^2 + a^3 = 2 + 2^2 + 2^3 = 2 + 4 + 8 = 14.\nPrint the answer as an input. Outputs such as 14.0 will be judged as incorrect.\n\nSample Input 210\n\nSample Output 21110",
        "desc": "This C++ problem tasks the programmer with reading an integer input and calculating the sum of the integer, its square, and its cube, thereby testing fundamental arithmetic operations and basic input/output handling. It is classified as an easy-level question appropriate for beginners.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int a;\n  cin >> a;\n  cout << a + a*a + a*a*a << endl; \n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02622",
        "question": "Score : 200 points\n\nProblem StatementGiven are strings S and T. Consider changing S to T by repeating the operation below. Find the minimum number of operations required to do so.\nOperation: Choose one character of S and replace it with a different character.\n\nConstraints\nS and T have lengths between 1 and 2\\times 10^5 (inclusive).\nS and T consists of lowercase English letters.\nS and T have equal lengths.\n\nInputInput is given from Standard Input in the following format:\nS\nT\n\nOutputPrint the answer.\n\nSample Input 1cupofcoffee\ncupofhottea\n\nSample Output 14\n\nWe can achieve the objective in four operations, such as the following:\n\nFirst, replace the sixth character c with h.\nSecond, replace the eighth character f with t.\nThird, replace the ninth character f with t.\nFourth, replace the eleventh character e with a.\n\nSample Input 2abcde\nbcdea\n\nSample Output 25\n\nSample Input 3apple\napple\n\nSample Output 30\n\nNo operations may be needed to achieve the objective.",
        "desc": "This C++ problem requires determining the minimum number of single-character replacement operations needed to transform one string into another of equal length, efficiently handling strings up to 200,000 characters. It tests knowledge of string manipulation, character comparison, and optimization techniques for large input sizes, and is classified as medium to hard difficulty.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  string S, T;\n  cin >> S >> T;\n  int count = 0;\n  for (int i = 0; i < S.size(); i++) {\n    if (S.at(i) != T.at(i)) count++; \n  }\n  cout << count << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02623",
        "question": "Score : 300 points\n\nProblem StatementWe have two desks: A and B. Desk A has a vertical stack of N books on it, and Desk B similarly has M books on it.\nIt takes us A_i minutes to read the i-th book from the top on Desk A (1 \\leq i \\leq N), and B_i minutes to read the i-th book from the top on Desk B (1 \\leq i \\leq M).\nConsider the following action:\n\nChoose a desk with a book remaining, read the topmost book on that desk, and remove it from the desk.\n\nHow many books can we read at most by repeating this action so that it takes us at most K minutes in total? We ignore the time it takes to do anything other than reading.\n\nConstraints\n1 \\leq N, M \\leq 200000\n1 \\leq K \\leq 10^9\n1 \\leq A_i, B_i \\leq 10^9\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nN M K\nA_1 A_2 \\ldots A_N\nB_1 B_2 \\ldots B_M\n\nOutputPrint an integer representing the maximum number of books that can be read.\n\nSample Input 13 4 240\n60 90 120\n80 150 80 150\n\nSample Output 13\n\nIn this case, it takes us 60, 90, 120 minutes to read the 1-st, 2-nd, 3-rd books from the top on Desk A, and 80, 150, 80, 150 minutes to read the 1-st, 2-nd, 3-rd, 4-th books from the top on Desk B, respectively.\nWe can read three books in 230 minutes, as shown below, and this is the maximum number of books we can read within 240 minutes.\n\nRead the topmost book on Desk A in 60 minutes, and remove that book from the desk.\nRead the topmost book on Desk B in 80 minutes, and remove that book from the desk.\nRead the topmost book on Desk A in 90 minutes, and remove that book from the desk.\n\nSample Input 23 4 730\n60 90 120\n80 150 80 150\n\nSample Output 27\n\nSample Input 35 4 1\n1000000000 1000000000 1000000000 1000000000 1000000000\n1000000000 1000000000 1000000000 1000000000\n\nSample Output 30\n\nWatch out for integer overflows.",
        "desc": "This C++ problem challenges programmers to determine the maximum number of books that can be read from two stacks within a given time limit, requiring efficient handling of large input sizes. It tests concepts such as greedy algorithms, prefix sums, and two-pointer techniques, and is classified as a hard-level problem.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, m, k;\n  cin >> n >> m >> k;\n  int a[n], b[n];\n  for (int i = 0; i < n; i++) cin >> a[i];\n  for (int i = 0; i < m; i++) cin >> b[i];\n  int ac = 0, bc = 0, sum = 0, i = 0;\n  while (k >= sum) {\n    if (a[i-ac] >= b[i-bc]) {\n      ac++;\n      if (k < sum + b[i-bc]) break;\n      sum += b[i-bc];\n    }\n    else {\n      bc++;\n      if (k < sum + a[i-ac]) break;\n      sum += a[i-ac];\n    }  \n    i++;\n  }  \n  cout << i << endl;\n}",
        "error_desc": "1. The array `b` is declared with size `n` instead of `m`.\n2. Variable-length arrays `a[n]` and `b[n]` are used, which are not standard in C++.\n3. The `sum` variable is of type `int` and may overflow with large input values.\n4. Incorrect index calculations `a[i - ac]` and `b[i - bc]` can lead to out-of-bounds access."
    },
    {
        "problem_id": "p02624",
        "question": "Score : 400 points\n\nProblem StatementFor a positive integer X, let f(X) be the number of positive divisors of X.\nGiven a positive integer N, find \\sum_{K=1}^N K\\times f(K).\n\nConstraints\n1 \\leq N \\leq 10^7\n\nInputInput is given from Standard Input in the following format:\nN\n\nOutputPrint the value \\sum_{K=1}^N K\\times f(K).\n\nSample Input 14\n\nSample Output 123\n\nWe have f(1)=1, f(2)=2, f(3)=2, and f(4)=3, so the answer is 1\\times 1 + 2\\times 2 + 3\\times 2 + 4\\times 3 =23.\n\nSample Input 2100\n\nSample Output 226879\n\nSample Input 310000000\n\nSample Output 3838627288460105\n\nWatch out for overflows.",
        "desc": "This C++ problem asks for the computation of the sum \\( \\sum_{K=1}^N K \\times f(K) \\), where \\( f(K) \\) is the number of positive divisors of \\( K \\), requiring efficient algorithms for divisor counting and handling large input sizes up to \\( 10^7 \\). It tests understanding of number theory concepts, optimized iteration or sieve techniques, and careful management of data types to prevent overflow, categorizing it as a challenging medium-to-hard level problem.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nint main() {\n  int n;\n  ll ans = 0, sum = 0;\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    ll e = n / i;\n    ll l = e * i;\n    sum += (i + l) * e / 2; \n  }  \n  cout << sum << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02681",
        "question": "Score : 100 points\n\nProblem StatementTakahashi wants to be a member of some web service.\nHe tried to register himself with the ID S, which turned out to be already used by another user.\nThus, he decides to register using a string obtained by appending one character at the end of S as his ID.\nHe is now trying to register with the ID T. Determine whether this string satisfies the property above.\n\nConstraints\nS and T are strings consisting of lowercase English letters.\n1 \\leq |S| \\leq 10\n|T| = |S| + 1\n\nInputInput is given from Standard Input in the following format:\nS\nT\n\nOutputIf T satisfies the property in Problem Statement, print Yes; otherwise, print No.\n\nSample Input 1chokudai\nchokudaiz\n\nSample Output 1Yes\n\nchokudaiz can be obtained by appending z at the end of chokudai.\n\nSample Input 2snuke\nsnekee\n\nSample Output 2No\n\nsnekee cannot be obtained by appending one character at the end of snuke.\n\nSample Input 3a\naa\n\nSample Output 3Yes",
        "desc": "This C++ problem assesses the ability to manipulate and compare strings, specifically by checking if one string is formed by appending a single character to another. It tests fundamental string operations and conditional logic, and is considered to have an easy difficulty level.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  string s, t;\n  cin >> s >> t;\n  if (s.size() + 1 == t.size()) {\n    int count = 0;\n    for (int i = 0; i < s.size(); i++) {\n      if (s.at(i) == t.at(i)) {\n        count++;\n      }\n      else {\n        cout << \"No\" << endl;\n        return 0;\n      }  \n    }\n    if (s.size() == count) cout << \"Yes\" << endl;\n  } else cout << \"No\" << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02682",
        "question": "Score : 200 points\n\nProblem StatementWe have A cards, each of which has an integer 1 written on it. Similarly, we also have B cards with 0s and C cards with -1s.\nWe will pick up K among these cards. What is the maximum possible sum of the numbers written on the cards chosen?\n\nConstraints\nAll values in input are integers.\n0 \\leq A, B, C\n1 \\leq K \\leq A + B + C \\leq 2 \\times 10^9\n\nInputInput is given from Standard Input in the following format:\nA B C K\n\nOutputPrint the maximum possible sum of the numbers written on the cards chosen.\n\nSample Input 12 1 1 3\n\nSample Output 12\n\nConsider picking up two cards with 1s and one card with a 0.\nIn this case, the sum of the numbers written on the cards is 2, which is the maximum possible value.\n\nSample Input 21 2 3 4\n\nSample Output 20\n\nSample Input 32000000000 0 0 2000000000\n\nSample Output 32000000000",
        "desc": "This C++ problem involves selecting **K** cards from three groups containing **A** cards with `1`, **B** cards with `0`, and **C** cards with `-1` to maximize the total sum. It tests understanding of greedy algorithms and efficient computation with large numerical constraints, and is classified as a **medium difficulty** level problem.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int a, b, c, k, t, t2, sum = 0;\n  cin >> a >> b >> c >> k;\n  sum = a * 1;\n  t = k - a;\n  sum += t * 0;\n  t = t - b;\n  sum += -t;\n  cout << sum << endl;\n}",
        "error_desc": "1. The variables are declared as `int`, which can cause overflow since inputs can be up to 2 × 10⁹.\n2. The code sets `sum = a * 1` without ensuring that `a` does not exceed `k`, potentially selecting more cards than allowed.\n3. It incorrectly calculates `sum += -t` without verifying if `t` is positive, leading to an incorrect sum when `k` is less than `a`.\n4. The logic for adding zeros with `sum += t * 0` is unnecessary and does not properly account for the remaining card selections."
    },
    {
        "problem_id": "p02594",
        "question": "Score : 100 points\n\nProblem StatementYou will turn on the air conditioner if, and only if, the temperature of the room is 30 degrees Celsius or above.\nThe current temperature of the room is X degrees Celsius. Will you turn on the air conditioner?\n\nConstraints\n-40 \\leq X \\leq 40\nX is an integer.\n\nInputInput is given from Standard Input in the following format:\nX\n\nOutputPrint Yes if you will turn on the air conditioner; print No otherwise.\n\nSample Input 125\n\nSample Output 1No\n\nSample Input 230\n\nSample Output 2Yes",
        "desc": "This C++ problem evaluates the ability to perform input/output operations and apply conditional statements to make decisions based on numerical comparisons. It is classified as an easy-level question, suitable for beginners practicing basic programming fundamentals.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int x;\n  cin >> x;\n  if (x >= 30) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02595",
        "question": "Score : 200 points\n\nProblem StatementWe have N points in the two-dimensional plane. The coordinates of the i-th point are (X_i,Y_i).\nAmong them, we are looking for the points such that the distance from the origin is at most D. How many such points are there?\nWe remind you that the distance between the origin and the point (p, q) can be represented as \\sqrt{p^2+q^2}.\n\nConstraints\n1 \\leq N \\leq 2\\times 10^5\n0 \\leq D \\leq 2\\times 10^5\n|X_i|,|Y_i| \\leq 2\\times 10^5\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nN D\nX_1 Y_1\n\\vdots\nX_N Y_N\n\nOutputPrint an integer representing the number of points such that the distance from the origin is at most D.\n\nSample Input 14 5\n0 5\n-2 4\n3 4\n4 -4\n\nSample Output 13\n\nThe distance between the origin and each of the given points is as follows:\n\n\\sqrt{0^2+5^2}=5\n\\sqrt{(-2)^2+4^2}=4.472\\ldots\n\\sqrt{3^2+4^2}=5\n\\sqrt{4^2+(-4)^2}=5.656\\ldots\n\nThus, we have three points such that the distance from the origin is at most 5.\n\nSample Input 212 3\n1 1\n1 1\n1 1\n1 1\n1 2\n1 3\n2 1\n2 2\n2 3\n3 1\n3 2\n3 3\n\nSample Output 27\n\nMultiple points may exist at the same coordinates.\n\nSample Input 320 100000\n14309 -32939\n-56855 100340\n151364 25430\n103789 -113141\n147404 -136977\n-37006 -30929\n188810 -49557\n13419 70401\n-88280 165170\n-196399 137941\n-176527 -61904\n46659 115261\n-153551 114185\n98784 -6820\n94111 -86268\n-30401 61477\n-55056 7872\n5901 -163796\n138819 -185986\n-69848 -96669\n\nSample Output 36",
        "desc": "This C++ problem requires counting how many of up to 200,000 two-dimensional points lie within a specified Euclidean distance from the origin, testing concepts such as efficient iteration, distance calculation, and handling large inputs. It is considered to have a medium to high difficulty level.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, d;\n  cin >> n >> d;\n  int x, y, count = 0;\n  for (int i = 0; i < n; i++) {\n    cin >> x >> y;\n    double dis = sqrt(pow(x,2) + pow(y,2));\n    if (d >= dis) count++;\n  }\n  cout << count << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02596",
        "question": "Score : 300 points\n\nProblem StatementTakahashi loves the number 7 and multiples of K.\nWhere is the first occurrence of a multiple of K in the sequence 7,77,777,\\ldots? (Also see Output and Sample Input/Output below.)\nIf the sequence contains no multiples of K, print -1 instead.\n\nConstraints\n1 \\leq K \\leq 10^6\nK is an integer.\n\nInputInput is given from Standard Input in the following format:\nK\n\nOutputPrint an integer representing the position of the first occurrence of a multiple of K. (For example, if the first occurrence is the fourth element of the sequence, print 4.)\n\nSample Input 1101\n\nSample Output 14\n\nNone of 7, 77, and 777 is a multiple of 101, but 7777 is.\n\nSample Input 22\n\nSample Output 2-1\n\nAll elements in the sequence are odd numbers; there are no multiples of 2.\n\nSample Input 3999983\n\nSample Output 3999982",
        "desc": "This C++ problem requires finding the first position in a sequence of numbers composed of repeated digit '7' that is divisible by a given integer K, testing concepts such as modular arithmetic, number construction without overflow, and efficient search techniques. It is categorized as a medium to hard difficulty level problem due to the need for optimized algorithms to handle large values of K (up to 10⁶).",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int k, L, sum = 0;\n  cin >> k;\n  if (k % 2 == 0 || k % 5 == 0) sum = -1;\n  else {\n    L = 9 * k;\n    if (L % 7 == 0) L /= 7;\n    int i = 10;\n    bool jug = true;\n    while (jug) {\n      sum++;\n      i %= L;\n      if (i == 1) {\n        jug = false;\n      }\n      i *= 10;\n    }\n  } \n  cout << sum << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02639",
        "question": "Score : 100 points\n\nProblem StatementWe have five variables x_1, x_2, x_3, x_4, and x_5.\nThe variable x_i was initially assigned a value of i.\nSnuke chose one of these variables and assigned it 0.\nYou are given the values of the five variables after this assignment.\nFind out which variable Snuke assigned 0.\n\nConstraints\nThe values of x_1, x_2, x_3, x_4, and x_5 given as input are a possible outcome of the assignment by Snuke.\n\nInputInput is given from Standard Input in the following format:\nx_1 x_2 x_3 x_4 x_5\n\nOutputIf the variable Snuke assigned 0 was x_i, print the integer i.\n\nSample Input 10 2 3 4 5\n\nSample Output 11\n\nIn this case, Snuke assigned 0 to x_1, so we should print 1.\n\nSample Input 21 2 0 4 5\n\nSample Output 23",
        "desc": "This problem asks you to identify which of five initially sequential variables was set to zero by comparing the final values to their original assignments, testing skills in input handling and basic arithmetic operations in C++. It is classified as an easy-level programming challenge suitable for beginners.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  vector<int> x(5);\n  int num = 0;\n  cin >> x[1] >> x[2] >> x[3] >> x[4] >> x[5];\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] == 0) {\n      num = i;\n    }\n  }\n  cout << num << endl;\n}",
        "error_desc": "1. The vector `x` is initialized with size 5, making valid indices 0 to 4, but the code attempts to access `x[5]`, which is out of bounds.\n2. The code uses 1-based indexing for the vector, causing it to skip `x[0]` and incorrectly reference `x[5]`.\n3. The loop starts at `i = 1` and does not check the first element `x[0]`, potentially missing the variable that was set to 0."
    },
    {
        "problem_id": "p02640",
        "question": "Score : 200 points\n\nProblem StatementThere are some animals in a garden. Each of them is a crane with two legs or a turtle with four legs.\nTakahashi says: \"there are X animals in total in the garden, and they have Y legs in total.\" Determine whether there is a combination of numbers of cranes and turtles in which this statement is correct.\n\nConstraints\n1 \\leq X \\leq 100\n1 \\leq Y \\leq 100\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nX Y\n\nOutputIf there is a combination of numbers of cranes and turtles in which the statement is correct, print Yes; otherwise, print No.\n\nSample Input 13 8\n\nSample Output 1Yes\n\nThe statement \"there are 3 animals in total in the garden, and they have 8 legs in total\" is correct if there are two cranes and one turtle. Thus, there is a combination of numbers of cranes and turtles in which the statement is correct.\n\nSample Input 22 100\n\nSample Output 2No\n\nThere is no combination of numbers of cranes and turtles in which this statement is correct.\n\nSample Input 31 2\n\nSample Output 3Yes\n\nWe also consider the case in which there are only cranes or only turtles.",
        "desc": "This C++ problem requires determining if a given total number of animals and legs can be achieved using cranes (2 legs) and turtles (4 legs), testing understanding of integer arithmetic and conditional logic. It is classified as an easy to medium difficulty level programming challenge.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int x, y;\n  bool ans = false;\n  cin >> x >> y;\n  for (int crane = 0; crane <= x; crane++) {\n    int turtle = x - crane;\n    int sum = crane * 2 + turtle * 4;\n    if (sum == y) ans = true;\n  }\n  if (ans) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;",
        "error_desc": "1. The program includes the non-standard header `<bits/stdc++.h>`, which can cause a compile error.\n2. Missing `return 0;` statement at the end of the `main` function."
    },
    {
        "problem_id": "p02627",
        "question": "Score : 100 points\n\nProblem StatementAn uppercase or lowercase English letter \\alpha will be given as input.\nIf \\alpha is uppercase, print A; if it is lowercase, print a.\n\nConstraints\n\\alpha is an uppercase (A - Z) or lowercase (a - z) English letter.\n\nInputInput is given from Standard Input in the following format:\nα\n\nOutputIf \\alpha is uppercase, print A; if it is lowercase, print a.\n\nSample Input 1B\n\nSample Output 1A\n\nB is uppercase, so we should print A.\n\nSample Input 2a\n\nSample Output 2a\n\na is lowercase, so we should print a.",
        "desc": "This C++ problem assesses understanding of character classification and conditional logic by requiring the identification of an input letter’s case and outputting a corresponding character ('A' for uppercase, 'a' for lowercase). It is considered a beginner-level question, suitable for those new to handling character data and implementing basic conditional structures.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  char n;\n  cin >> n;\n  if (n >= 'A' && n <= 'Z') cout << \"A\" << endl;\n  if (n >= 'a' && n <= 'z') cout << \"a\" << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02628",
        "question": "Score : 200 points\n\nProblem StatementA shop sells N kinds of fruits, Fruit 1, \\ldots, N, at prices of p_1, \\ldots, p_N yen per item, respectively. (Yen is the currency of Japan.)\nHere, we will choose K kinds of fruits and buy one of each chosen kind. Find the minimum possible total price of those fruits.\n\nConstraints\n1 \\leq K \\leq N \\leq 1000\n1 \\leq p_i \\leq 1000\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nN K\np_1 p_2 \\ldots p_N\n\nOutputPrint an integer representing the minimum possible total price of fruits.\n\nSample Input 15 3\n50 100 80 120 80\n\nSample Output 1210\n\nThis shop sells Fruit 1, 2, 3, 4, and 5 for 50 yen, 100 yen, 80 yen, 120 yen, and 80 yen, respectively.\nThe minimum total price for three kinds of fruits is 50 + 80 + 80 = 210 yen when choosing Fruit 1, 3, and 5.\n\nSample Input 21 1\n1000\n\nSample Output 21000",
        "desc": "This C++ problem involves selecting the cheapest **K** fruits from a list of **N** priced items, requiring knowledge of sorting algorithms and efficient array handling to compute the minimum total cost. It assesses fundamental problem-solving skills and is classified as an **Easy to Medium** difficulty level.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, k;\n  cin >> n >> k;\n  vector<int> p(n);\n  for (int i = 0; i < n; i++) cin >> p[i];\n  sort(p.begin(), p.end());\n  int min = 0;\n  for (int i = 0; i < k; i++) min += p[i];\n  cout << min << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02629",
        "question": "Score : 300 points\n\nProblem Statement1000000000000001 dogs suddenly appeared under the roof of Roger's house, all of which he decided to keep. The dogs had been numbered 1 through 1000000000000001, but he gave them new names, as follows:\n\nthe dogs numbered 1,2,\\cdots,26 were respectively given the names a, b, ..., z;\nthe dogs numbered 27,28,29,\\cdots,701,702  were respectively given the names aa, ab, ac, ..., zy, zz;\nthe dogs numbered 703,704,705,\\cdots,18277,18278  were respectively given the names aaa, aab, aac, ..., zzy, zzz;\nthe dogs numbered 18279,18280,18281,\\cdots,475253,475254  were respectively given the names aaaa, aaab, aaac, ..., zzzy, zzzz;\nthe dogs numbered 475255,475256,\\cdots  were respectively given the names aaaaa, aaaab, ...;\nand so on.\n\nTo sum it up, the dogs numbered 1, 2, \\cdots were respectively given the following names:\na, b, ..., z, aa, ab, ..., az, ba, bb, ..., bz, ..., za, zb, ..., zz, aaa, aab, ..., aaz, aba, abb, ..., abz, ..., zzz, aaaa, ...\nNow, Roger asks you:\n\"What is the name for the dog numbered N?\"\n\nConstraints\nN is an integer.\n 1 \\leq N \\leq 1000000000000001\n\nInputInput is given from Standard Input in the following format:\nN\n\nOutputPrint the answer to Roger's question as a string consisting of lowercase English letters.\n\nSample Input 12\n\nSample Output 1b\n\nSample Input 227\n\nSample Output 2aa\n\nSample Input 3123456789\n\nSample Output 3jjddja",
        "desc": "This C++ problem requires determining the unique name of a dog based on its numerical order by simulating a base-26 naming system with alphabetic strings of increasing length. It tests concepts such as number base conversion, string manipulation, and efficient handling of very large integers, and is classified as a high-difficulty (300 points) challenge.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nint main() {\n  ll n;\n  cin >> n;\n  int mod;\n  string ans = \" \";\n  while (n!=0) {\n    n--;\n    mod = n % 26;\n    char c = ('a' + mod);\n    ans = c + ans;\n    n /= 26;\n  }\n  cout << ans << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02630",
        "question": "Score : 400 points\n\nProblem StatementYou have a sequence A composed of N positive integers: A_{1}, A_{2}, \\cdots, A_{N}.\nYou will now successively do the following Q operations:\n\nIn the i-th operation, you replace every element whose value is B_{i} with C_{i}.\n\nFor each i (1 \\leq i \\leq Q), find S_{i}: the sum of all elements in A just after the i-th operation.\n\nConstraints\nAll values in input are integers.\n 1 \\leq N, Q, A_{i}, B_{i}, C_{i} \\leq 10^{5} \n B_{i} \\neq C_{i} \n\nInputInput is given from Standard Input in the following format:\nN\nA_{1} A_{2} \\cdots A_{N}\nQ\nB_{1} C_{1}\nB_{2} C_{2}\n\\vdots\nB_{Q} C_{Q}\n\nOutputPrint Q integers S_{i} to Standard Output in the following format:\nS_{1}\nS_{2}\n\\vdots\nS_{Q}\n\nNote that S_{i} may not fit into a 32-bit integer.\n\nSample Input 14\n1 2 3 4\n3\n1 2\n3 4\n2 4\n\nSample Output 111\n12\n16\n\nInitially, the sequence A is 1,2,3,4.\nAfter each operation, it becomes the following:\n\n2, 2, 3, 4\n2, 2, 4, 4\n4, 4, 4, 4\n\nSample Input 24\n1 1 1 1\n3\n1 2\n2 1\n3 5\n\nSample Output 28\n4\n4\n\nNote that the sequence A may not contain an element whose value is B_{i}.\n\nSample Input 32\n1 2\n3\n1 100\n2 100\n100 1000\n\nSample Output 3102\n200\n2000",
        "desc": "This C++ problem challenges participants to efficiently manage and update a large sequence of integers by replacing specific values and calculating the sum after each operation, utilizing techniques like frequency counting or optimized data structures. It tests knowledge of algorithm optimization and data manipulation, and is classified as a high-difficulty (hard) level question.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nint main() {\n  int Q, N;\n  cin >> N;\n  vector<int> a(N);\n  for (int i = 0; i < N; i++) cin >> a[i];\n  cin >> Q;\n  vector<int> b(Q), c(Q);\n  for (int i = 0; i < Q; i++) cin >> b[i] >> c[i];\n  for (int i = 0; i < Q; i++) {\n    for (int j = 0; j < N; j++) {\n      if (a[j] == b[i]) a[j] = c[i];\n    }\n    ll sum = 0;\n    for (int j = 0; j < N; j++) sum += a[j];\n    cout << sum << endl;\n  }\n}",
        "error_desc": "1. The program uses nested loops to process Q operations and iterate through N elements, resulting in a time complexity of O(Q*N).\n2. It recalculates the sum by traversing the entire array after each operation instead of maintaining the sum incrementally.\n3. The solution does not utilize efficient data structures like frequency maps to optimize element replacements and sum updates."
    }
]