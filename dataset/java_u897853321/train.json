[
    {
        "problem_id": "p02595",
        "question": "Score : 200 points\n\nProblem StatementWe have N points in the two-dimensional plane. The coordinates of the i-th point are (X_i,Y_i).\nAmong them, we are looking for the points such that the distance from the origin is at most D. How many such points are there?\nWe remind you that the distance between the origin and the point (p, q) can be represented as \\sqrt{p^2+q^2}.\n\nConstraints\n1 \\leq N \\leq 2\\times 10^5\n0 \\leq D \\leq 2\\times 10^5\n|X_i|,|Y_i| \\leq 2\\times 10^5\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nN D\nX_1 Y_1\n\\vdots\nX_N Y_N\n\nOutputPrint an integer representing the number of points such that the distance from the origin is at most D.\n\nSample Input 14 5\n0 5\n-2 4\n3 4\n4 -4\n\nSample Output 13\n\nThe distance between the origin and each of the given points is as follows:\n\n\\sqrt{0^2+5^2}=5\n\\sqrt{(-2)^2+4^2}=4.472\\ldots\n\\sqrt{3^2+4^2}=5\n\\sqrt{4^2+(-4)^2}=5.656\\ldots\n\nThus, we have three points such that the distance from the origin is at most 5.\n\nSample Input 212 3\n1 1\n1 1\n1 1\n1 1\n1 2\n1 3\n2 1\n2 2\n2 3\n3 1\n3 2\n3 3\n\nSample Output 27\n\nMultiple points may exist at the same coordinates.\n\nSample Input 320 100000\n14309 -32939\n-56855 100340\n151364 25430\n103789 -113141\n147404 -136977\n-37006 -30929\n188810 -49557\n13419 70401\n-88280 165170\n-196399 137941\n-176527 -61904\n46659 115261\n-153551 114185\n98784 -6820\n94111 -86268\n-30401 61477\n-55056 7872\n5901 -163796\n138819 -185986\n-69848 -96669\n\nSample Output 36",
        "desc": "This Java problem assesses understanding of geometric calculations and efficient data processing, specifically computing distances using the Euclidean formula and handling large input sizes with optimal algorithms. It is classified as a medium to intermediate difficulty level, suitable for testing proficiency in loops, conditionals, and performance optimization in programming.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint d = sc.nextInt();\n\t\tint[] x = new int[n];\n\t\tint[] y = new int[n];\n\t\tint count = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif((Math.sqrt(x[i]*x[i] + y[i]*y[i])) <= d){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n}",
        "error_desc": "1. The program never reads the X and Y coordinates from the input, leaving the `x` and `y` arrays uninitialized.\n2. It incorrectly attempts to calculate distances using uninitialized `x[i]` and `y[i]` values.\n3. The distance comparison uses floating-point arithmetic which may lead to precision issues with large input values.\n4. The program does not handle large input sizes efficiently, potentially causing performance issues."
    },
    {
        "problem_id": "p04043",
        "question": "Score : 100 points\n\nProblem StatementIroha loves Haiku. Haiku is a short form of Japanese poetry. A Haiku consists of three phrases with 5, 7 and 5 syllables, in this order.\nTo create a Haiku, Iroha has come up with three different phrases. These phrases have A, B and C syllables, respectively. Determine whether she can construct a Haiku by using each of the phrases once, in some order.\n\nConstraints\n1≦A,B,C≦10\n\nInputThe input is given from Standard Input in the following format:\nA B C\n\nOutputIf it is possible to construct a Haiku by using each of the phrases once, print YES (case-sensitive). Otherwise, print NO.\n\nSample Input 15 5 7\n\nSample Output 1YES\n\nUsing three phrases of length 5, 5 and 7, it is possible to construct a Haiku.\n\nSample Input 27 7 5\n\nSample Output 2NO",
        "desc": "The problem requires determining if three given integers can be reordered to match the syllable pattern 5-7-5 of a Haiku, testing concepts like permutations and conditional logic. It is classified as an easy-level Java programming challenge.",
        "program": "import java.util.Scanner;\npablic class Main{\n\tpablic static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n      String a = sc.next();\n      String b = sc.next();\n      String c = sc.next();\n      if(a.length() == 5 && b.length() == 7 && c.length() ==5){\n      \tSystem.out.println(\"YES\");\n      }else if(a.length() == 5 && b.length() == 5 && c.length() ==7){\n      \tSystem.out.println(\"YES\");\n      }else if(a.length() == 5 && b.length() == 7 && c.length() ==5){\n      \tSystem.out.println(\"YES\");\n      }else{\n      \tSystem.out.println(\"NO\");\n      }\n    }\n}",
        "error_desc": "1. The keyword `public` is misspelled as `pablic` in both the class declaration and the main method.\n2. The program uses `String` types and the `length()` method to handle syllable counts instead of reading them as integers.\n3. The third `else if` condition is a duplicate of the first condition, making it redundant.\n4. The program does not correctly handle all possible permutations of the syllable counts needed for a Haiku."
    },
    {
        "problem_id": "p04044",
        "question": "Score : 200 points\n\nProblem StatementIroha has a sequence of N strings S_1, S_2, ..., S_N. The length of each string is L.\nShe will concatenate all of the strings in some order, to produce a long string.\nAmong all strings that she can produce in this way, find the lexicographically smallest one.\nHere, a string s=s_1s_2s_3...s_n is lexicographically smaller than another string t=t_1t_2t_3...t_m if and only if one of the following holds:\n\nThere exists an index i(1≦i≦min(n,m)), such that s_j = t_j for all indices j(1≦j&lt;i), and s_i&lt;t_i.\ns_i = t_i for all integers i(1≦i≦min(n,m)), and n&lt;m.\n\nConstraints\n1 ≦ N, L ≦ 100\nFor each i, the length of S_i equals L.\nFor each i, S_i consists of lowercase letters.\n\nInputThe input is given from Standard Input in the following format:\nN L\nS_1\nS_2\n:\nS_N\n\nOutputPrint the lexicographically smallest string that Iroha can produce.\n\nSample Input 13 3\ndxx\naxx\ncxx\n\nSample Output 1axxcxxdxx\n\nThe following order should be used: axx, cxx, dxx.",
        "desc": "The problem requires arranging N fixed-length lowercase strings in an order that, when concatenated, forms the lexicographically smallest possible string, testing concepts like string comparison and custom sorting algorithms. It is classified as a medium-difficulty question suitable for intermediate Java programmers.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n      \tScanner sc = new Scanner(System.in);\n      \tint n = sc.nextInt();\n      \tint l = sc.nextInt();\n      \tString[] s = new String[n];\n      \tfor(int i = 0; i < n; i++){\n        \ts[i] = sc.next();\n        }\n      \tArrays.sort(s);\n      \tfor(int i = 0; i < n; i++){\n        \tSystem.out.print(s[i]);\n        }\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03493",
        "question": "Score : 100 points\n\nProblem StatementSnuke has a grid consisting of three squares numbered 1, 2 and 3.\nIn each square, either 0 or 1 is written. The number written in Square i is s_i.\nSnuke will place a marble on each square that says 1.\nFind the number of squares on which Snuke will place a marble.\n\nConstraints\nEach of s_1, s_2 and s_3 is either 1 or 0.\n\nInputInput is given from Standard Input in the following format:\ns_{1}s_{2}s_{3}\n\nOutputPrint the answer.\n\nSample Input 1101\n\nSample Output 12\n\nA marble will be placed on Square 1 and 3.\n\nSample Input 2000\n\nSample Output 20\n\nNo marble will be placed on any square.",
        "desc": "This problem involves reading a three-digit binary input and counting the number of digits that are `1`, testing concepts like input handling, string manipulation, and conditional counting in Java. It is considered an easy-level programming challenge.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n      \tString s = sc.next();\n      \tint c = 0;\n      \tfor(int i = 0; i < s.length(); i++){\n        \tif(s.charAt(i)=='1') c++;\n        }\n      \tSystem.out.println(c);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03469",
        "question": "Score : 100 points\n\nProblem StatementOn some day in January 2018, Takaki is writing a document. The document has a column where the current date is written in yyyy/mm/dd format. For example, January 23, 2018 should be written as 2018/01/23.\nAfter finishing the document, she noticed that she had mistakenly wrote 2017 at the beginning of the date column. Write a program that, when the string that Takaki wrote in the date column, S, is given as input, modifies the first four characters in S to 2018 and prints it.\n\nConstraints\nS is a string of length 10.\nThe first eight characters in S are 2017/01/.\nThe last two characters in S are digits and represent an integer between 1 and 31 (inclusive).\n\nInputInput is given from Standard Input in the following format:\nS\n\nOutputReplace the first four characters in S with 2018 and print it.\n\nSample Input 12017/01/07\n\nSample Output 12018/01/07\n\nSample Input 22017/01/31\n\nSample Output 22018/01/31",
        "desc": "This Java problem assesses basic string manipulation skills, specifically the ability to modify substrings using indexing and replacement techniques. It is considered an easy-level question, suitable for beginners to practice fundamental string handling concepts.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc  = new Scanner(System.in);\n      \tString s = sc.next();\n      \tString s2 = \"2018\" + s.substring(4,s.length());\n      \tSystem.out.println(s2);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03455",
        "question": "Score : 100 points\n\nProblem StatementAtCoDeer the deer found two positive integers, a and b.\nDetermine whether the product of a and b is even or odd.\n\nConstraints\n1 ≤ a,b ≤ 10000\na and b are integers.\n\nInputInput is given from Standard Input in the following format:\na b\n\nOutputIf the product is odd, print Odd; if it is even, print Even.\n\nSample Input 13 4\n\nSample Output 1Even\n\nAs 3 × 4 = 12 is even, print Even.\n\nSample Input 21 21\n\nSample Output 2Odd\n\nAs 1 × 21 = 21 is odd, print Odd.",
        "desc": "This Java problem assesses understanding of arithmetic operations and the use of conditional statements or modulus operator to determine the parity of a product. It is categorized as an easy-level question, suitable for beginners learning basic programming concepts.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc  = new Scanner(System.in);\n      \tint a = sc.nextInt();\n      \tint b = sc.nextInt();\n      \tif((a*b) % 2 == 0){\n        \tSystem.out.println(\"Even\");\n        }else{\n        \tSystem.out.println(\"Odd\");\n        }\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p04030",
        "question": "Score : 200 points\n\nProblem StatementSig has built his own keyboard. Designed for ultimate simplicity, this keyboard only has 3 keys on it: the 0 key, the 1 key and the backspace key.\nTo begin with, he is using a plain text editor with this keyboard. This editor always displays one string (possibly empty). Just after the editor is launched, this string is empty. When each key on the keyboard is pressed, the following changes occur to the string:\n\nThe 0 key: a letter 0 will be inserted to the right of the string.\nThe 1 key: a letter 1 will be inserted to the right of the string.\nThe backspace key: if the string is empty, nothing happens. Otherwise, the rightmost letter of the string is deleted.\n\nSig has launched the editor, and pressed these keys several times. You are given a string s, which is a record of his keystrokes in order. In this string, the letter 0 stands for the 0 key, the letter 1 stands for the 1 key and the letter B stands for the backspace key. What string is displayed in the editor now?\n\nConstraints\n1 ≦ |s| ≦ 10 (|s| denotes the length of s)\ns consists of the letters 0, 1 and B.\nThe correct answer is not an empty string.\n\nInputThe input is given from Standard Input in the following format:\ns\n\nOutputPrint the string displayed in the editor in the end.\n\nSample Input 101B0\n\nSample Output 100\n\nEach time the key is pressed, the string in the editor will change as follows: 0, 01, 0, 00.\n\nSample Input 20BB1\n\nSample Output 21\n\nEach time the key is pressed, the string in the editor will change as follows: 0, (empty), (empty), 1.",
        "desc": "This Java problem requires simulating a text editor by processing a sequence of key presses ('0', '1', and 'B') to determine the final string displayed, testing concepts like string manipulation and stack-like operations. It is classified as an easy to introductory-level programming challenge.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc  = new Scanner(System.in);\n      \tString s = sc.next();\n      \tString t = \"\";\n      \tfor(int i = 0; i < s.length(); i++){\n        \tif(s.charAt(i) == '0') t+= \"0\";\n          \telse if(s.charAt(i) == '1') t+= \"1\";\n          \telse if(s.charAt(i) == 'B' && t.length()>=1)\n              t = t.substring(0, (t.length()-1));\n        }\n      \tSystem.out.println(t);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03315",
        "question": "Score : 100 points\n\nProblem StatementThere is always an integer in Takahashi's mind.\nInitially, the integer in Takahashi's mind is 0. Takahashi is now going to eat four symbols, each of which is + or -. When he eats +, the integer in his mind increases by 1; when he eats -, the integer in his mind decreases by 1.\nThe symbols Takahashi is going to eat are given to you as a string S. The i-th character in S is the i-th symbol for him to eat.\nFind the integer in Takahashi's mind after he eats all the symbols.\n\nConstraints\nThe length of S is 4.\nEach character in S is + or -.\n\nInputInput is given from Standard Input in the following format:\nS\n\nOutputPrint the integer in Takahashi's mind after he eats all the symbols.\n\nSample Input 1+-++\n\nSample Output 12\n\nInitially, the integer in Takahashi's mind is 0.\nThe first integer for him to eat is +. After eating it, the integer in his mind becomes 1.\nThe second integer to eat is -. After eating it, the integer in his mind becomes 0.\nThe third integer to eat is +. After eating it, the integer in his mind becomes 1.\nThe fourth integer to eat is +. After eating it, the integer in his mind becomes 2.\n\nThus, the integer in Takahashi's mind after he eats all the symbols is 2.\n\nSample Input 2-+--\n\nSample Output 2-2\n\nSample Input 3----\n\nSample Output 3-4",
        "desc": "This problem involves processing a 4-character string of '+' and '-' symbols to calculate the final integer value by incrementing or decrementing accordingly. It tests fundamental concepts in string manipulation, iteration, and conditional logic, and is considered an easy-level programming challenge.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n      \tString s =sc.next();\n      \tint t = 0;\t\n     \tfor(int i = 0; i < 4; i++){\n        \tif(s.charAt(i) == '+') t++;\n          \telse t--;\n        }\n      \tSystem.out.println(t);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03292",
        "question": "Score : 100 points\n\nProblem StatementYou have three tasks, all of which need to be completed.\nFirst, you can complete any one task at cost 0.\nThen, just after completing the i-th task, you can complete the j-th task at cost |A_j - A_i|.\nHere, |x| denotes the absolute value of x.\nFind the minimum total cost required to complete all the task.\n\nConstraints\nAll values in input are integers.\n1 \\leq A_1, A_2, A_3 \\leq 100\n\nInputInput is given from Standard Input in the following format:\nA_1 A_2 A_3\n\nOutputPrint the minimum total cost required to complete all the task.\n\nSample Input 11 6 3\n\nSample Output 15\n\nWhen the tasks are completed in the following order, the total cost will be 5, which is the minimum:\n\nComplete the first task at cost 0.\nComplete the third task at cost 2.\nComplete the second task at cost 3.\n\nSample Input 211 5 5\n\nSample Output 26\n\nSample Input 3100 100 100\n\nSample Output 30",
        "desc": "This Java problem assesses the ability to evaluate all permutations of task sequences and compute minimum costs using absolute differences, effectively testing knowledge of combinatorial optimization and brute-force algorithms. It is classified as a medium difficulty level challenge.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n      \tint[] a = new int[3];\n      \tfor(int i = 0; i < 3; i++){\n        \ta[i] = sc.nextInt();\n        }\n      \tArrays.sort(a);\n      \tSystem.out.println(a[2] - a[0]);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03242",
        "question": "Score : 100 points\n\nProblem StatementCat Snuke is learning to write characters.\nToday, he practiced writing digits 1 and 9, but he did it the other way around.\nYou are given a three-digit integer n written by Snuke.\nPrint the integer obtained by replacing each digit 1 with 9 and each digit 9 with 1 in n.\n\nConstraints\n111 \\leq n \\leq 999\nn is an integer consisting of digits 1 and 9.\n\nInputInput is given from Standard Input in the following format:\nn\n\nOutputPrint the integer obtained by replacing each occurrence of 1 with 9 and each occurrence of 9 with 1 in n.\n\nSample Input 1119\n\nSample Output 1991\n\nReplace the 9 in the ones place with 1, the 1 in the tens place with 9 and the 1 in the hundreds place with 9. The answer is 991.\n\nSample Input 2999\n\nSample Output 2111",
        "desc": "This Java problem asks the user to manipulate a three-digit integer by swapping each digit 1 with 9 and vice versa. It tests understanding of input handling, string or digit manipulation, and conditional logic, and is considered an easy-level question.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n      \tString n = sc.next();\n      \tString newn =\"\";\n      \tfor(int i = 0; i < 3; i++){\n\t      \tif(n.charAt(i) == '1'){\n            \tnewn += \"9\";\n            }else if(n.charAt(i) == '9'){\n            \tnewn += \"1\";\n            }else{\n            \tnewn += String.valueOf(n.charAt(i));\n            }\n        }\n      \tSystem.out.println(newn);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03109",
        "question": "Score : 100 points\n\nProblem StatementYou are given a string S as input. This represents a valid date in the year 2019 in the yyyy/mm/dd format. (For example, April 30, 2019 is represented as 2019/04/30.)\nWrite a program that prints Heisei if the date represented by S is not later than April 30, 2019, and prints TBD otherwise.\n\nConstraints\nS is a string that represents a valid date in the year 2019 in the yyyy/mm/dd format.\n\nInputInput is given from Standard Input in the following format:\nS\n\nOutputPrint Heisei if the date represented by S is not later than April 30, 2019, and print TBD otherwise.\n\nSample Input 12019/04/30\n\nSample Output 1Heisei\n\nSample Input 22019/11/01\n\nSample Output 2TBD",
        "desc": "This Java problem assesses skills in string manipulation and date comparison by requiring the parsing of a date string in the `yyyy/mm/dd` format and determining its relation to a specific cutoff date. It is classified as an easy to medium difficulty level.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n      \tString s = sc.next();\n\t\ts.replaceAll(\"/\", \"\");\n      \tif(s.compareTo(\"20190430\") <= 0) System.out.println(\"Heisei\");\n        else System.out.println(\"TBD\");\n    }\n}",
        "error_desc": "1. The `replaceAll` method is not assigned back to variable `s`, so the slashes are not removed.\n2. The program does not handle the leading number in the input, causing incorrect comparison with the date string."
    },
    {
        "problem_id": "p04012",
        "question": "Score : 200 points\n\nProblem StatementLet w be a string consisting of lowercase letters.\nWe will call w beautiful if the following condition is satisfied:\n\nEach lowercase letter of the English alphabet occurs even number of times in w.\n\nYou are given the string w. Determine if w is beautiful.\n\nConstraints\n1 \\leq |w| \\leq 100\nw consists of lowercase letters (a-z).\n\nInputThe input is given from Standard Input in the following format:\nw\n\nOutputPrint Yes if w is beautiful. Print No otherwise.\n\nSample Input 1abaccaba\n\nSample Output 1Yes\n\na occurs four times, b occurs twice, c occurs twice and the other letters occur zero times.\n\nSample Input 2hthth\n\nSample Output 2No",
        "desc": "This Java problem asks you to determine if a given lowercase string is \"beautiful,\" meaning every letter appears an even number of times. It tests understanding of string manipulation and frequency counting techniques, such as using arrays or hash maps, and is considered to have an easy to medium difficulty level.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n      \tString w = sc.next();\n      \tint[] eng = new int[26];\n      \tboolean res = true;\n      \tfor(int i = 0; i < w.length(); i++){\n        \teng[w.charAt(i)-'a']++;\n        }\n      \tfor(int i = 0; i < 26; i++){\n        \tif(eng[i] % 2 != 0) res = false;\n        }\n      \tif(res){\n        \tSystem.out.println(\"Yes\");\n        }else{\n        \tSystem.out.println(\"No\");\n        }\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02613",
        "question": "Score : 200 points\n\nProblem StatementTakahashi is participating in a programming contest called AXC002, and he has just submitted his code to Problem A.\nThe problem has N test cases.\nFor each test case i (1\\leq i \\leq N), you are given a string S_i representing the verdict for that test case. Find the numbers of test cases for which the verdict is AC, WA, TLE, and RE, respectively.\nSee the Output section for the output format.\n\nConstraints\n1 \\leq N \\leq 10^5\nS_i is AC, WA, TLE, or RE.\n\nInputInput is given from Standard Input in the following format:\nN\nS_1\n\\vdots\nS_N\n\nOutputLet C_0, C_1, C_2, and C_3 be the numbers of test cases for which the verdict is AC, WA, TLE, and RE, respectively. Print the following:\nAC x C_0\nWA x C_1\nTLE x C_2\nRE x C_3\n\nSample Input 16\nAC\nTLE\nAC\nAC\nWA\nTLE\n\nSample Output 1AC x 3\nWA x 1\nTLE x 2\nRE x 0\n\nWe have 3, 1, 2, and 0 test case(s) for which the verdict is AC, WA, TLE, and RE, respectively.\n\nSample Input 210\nAC\nAC\nAC\nAC\nAC\nAC\nAC\nAC\nAC\nAC\n\nSample Output 2AC x 10\nWA x 0\nTLE x 0\nRE x 0",
        "desc": "This Java problem assesses the ability to efficiently process and count string occurrences under large input constraints, specifically utilizing arrays or hash maps for tallying verdicts. It is classified as a medium-difficulty problem, requiring knowledge of input handling and basic data aggregation techniques.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n      \tint n = sc.nextInt();\n      \tint[] result = new int[4];\n      \tfor(int i = 0; i < n; i++){\n        \tString s = sc.next();\n          \tswitch(s){\n              case \"AC\":\n                result[0]++;\n\t\t\t\tbreak;\n              case \"WA\":\n                result[1]++;\n                break;\n              case \"TLE\":\n                result[2]++;\n\t\t\t\tbreak;\n              case \"RE\":\n                result[3]++;\n                break;              \n            }\n        }\n      \tSystem.out.println(\"AC x \" + result[0]);\n      \tSystem.out.println(\"WA x \" + result[1]);\n      \tSystem.out.println(\"TLE x \" + result[2]);\n      \tSystem.out.println(\"RE x \" + result[3]);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02622",
        "question": "Score : 200 points\n\nProblem StatementGiven are strings S and T. Consider changing S to T by repeating the operation below. Find the minimum number of operations required to do so.\nOperation: Choose one character of S and replace it with a different character.\n\nConstraints\nS and T have lengths between 1 and 2\\times 10^5 (inclusive).\nS and T consists of lowercase English letters.\nS and T have equal lengths.\n\nInputInput is given from Standard Input in the following format:\nS\nT\n\nOutputPrint the answer.\n\nSample Input 1cupofcoffee\ncupofhottea\n\nSample Output 14\n\nWe can achieve the objective in four operations, such as the following:\n\nFirst, replace the sixth character c with h.\nSecond, replace the eighth character f with t.\nThird, replace the ninth character f with t.\nFourth, replace the eleventh character e with a.\n\nSample Input 2abcde\nbcdea\n\nSample Output 25\n\nSample Input 3apple\napple\n\nSample Output 30\n\nNo operations may be needed to achieve the objective.",
        "desc": "This Java problem requires determining the minimum number of single-character replacements needed to transform string S into string T, emphasizing efficient handling of large strings and character frequency analysis. It tests knowledge of string manipulation and optimization algorithms and is categorized as a medium to hard difficulty level.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n      \tString s = sc.next();\n      \tString t = sc.next();\n      \tint count = 0;\n      \tfor(int i = 0; i < s.length(); i++){\n        \tif(s.charAt(i) != t.charAt(i)) count++;\n        }\n      \tSystem.out.println(count);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02628",
        "question": "Score : 200 points\n\nProblem StatementA shop sells N kinds of fruits, Fruit 1, \\ldots, N, at prices of p_1, \\ldots, p_N yen per item, respectively. (Yen is the currency of Japan.)\nHere, we will choose K kinds of fruits and buy one of each chosen kind. Find the minimum possible total price of those fruits.\n\nConstraints\n1 \\leq K \\leq N \\leq 1000\n1 \\leq p_i \\leq 1000\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nN K\np_1 p_2 \\ldots p_N\n\nOutputPrint an integer representing the minimum possible total price of fruits.\n\nSample Input 15 3\n50 100 80 120 80\n\nSample Output 1210\n\nThis shop sells Fruit 1, 2, 3, 4, and 5 for 50 yen, 100 yen, 80 yen, 120 yen, and 80 yen, respectively.\nThe minimum total price for three kinds of fruits is 50 + 80 + 80 = 210 yen when choosing Fruit 1, 3, and 5.\n\nSample Input 21 1\n1000\n\nSample Output 21000",
        "desc": "This Java problem requires selecting the K least expensive fruits from a list of N types, testing knowledge of array handling, sorting algorithms, and efficient selection techniques. It assesses fundamental algorithmic skills and is considered to have an easy to intermediate difficulty level.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n      \tint n = sc.nextInt();\n      \tint k = sc.nextInt();\n      \tint[] pi = new int[n];\n      \tint sum = 0;\n      \tfor(int i = 0; i < n; i++){\n        \tpi[i] = sc.nextInt();\n        }\n\t\tArrays.sort(pi);\n      \tfor(int i = 0; i < k; i++){\n        \tsum += pi[i];\n        }\n      \tSystem.out.println(sum);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03075",
        "question": "﻿Score: 100 points\n\nProblem Statement\nIn AtCoder city, there are five antennas standing in a straight line. They are called Antenna A, B, C, D and E from west to east, and their coordinates are a, b, c, d and e, respectively.\nTwo antennas can communicate directly if the distance between them is k or less, and they cannot if the distance is greater than k.\nDetermine if there exists a pair of antennas that cannot communicate directly.\nHere, assume that the distance between two antennas at coordinates p and q (p &lt; q) is q - p.  \n\nConstraints\n\na, b, c, d, e and k are integers between 0 and 123 (inclusive).\na &lt; b &lt; c &lt; d &lt; e\n\nInput\nInput is given from Standard Input in the following format:\na\nb\nc\nd\ne\nk\n\nOutput\nPrint :( if there exists a pair of antennas that cannot communicate directly, and print Yay! if there is no such pair.\n\nSample Input 11\n2\n4\n8\n9\n15\n\nSample Output 1Yay!\n\nIn this case, there is no pair of antennas that cannot communicate directly, because:\n\nthe distance between A and B is 2 - 1 = 1\nthe distance between A and C is 4 - 1 = 3\nthe distance between A and D is 8 - 1 = 7\nthe distance between A and E is 9 - 1 = 8\nthe distance between B and C is 4 - 2 = 2\nthe distance between B and D is 8 - 2 = 6\nthe distance between B and E is 9 - 2 = 7\nthe distance between C and D is 8 - 4 = 4\nthe distance between C and E is 9 - 4 = 5\nthe distance between D and E is 9 - 8 = 1\n\nand none of them is greater than 15. Thus, the correct output is Yay!.\n\nSample Input 215\n18\n26\n35\n36\n18\n\nSample Output 2:(\n\nIn this case, the distance between antennas A and D is 35 - 15 = 20 and exceeds 18, so they cannot communicate directly.\nThus, the correct output is :(.",
        "desc": "This Java problem assesses the ability to perform pairwise comparisons and apply conditional logic to determine if any two of five ordered antennas exceed a specified distance threshold. It tests fundamental programming concepts such as loops, conditionals, and basic input/output handling, and is considered to be of easy difficulty.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n      \tint a = sc.nextInt();\n      \tint b = sc.nextInt();\n      \tint c = sc.nextInt();\n      \tint d = sc.nextInt();\n      \tint e = sc.nextInt();\n      \tint k = sc.nextInt();\n      \tboolean go = true;\n      \tif(Math.abs(a-b) > k) go = false;\n        if(Math.abs(a-c) > k) go = false;\n        if(Math.abs(a-d) > k) go = false;\n        if(Math.abs(a-e) > k) go = false;\n        if(Math.abs(b-c) > k) go = false;\n        if(Math.abs(b-d) > k) go = false;\n        if(Math.abs(b-e) > k) go = false;\n        if(Math.abs(c-d) > k) go = false;\n        if(Math.abs(c-e) > k) go = false;\n        if(Math.abs(d-e) > k) go = false;\n      \tif(go){\n        \tSystem.out.println(\"Yay!\");\n        }else{\n        \tSystem.out.println(\":(\");\n        }\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03071",
        "question": "Score : 100 points\n\nProblem StatementThere are two buttons, one of size A and one of size B.\nWhen you press a button of size X, you get X coins and the size of that button decreases by 1.\nYou will press a button twice. Here, you can press the same button twice, or press both buttons once.\nAt most how many coins can you get?\n\nConstraints\nAll values in input are integers.\n3 \\leq A, B \\leq 20\n\nInputInput is given from Standard Input in the following format:\nA B\n\nOutputPrint the maximum number of coins you can get.\n\nSample Input 15 3\n\nSample Output 19\n\nYou can get 5 + 4 = 9 coins by pressing the button of size 5 twice, and this is the maximum result.\n\nSample Input 23 4\n\nSample Output 27\n\nSample Input 36 6\n\nSample Output 312",
        "desc": "This Java problem requires calculating the maximum coins obtainable by strategically pressing two buttons with diminishing sizes, testing concepts like conditional logic and simple optimization algorithms. It is classified as an easy to medium difficulty level.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n      \tint[] a = new int[2];\n      \ta[0] = sc.nextInt();\n      \ta[1] = sc.nextInt();\n      \tint sum = 0;\n      \tArrays.sort(a);\n      \tsum += a[1];\n      \ta[1]--;\n      \tArrays.sort(a);\n      \tsum += a[1];\n      \ta[1]--;\n      \tSystem.out.println(sum);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03059",
        "question": "Score : 100 points\n\nProblem StatementA biscuit making machine produces B biscuits at the following moments: A seconds, 2A seconds, 3A seconds and each subsequent multiple of A seconds after activation.\nFind the total number of biscuits produced within T + 0.5 seconds after activation.\n\nConstraints\nAll values in input are integers.\n1 \\leq A, B, T \\leq 20\n\nInputInput is given from Standard Input in the following format:\nA B T\n\nOutputPrint the total number of biscuits produced within T + 0.5 seconds after activation.\n\nSample Input 13 5 7\n\nSample Output 110\n\nFive biscuits will be produced three seconds after activation.\nAnother five biscuits will be produced six seconds after activation.\nThus, a total of ten biscuits will be produced within 7.5 seconds after activation.\n\nSample Input 23 2 9\n\nSample Output 26\n\nSample Input 320 20 19\n\nSample Output 30",
        "desc": "This Java problem requires calculating the total number of biscuits a machine produces at regular time intervals within a given period, testing concepts such as loops or arithmetic sequences and conditional counting. It is considered to have a beginner to intermediate difficulty level.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n      \tScanner sc = new Scanner(System.in);\n    \tint a = sc.nextInt();\n      \tint b = sc.nextInt();\n      \tdouble t = sc.nextDouble();\n      \tint sec = (int)((t+0.5)/a);\n      \tint sum = b*sec;\n      \tSystem.out.println(sum);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03041",
        "question": "Score : 100 points\n\nProblem StatementYou are given a string S of length N consisting of A, B and C, and an integer K which is between 1 and N (inclusive).\nPrint the string S after lowercasing the K-th character in it.\n\nConstraints\n1 ≤ N ≤ 50\n1 ≤ K ≤ N\nS is a string of length N consisting of A, B and C.\n\nInputInput is given from Standard Input in the following format:\nN K\nS\n\nOutputPrint the string S after lowercasing the K-th character in it.\n\nSample Input 13 1\nABC\n\nSample Output 1aBC\n\nSample Input 24 3\nCABA\n\nSample Output 2CAbA",
        "desc": "This Java problem assesses understanding of string manipulation, character indexing, and case conversion by requiring the alteration of the K-th character in a given string. It is categorized as an easy-level question suitable for beginners.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n      \tScanner sc = new Scanner(System.in);\n    \tint n = sc.nextInt();\n      \tint k = sc.nextInt();\n      \tString s = sc.next();\n      \ts = s.substring(0,k-1) + s.substring(k-1,k).toLowerCase() + s.substring(k, n);\n      \tSystem.out.println(s);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03035",
        "question": "Score : 100 points\n\nProblem StatementTakahashi, who is A years old, is riding a Ferris wheel.\nIt costs B yen (B is an even number) to ride the Ferris wheel if you are 13 years old or older, but children between 6 and 12 years old (inclusive) can ride it for half the cost, and children who are 5 years old or younger are free of charge. (Yen is the currency of Japan.)\nFind the cost of the Ferris wheel for Takahashi.\n\nConstraints\n0 ≤ A ≤ 100\n2 ≤ B ≤ 1000\nB is an even number.\n\nInputInput is given from Standard Input in the following format:\nA B\n\nOutputPrint the cost of the Ferris wheel for Takahashi.\n\nSample Input 130 100\n\nSample Output 1100\n\nTakahashi is 30 years old now, and the cost of the Ferris wheel is 100 yen.\n\nSample Input 212 100\n\nSample Output 250\n\nTakahashi is 12 years old, and the cost of the Ferris wheel is the half of 100 yen, that is, 50 yen.\n\nSample Input 30 100\n\nSample Output 30\n\nTakahashi is 0 years old, and he can ride the Ferris wheel for free.",
        "desc": "This Java problem requires determining the Ferris wheel cost based on Takahashi's age using conditional statements, testing understanding of input handling and branching logic. It is classified as an easy-level programming challenge.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n      \tint a = sc.nextInt();\n      \tint b = sc.nextInt();\n      \tif(a >= 13) System.out.println(b);\n      \telse if(a >= 6) System.out.println(b/2);\n      \telse System.out.println(\"0\");\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03011",
        "question": "Score : 100 points\n\nProblem StatementThere are three airports A, B and C, and flights between each pair of airports in both directions.\nA one-way flight between airports A and B takes P hours, a one-way flight between airports B and C takes Q hours, and a one-way flight between airports C and A takes R hours.\nConsider a route where we start at one of the airports, fly to another airport and then fly to the other airport.\nWhat is the minimum possible sum of the flight times?\n\nConstraints\n1 \\leq P,Q,R \\leq 100\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nP Q R\n\nOutputPrint the minimum possible sum of the flight times.\n\nSample Input 11 3 4\n\nSample Output 14\n\nThe sum of the flight times in the route A \\rightarrow B \\rightarrow C: 1 + 3 = 4 hours\nThe sum of the flight times in the route A \\rightarrow C \\rightarrow C: 4 + 3 = 7 hours\nThe sum of the flight times in the route B \\rightarrow A \\rightarrow C: 1 + 4 = 5 hours\nThe sum of the flight times in the route B \\rightarrow C \\rightarrow A: 3 + 4 = 7 hours\nThe sum of the flight times in the route C \\rightarrow A \\rightarrow B: 4 + 1 = 5 hours\nThe sum of the flight times in the route C \\rightarrow B \\rightarrow A: 3 + 1 = 4 hours\n\nThe minimum of these is 4 hours.\n\nSample Input 23 2 3\n\nSample Output 25",
        "desc": "This Java problem assesses the ability to handle basic combinatorial logic and optimize simple calculations by determining the minimum sum from possible flight routes. It is categorized as an easy to intermediate difficulty level, testing fundamental programming skills such as input handling and conditional logic.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n      \tint[] pqr = new int[3];\n      \tfor(int i = 0; i < 3; i++){\n        \tpqr[i] = sc.nextInt();\n        }\n\t\tArrays.sort(pqr);\n      \tSystem.out.println(pqr[0]+pqr[1]);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03998",
        "question": "Score : 200 points\n\nProblem StatementAlice, Bob and Charlie are playing Card Game for Three, as below:\n\nAt first, each of the three players has a deck consisting of some number of cards. Each card has a letter a, b or c written on it. The orders of the cards in the decks cannot be rearranged.\nThe players take turns. Alice goes first.\nIf the current player's deck contains at least one card, discard the top card in the deck. Then, the player whose name begins with the letter on the discarded card, takes the next turn. (For example, if the card says a, Alice takes the next turn.)\nIf the current player's deck is empty, the game ends and the current player wins the game.\n\nYou are given the initial decks of the players.\nMore specifically, you are given three strings S_A, S_B and S_C. The i-th (1≦i≦|S_A|) letter in S_A is the letter on the i-th card in Alice's initial deck. S_B and S_C describes Bob's and Charlie's initial decks in the same way.\nDetermine the winner of the game.\n\nConstraints\n1≦|S_A|≦100\n1≦|S_B|≦100\n1≦|S_C|≦100\nEach letter in S_A, S_B, S_C is a, b or c.\n\nInputThe input is given from Standard Input in the following format:\nS_A\nS_B\nS_C\n\nOutputIf Alice will win, print A. If Bob will win, print B. If Charlie will win, print C.\n\nSample Input 1aca\naccc\nca\n\nSample Output 1A\n\nThe game will progress as below:\n\nAlice discards the top card in her deck, a. Alice takes the next turn.\nAlice discards the top card in her deck, c. Charlie takes the next turn.\nCharlie discards the top card in his deck, c. Charlie takes the next turn.\nCharlie discards the top card in his deck, a. Alice takes the next turn.\nAlice discards the top card in her deck, a. Alice takes the next turn.\nAlice's deck is empty. The game ends and Alice wins the game.\n\nSample Input 2abcb\naacb\nbccc\n\nSample Output 2C",
        "desc": "The problem requires simulating a turn-based card game where players discard cards and determine the next turn based on card values, testing concepts such as string manipulation, queue or stack data structures, and control flow. It is classified as a medium to hard difficulty level.",
        "program": "import java.util.*;\npublic class Main{\n  public static void main(String[] args){\n      Scanner st = new Scanner(System.in);\n      String sa = st.next();\n      String sb = st.next();\n      String sc = st.next();\n      int a = 0;\n      int b = 0;\n      int c = 0;\n      char flag = 0;\n      while(a<sa.length() && b<sb.length() && c<sc.length()){\n          if(flag == 'a'){\n              flag = sa.charAt(a);\n              a++;\n          }else if(flag == 'b'){\n              flag = sb.charAt(b);\n              b++;\n          }else{\n              flag = sc.charAt(c);\n              c++;\n          }\n      } \n      System.out.println(Character.toUpperCase(flag));\n  }\n}",
        "error_desc": "1. The initial `flag` is set to `0` instead of `'a'`, so the first turn does not correctly start with Alice.\n2. The loop condition uses `a < sa.length() && b < sb.length() && c < sc.length()`, causing the game to end prematurely when any deck is empty instead of when the current player's deck is empty.\n3. The program incorrectly determines the winner by printing the last discarded card's character instead of the player whose deck is empty.\n4. The `flag` variable does not correctly represent the current player, leading to improper turn handling."
    },
    {
        "problem_id": "p02582",
        "question": "Score : 100 points\n\nProblem StatementWe have weather records at AtCoder Town for some consecutive three days. A string of length 3, S, represents the records - if the i-th character is S, it means it was sunny on the i-th day; if that character is R, it means it was rainy on that day.\nFind the maximum number of consecutive rainy days in this period.\n\nConstraints\n|S| = 3\nEach character of S is S or R.\n\nInputInput is given from Standard Input in the following format:\nS\n\nOutputPrint the maximum number of consecutive rainy days in the period.\n\nSample Input 1RRS\n\nSample Output 12\n\nWe had rain on the 1-st and 2-nd days in the period. Here, the maximum number of consecutive rainy days is 2, so we should print 2.\n\nSample Input 2SSS\n\nSample Output 20\n\nIt was sunny throughout the period. We had no rainy days, so we should print 0.\n\nSample Input 3RSR\n\nSample Output 31\n\nWe had rain on the 1-st and 3-rd days - two \"streaks\" of one rainy day, so we should print 1.",
        "desc": "This Java problem tests string processing and iteration skills by requiring the identification of the longest sequence of consecutive 'R' characters within a three-character string. It is classified as an easy-level exercise, suitable for beginners practicing basic string manipulation and control structures.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n      \tString s = sc.next();\n      \tint count;\n      \tif(s.charAt(0)=='S' &&s.charAt(1)=='S' &&s.charAt(2)=='S') count = 0;\n      \telse if((s.charAt(0)=='R' &&s.charAt(1)=='R' &&s.charAt(2)=='S')\n                ||(s.charAt(0)=='S' &&s.charAt(1)=='R' &&s.charAt(2)=='R')) count= 2;\n      \telse if (s.charAt(0)=='R' &&s.charAt(1)=='R' &&s.charAt(2)=='R') count = 3;\n      \telse count = 1;\n      \tSystem.out.println(count);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02921",
        "question": "Score : 100 points\n\nProblem StatementYou will be given a string S of length 3 representing the weather forecast for three days in the past.\nThe i-th character (1 \\leq i \\leq 3) of S represents the forecast for the i-th day. S, C, and R stand for sunny, cloudy, and rainy, respectively.\nYou will also be given a string T of length 3 representing the actual weather on those three days.\nThe i-th character (1 \\leq i \\leq 3) of S represents the actual weather on the i-th day. S, C, and R stand for sunny, cloudy, and rainy, respectively.\nPrint the number of days for which the forecast was correct.\n\nConstraints\nS and T are strings of length 3 each.\nS and T consist of S, C, and R.\n\nInputInput is given from Standard Input in the following format:\nS\nT\n\nOutputPrint the number of days for which the forecast was correct.\n\nSample Input 1CSS\nCSR\n\nSample Output 12\n\nFor the first day, it was forecast to be cloudy, and it was indeed cloudy.\nFor the second day, it was forecast to be sunny, and it was indeed sunny.\nFor the third day, it was forecast to be sunny, but it was rainy.\n\nThus, the forecast was correct for two days in this case.\n\nSample Input 2SSR\nSSR\n\nSample Output 23\n\nSample Input 3RRR\nSSS\n\nSample Output 30",
        "desc": "This Java problem assesses the ability to manipulate and compare strings by iterating through characters and using conditional logic to count matching elements. It is categorized as an easy-level question, suitable for beginners practicing basic string operations and control structures.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n\t\tchar[] s = sc.next().toCharArray();\n      \tchar[] t = sc.next().toCharArray();\n      \tint count = 0;\n      \tfor(int i = 0; i < 3; i++){\n        \tif(s[i] == t[i]) count++;\n        }\n      \tSystem.out.println(count);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02993",
        "question": "Score : 100 points\n\nProblem Statement\nThe door of Snuke's laboratory is locked with a security code.\nThe security code is a 4-digit number. We say the security code is hard to enter when it contains two consecutive digits that are the same.\nYou are given the current security code S. If S is hard to enter, print Bad; otherwise, print Good.\n\nConstraints\n\nS is a 4-character string consisting of digits.\n\nInput\nInput is given from Standard Input in the following format:\nS\n\nOutput\nIf S is hard to enter, print Bad; otherwise, print Good.\n\nSample Input 13776\n\nSample Output 1Bad\n\nThe second and third digits are the same, so 3776 is hard to enter.\n\nSample Input 28080\n\nSample Output 2Good\n\nThere are no two consecutive digits that are the same, so 8080 is not hard to enter.\n\nSample Input 31333\n\nSample Output 3Bad\n\nSample Input 40024\n\nSample Output 4Bad",
        "desc": "This Java problem evaluates string processing and the ability to detect consecutive identical characters by determining if a 4-digit security code contains any repeating adjacent digits. It is considered an easy-level challenge.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n      \tString s = sc.next();\n      \tboolean isGood = true;\n      \tif(s.charAt(0) == s.charAt(1)) isGood = false;\n      \tif(s.charAt(1) == s.charAt(2)) isGood = false;\n      \tif(s.charAt(2) == s.charAt(3)) isGood = false;\n      \tif(isGood) System.out.println(\"Good\");\n      \telse System.out.println(\"Bad\");\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02987",
        "question": "Score : 100 points\n\nProblem StatementYou are given a 4-character string S consisting of uppercase English letters.\nDetermine if S consists of exactly two kinds of characters which both appear twice in S.\n\nConstraints\nThe length of S is 4.\nS consists of uppercase English letters.\n\nInputInput is given from Standard Input in the following format:\nS\n\nOutputIf S consists of exactly two kinds of characters which both appear twice in S, print Yes; otherwise, print No.\n\nSample Input 1ASSA\n\nSample Output 1Yes\n\nS consists of A and S which both appear twice in S.\n\nSample Input 2STOP\n\nSample Output 2No\n\nSample Input 3FFEE\n\nSample Output 3Yes\n\nSample Input 4FREE\n\nSample Output 4No",
        "desc": "This Java problem tests string manipulation and frequency counting concepts, requiring the use of data structures like arrays or hash maps to determine if a 4-character uppercase string contains exactly two distinct characters, each appearing twice. It is classified as an easy to medium difficulty level.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n      \tchar[] s = sc.next().toCharArray();\n      \tArrays.sort(s);\n      \tif(s[0]==s[1] && s[1]!=s[2] && s[2]==s[3]) System.out.println(\"Yes\");\n      \telse System.out.println(\"No\");\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02981",
        "question": "Score : 100 points\n\nProblem StatementN of us are going on a trip, by train or taxi.\nThe train will cost each of us A yen (the currency of Japan).\nThe taxi will cost us a total of B yen.\nHow much is our minimum total travel expense?\n\nConstraints\nAll values in input are integers.\n1 \\leq N \\leq 20\n1 \\leq A \\leq 50\n1 \\leq B \\leq 50\n\nInputInput is given from Standard Input in the following format:\nN A B\n\nOutputPrint an integer representing the minimum total travel expense.\n\nSample Input 14 2 9\n\nSample Output 18\n\nThe train will cost us 4 \\times 2 = 8 yen, and the taxi will cost us 9 yen, so the minimum total travel expense is 8 yen.\n\nSample Input 24 2 7\n\nSample Output 27\n\nSample Input 34 2 8\n\nSample Output 38",
        "desc": "This Java problem requires calculating the minimum total travel cost by comparing the cumulative train expenses (N × A) with the fixed taxi fare (B), testing basic arithmetic operations and conditional decision-making. It is classified as an easy-level problem appropriate for beginners.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n      \tint n = sc.nextInt();\n      \tint a = sc.nextInt();\n      \tint b = sc.nextInt();\n      \tSystem.out.println(Math.min(a*n, b));\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02957",
        "question": "Score: 100 points\n\nProblem StatementWe have two distinct integers A and B.\nPrint the integer K such that |A - K| = |B - K|.\nIf such an integer does not exist, print IMPOSSIBLE instead.\n\nConstraints\nAll values in input are integers.\n0 \\leq A,\\ B \\leq 10^9\nA and B are distinct.\n\nInputInput is given from Standard Input in the following format:\nA B\n\nOutputPrint the integer K satisfying the condition.\nIf such an integer does not exist, print IMPOSSIBLE instead.\n\nSample Input 12 16\n\nSample Output 19\n\n|2 - 9| = 7 and |16 - 9| = 7, so 9 satisfies the condition.\n\nSample Input 20 3\n\nSample Output 2IMPOSSIBLE\n\nNo integer satisfies the condition.\n\nSample Input 3998244353 99824435\n\nSample Output 3549034394",
        "desc": "This problem tests understanding of absolute value properties and arithmetic to determine an integer equidistant from two distinct numbers, including handling cases where no such integer exists. It is classified as an easy to intermediate difficulty level programming challenge.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n      \tint a = sc.nextInt();\n\t\tint b = sc.nextInt();\n      \tif(a%2 != b%2) System.out.println(\"IMPOSSIBLE\");\n\t\telse System.out.println((a+b)/2);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02951",
        "question": "Score : 100 points\n\nProblem StatementWe have two bottles for holding water.\nBottle 1 can hold up to A milliliters of water, and now it contains B milliliters of water.\nBottle 2 contains C milliliters of water.\nWe will transfer water from Bottle 2 to Bottle 1 as much as possible.\nHow much amount of water will remain in Bottle 2?\n\nConstraints\nAll values in input are integers.\n1 \\leq B \\leq A \\leq 20\n1 \\leq C \\leq 20\n\nInputInput is given from Standard Input in the following format:\nA B C\n\nOutputPrint the integer representing the amount of water, in milliliters, that will remain in Bottle 2.\n\nSample Input 16 4 3\n\nSample Output 11\n\nWe will transfer two milliliters of water from Bottle 2 to Bottle 1, and one milliliter of water will remain in Bottle 2.\n\nSample Input 28 3 9\n\nSample Output 24\n\nSample Input 312 3 7\n\nSample Output 30",
        "desc": "This Java problem assesses understanding of basic input handling, arithmetic operations, and conditional logic by requiring the calculation of remaining water after transferring between two bottles. It is categorized as an easy-level programming challenge.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n      \tint a = sc.nextInt();\n\t\tint b = sc.nextInt();\n      \tint c = sc.nextInt();\n      \tif(c-(a-b) > 0) System.out.println(c-(a-b));\n      \telse System.out.println(0);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02945",
        "question": "Score : 100 points\n\nProblem StatementWe have two integers: A and B.\nPrint the largest number among A + B, A - B, and A \\times B.\n\nConstraints\nAll values in input are integers.\n-100 \\leq A,\\ B \\leq 100\n\nInputInput is given from Standard Input in the following format:\nA B\n\nOutputPrint the largest number among A + B, A - B, and A \\times B.\n\nSample Input 1-13 3\n\nSample Output 1-10\n\nThe largest number among A + B = -10, A - B = -16, and A \\times B = -39 is -10.\n\nSample Input 21 -33\n\nSample Output 234\n\nThe largest number among A + B = -32, A - B = 34, and A \\times B = -33 is 34.\n\nSample Input 313 3\n\nSample Output 339\n\nThe largest number among A + B = 16, A - B = 10, and A \\times B = 39 is 39.",
        "desc": "This Java problem evaluates the ability to perform basic arithmetic operations and implement conditional logic to compare and determine the maximum value among several computed results. It is categorized as an **Easy** difficulty level, making it suitable for beginners learning fundamental programming concepts.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n      \tint a = sc.nextInt();\n\t\tint b = sc.nextInt();\n      \tSystem.out.println(Math.max(a*b,Math.max(a+b, a-b)));\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03835",
        "question": "Score : 200 points\n\nProblem StatementYou are given two integers K and S.\nThree variable X, Y and Z takes integer values satisfying 0≤X,Y,Z≤K.\nHow many different assignments of values to X, Y and Z are there such that X + Y + Z = S?  \n\nConstraints\n2≤K≤2500 \n0≤S≤3K \nK and S are integers.  \n\nInputThe input is given from Standard Input in the following format:\nK S\n\nOutputPrint the number of the triples of X, Y and Z that satisfy the condition.\n\nSample Input 12 2\n\nSample Output 16\n\nThere are six triples of X, Y and Z that satisfy the condition:\n\nX = 0, Y = 0, Z = 2 \nX = 0, Y = 2, Z = 0 \nX = 2, Y = 0, Z = 0 \nX = 0, Y = 1, Z = 1 \nX = 1, Y = 0, Z = 1 \nX = 1, Y = 1, Z = 0\n\nSample Input 25 15\n\nSample Output 21\n\nThe maximum value of X + Y + Z is 15, achieved by one triple of X, Y and Z.",
        "desc": "This problem requires determining the number of non-negative integer triples (X, Y, Z) within a specified range that sum to a given value, testing combinatorial counting and efficient algorithm implementation skills. It is categorized as a medium-difficulty question suitable for competitive programming scenarios.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n      \tint K = sc.nextInt();\n      \tint S = sc.nextInt();\n      \tint count = 0;\n      \tfor(int i = 0; i <= K; i++){\n        \tfor(int j = 0; j <= K; j++){\n            \tfor(int k = 0; k <= K; k++){\n                \tif(i+j+k == S) count++;\n                }\n            }\n        }\n      \tSystem.out.println(count);\n    }\n}",
        "error_desc": "1. The solution uses three nested loops, resulting in a time complexity of O(K³), which is too slow for K up to 2500.\n2. The program does not apply any mathematical optimizations or combinatorial formulas to reduce the number of calculations.\n3. There is no mechanism to break early from loops when the sum exceeds S, leading to unnecessary iterations."
    },
    {
        "problem_id": "p02909",
        "question": "Score: 100 points\n\nProblem Statement\nThe weather in Takahashi's town changes day by day, in the following cycle: Sunny, Cloudy, Rainy, Sunny, Cloudy, Rainy, ...\nGiven is a string S representing the weather in the town today. Predict the weather tomorrow.\n\nConstraints\n\nS is Sunny, Cloudy, or Rainy.\n\nInput\nInput is given from Standard Input in the following format:\nS\n\nOutput\nPrint a string representing the expected weather tomorrow, in the same format in which input is given.\n\nSample Input 1Sunny\n\nSample Output 1Cloudy\n\nIn Takahashi's town, a sunny day is followed by a cloudy day.\n\nSample Input 2Rainy\n\nSample Output 2Sunny",
        "desc": "This Java problem asks students to determine the next day's weather based on a fixed three-day cycle (\"Sunny\" → \"Cloudy\" → \"Rainy\"). It tests understanding of string manipulation and basic control structures, and is classified as an easy-level challenge.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n      \tchar s = sc.next().charAt(0);\n      \tif(s=='S') System.out.println(\"Cloudy\");\n      \telse if(s=='C') System.out.println(\"Rainy\");\n      \telse System.out.println(\"Sunny\");\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02897",
        "question": "Score : 100 points\n\nProblem StatementGiven is an integer N.\nTakahashi chooses an integer a from the positive integers not greater than N with equal probability.\nFind the probability that a is odd.\n\nConstraints\n1 \\leq N \\leq 100\n\nInputInput is given from Standard Input in the following format:\nN\n\nOutputPrint the probability that a is odd.\nYour output will be considered correct when its absolute or relative error from the judge's output is at most 10^{-6}.\n\nSample Input 14\n\nSample Output 10.5000000000\n\nThere are four positive integers not greater than 4: 1, 2, 3, and 4. Among them, we have two odd numbers: 1 and 3. Thus, the answer is \\frac{2}{4} = 0.5.\n\nSample Input 25\n\nSample Output 20.6000000000\n\nSample Input 31\n\nSample Output 31.0000000000",
        "desc": "This Java problem assesses the ability to compute probabilities by determining the ratio of odd integers within a given range from 1 to N. It tests fundamental programming concepts such as control flow, arithmetic operations, and handling input/output, and is considered to be of easy difficulty.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n      \tdouble n = sc.nextDouble();\n      \tif(n%2==0) System.out.println(0.5);\n      \telse System.out.println((n+1)/2/n);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02879",
        "question": "Score : 100 points\n\nProblem StatementHaving learned the multiplication table, Takahashi can multiply two integers between 1 and 9 (inclusive) together. He cannot do any other calculation.\nGiven are two integers A and B.\nIf Takahashi can calculate A \\times B, print the result; if he cannot, print -1 instead.\n\nConstraints\n1 \\leq A \\leq 20\n1 \\leq B \\leq 20\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nA B\n\nOutputIf Takahashi can calculate A \\times B, print the result; if he cannot, print -1.\n\nSample Input 12 5\n\nSample Output 110\n\n2 \\times 5 = 10.\n\nSample Input 25 10\n\nSample Output 2-1\n\n5\\times 10 = 50, but Takahashi cannot do this calculation, so print -1 instead.\n\nSample Input 39 9\n\nSample Output 381",
        "desc": "This Java problem tests the ability to implement conditional statements and perform basic arithmetic operations, specifically multiplication within given constraints (integers between 1 and 9). It is classified as an easy difficulty level.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n      \tint a = sc.nextInt();\n      \tint b = sc.nextInt();\n      \tif((a<1 || a>9) || (b<1 || b>9)) System.out.println(-1);\n      \telse System.out.println(a*b);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03814",
        "question": "Score : 200 points\n\nProblem StatementSnuke has decided to construct a string that starts with A and ends with Z, by taking out a substring of a string s (that is, a consecutive part of s).\nFind the greatest length of the string Snuke can construct. Here, the test set guarantees that there always exists a substring of s that starts with A and ends with Z.\n\nConstraints\n1 ≦ |s| ≦ 200{,}000\ns consists of uppercase English letters.\nThere exists a substring of s that starts with A and ends with Z.\n\nInputThe input is given from Standard Input in the following format:\ns\n\nOutputPrint the answer.\n\nSample Input 1QWERTYASDFZXCV\n\nSample Output 15\n\nBy taking out the seventh through eleventh characters, it is possible to construct ASDFZ, which starts with A and ends with Z.\n\nSample Input 2ZABCZ\n\nSample Output 24\n\nSample Input 3HASFJGHOGAKZZFEGA\n\nSample Output 312",
        "desc": "This Java problem asks for the longest possible substring within a given string `s` that starts with the character 'A' and ends with 'Z'. It tests understanding of efficient string manipulation and traversal algorithms, particularly handling large input sizes up to 200,000 characters, and is classified as a medium to hard difficulty level.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n      \tchar[] s = sc.next().toCharArray();\n      \tint a, z;\n      \tint i = 0;\n      \tint j = s.length-1;\n      \twhile(true){\n        \tif(s[i] == 'A'){\n              \ta=i;\n          \t\tbreak;\n            }\n          \ti++;\n        }\n      \twhile(true){\n         \tif(s[j] == 'Z'){\n            \tz=j;\n              \tbreak;\n            }\n          \tj--;\n        }\n      \tSystem.out.println(j-i+1);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02576",
        "question": "Score : 100 points\n\nProblem StatementTakahashi loves takoyaki - a ball-shaped snack.\nWith a takoyaki machine, he can make at most X pieces of takoyaki at a time, taking T minutes regardless of the number of pieces to make.\nHow long does it take to make N takoyaki?\n\nConstraints\n1 \\leq N,X,T \\leq 1000\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nN X T\n\nOutputPrint an integer representing the minimum number of minutes needed to make N pieces of takoyaki.\n\nSample Input 120 12 6\n\nSample Output 112\n\nHe can make 12 pieces of takoyaki in the first 6 minutes and 8 more in the next 6 minutes, so he can make 20 in a total of 12 minutes.\nNote that being able to make 12 in 6 minutes does not mean he can make 2 in 1 minute.\n\nSample Input 21000 1 1000\n\nSample Output 21000000\n\nIt seems to take a long time to make this kind of takoyaki.",
        "desc": "This Java programming problem involves calculating the minimum time required to produce a specified number of takoyaki using a machine that can handle a limited batch size, testing concepts such as integer division, ceiling operations, and basic arithmetic calculations. It is categorized as an easy to medium difficulty level problem.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n      \tint n = sc.nextInt();\n      \tint x = sc.nextInt();\n      \tint t = sc.nextInt();\n      \tint time;\n      \tif(n%x==0) time = (n/x)*t;\n      \telse time = ((n/x)+1)*t;\n      \tSystem.out.println(time);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02577",
        "question": "Score : 200 points\n\nProblem StatementAn integer N is a multiple of 9 if and only if the sum of the digits in the decimal representation of N is a multiple of 9.\nDetermine whether N is a multiple of 9.\n\nConstraints\n0 \\leq N &lt; 10^{200000}\nN is an integer.\n\nInputInput is given from Standard Input in the following format:\nN\n\nOutputIf N is a multiple of 9, print Yes; otherwise, print No.\n\nSample Input 1123456789\n\nSample Output 1Yes\n\nThe sum of these digits is 1+2+3+4+5+6+7+8+9=45, which is a multiple of 9, so 123456789 is a multiple of 9.\n\nSample Input 20\n\nSample Output 2Yes\n\nSample Input 331415926535897932384626433832795028841971693993751058209749445923078164062862089986280\n\nSample Output 3No",
        "desc": "This Java problem assesses understanding of the divisibility rule for 9 and the ability to handle very large integers by processing them as strings. It is rated as medium to hard difficulty due to the need for efficient digit summation on inputs with up to 200,000 digits.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n    \tchar[] n = sc.next().toCharArray();\n    \tint sum = 0;\n    \tfor(int i = 0; i < n.length; i++){\n        \tsum += Character.getNumericValue(n[i]);\n        }\n      \tif(sum%9==0) System.out.println(\"Yes\");\n      \telse System.out.println(\"No\");\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02578",
        "question": "Score : 300 points\n\nProblem StatementN persons are standing in a row. The height of the i-th person from the front is A_i.\nWe want to have each person stand on a stool of some heights - at least zero - so that the following condition is satisfied for every person:\nCondition: Nobody in front of the person is taller than the person. Here, the height of a person includes the stool.\nFind the minimum total height of the stools needed to meet this goal.\n\nConstraints\n1 \\leq N \\leq 2\\times 10^5\n1 \\leq A_i \\leq 10^9\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nN\nA_1 \\ldots A_N\n\nOutputPrint the minimum total height of the stools needed to meet the goal.\n\nSample Input 15\n2 1 5 4 3\n\nSample Output 14\n\nIf the persons stand on stools of heights 0, 1, 0, 1, and 2, respectively, their heights will be 2, 2, 5, 5, and 5, satisfying the condition.\nWe cannot meet the goal with a smaller total height of the stools.\n\nSample Input 25\n3 3 3 3 3\n\nSample Output 20\n\nGiving a stool of height 0 to everyone will work.",
        "desc": "This Java problem assesses knowledge of greedy algorithms and efficient array manipulation to ensure non-decreasing heights by optimizing stool placements. It is classified as a hard-level challenge due to its requirement to handle large input sizes (up to 200,000 elements) with optimal performance.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n    \tint n = sc.nextInt();\n      \tint[] a = new int[n];\n      \tfor(int i = 0; i < n; i++){\n        \ta[i] = sc.nextInt();\n        }\n      \tint sum = 0;\n      \tfor(int i = 0; i < n-1; i++){\n        \tif(a[i] > a[i+1]){\n            \tsum += a[i] - a[i+1];\n              \ta[i+1]+= a[i] - a[i+1];\n            }\n        }\n      \tSystem.out.println(sum);\n    }\n}",
        "error_desc": "1. The code modifies the original height array `a` instead of calculating separate stool heights.\n2. It incorrectly adds the difference between `a[i]` and `a[i+1]` to `sum` instead of computing the required stool heights.\n3. The logic only compares each person with the next one, ignoring the cumulative height requirements from all previous persons.\n4. The stool heights are not initialized or managed separately, leading to an inaccurate total sum."
    },
    {
        "problem_id": "p02847",
        "question": "Score : 100 points\n\nProblem StatementGiven is a string S representing the day of the week today.\nS is SUN, MON, TUE, WED, THU, FRI, or SAT, for Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, and Saturday, respectively.\nAfter how many days is the next Sunday (tomorrow or later)?\n\nConstraints\nS is SUN, MON, TUE, WED, THU, FRI, or SAT.\n\nInputInput is given from Standard Input in the following format:\nS\n\nOutputPrint the number of days before the next Sunday.\n\nSample Input 1SAT\n\nSample Output 11\n\nIt is Saturday today, and tomorrow will be Sunday.\n\nSample Input 2SUN\n\nSample Output 27\n\nIt is Sunday today, and seven days later, it will be Sunday again.",
        "desc": "This Java problem assesses understanding of string manipulation, mapping enumerated values (days of the week) to numerical representations, and applying modular arithmetic to calculate intervals. It is considered to have an easy to medium difficulty level.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n      \tString s = sc.next();\n      \tswitch(s){\n          case \"SUN\":\n            System.out.println(7);\n            break;\n          case \"MON\":\n            System.out.println(6);\n            break;\n          case \"TUE\":\n            System.out.println(5);\n            break;\n          case \"WED\":\n            System.out.println(4);\n            break;\n          case \"THU\":\n            System.out.println(3);\n            break;\n          case \"FRI\":\n            System.out.println(2);\n            break;\n          case \"SAT\":\n            System.out.println(1);\n            break;\n        }\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02835",
        "question": "Score : 100 points\n\nProblem StatementGiven are three integers A_1, A_2, and A_3.\nIf A_1+A_2+A_3 is greater than or equal to 22, print bust; otherwise, print win.\n\nConstraints\n1 \\leq A_i \\leq 13 \\ \\ (i=1,2,3)\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nA_1 A_2 A_3\n\nOutputIf A_1+A_2+A_3 is greater than or equal to 22, print bust; otherwise, print win.\n\nSample Input 15 7 9\n\nSample Output 1win\n\n5+7+9=21, so print win.\n\nSample Input 213 7 2\n\nSample Output 2bust\n\n13+7+2=22, so print bust.",
        "desc": "This Java problem requires reading three integer inputs, calculating their sum, and using conditional statements to determine and print \"bust\" if the sum is at least 22 or \"win\" otherwise. It tests fundamental concepts such as input handling, arithmetic operations, and conditional logic, and is classified as an easy-level problem.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n      \tint A1 = sc.nextInt();\n      \tint A2 = sc.nextInt();\n        int A3 = sc.nextInt();\n      \tif(A1+A2+A3>=22) System.out.println(\"bust\");\n     \telse System.out.println(\"win\");\n    }\n}",
        "error_desc": "No error."
    }
]