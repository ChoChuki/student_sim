[
    {
        "problem_id": "p03449",
        "question": "Score : 300 points\n\nProblem StatementWe have a 2 \\times N grid. We will denote the square at the i-th row and j-th column (1 \\leq i \\leq 2, 1 \\leq j \\leq N) as (i, j).\nYou are initially in the top-left square, (1, 1).\nYou will travel to the bottom-right square, (2, N), by repeatedly moving right or down.\nThe square (i, j) contains A_{i, j} candies.\nYou will collect all the candies you visit during the travel.\nThe top-left and bottom-right squares also contain candies, and you will also collect them.\nAt most how many candies can you collect when you choose the best way to travel?\n\nConstraints\n1 \\leq N \\leq 100\n1 \\leq A_{i, j} \\leq 100 (1 \\leq i \\leq 2, 1 \\leq j \\leq N)\n\nInputInput is given from Standard Input in the following format:\nN\nA_{1, 1} A_{1, 2} ... A_{1, N}\nA_{2, 1} A_{2, 2} ... A_{2, N}\n\nOutputPrint the maximum number of candies that can be collected.\n\nSample Input 15\n3 2 2 4 1\n1 2 2 2 1\n\nSample Output 114\n\nThe number of collected candies will be maximized when you:\n\nmove right three times, then move down once, then move right once.\n\nSample Input 24\n1 1 1 1\n1 1 1 1\n\nSample Output 25\n\nYou will always collect the same number of candies, regardless of how you travel.\n\nSample Input 37\n3 3 4 5 4 5 3\n5 3 4 4 2 3 2\n\nSample Output 329\n\nSample Input 41\n2\n3\n\nSample Output 45",
        "desc": "This C++ problem requires implementing dynamic programming to determine the optimal path for collecting the maximum number of candies in a 2×N grid by moving only right or down. It tests understanding of grid traversal and state optimization techniques, and is considered to be of medium difficulty.",
        "program": "#include <bits/stdc++.h>\n#include <iostream>\n#include <string>\n#include <string.h>\nusing namespace std;\nint main() {\n  int n,A1[110],A2[110];\n  cin >> n;\n  for(int i = 0; i < n; i++)\n    cin >> A1[i];\n  for(int i = 0; i < n; i++)\n    cin >> A2[i];\n  int ans = 0;\n  for(int i = 0; i < n; i++) {\n    int count = 0;\n    for(int j = 0; j < n; j++) {\n      if(i+j < n) count += A1[j];\n      if(n-i-1+j < n) count += A2[n-i-1+j];\n    }\n    ans = max(ans,count);\n  }\n  cout << ans << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02613",
        "question": "Score : 200 points\n\nProblem StatementTakahashi is participating in a programming contest called AXC002, and he has just submitted his code to Problem A.\nThe problem has N test cases.\nFor each test case i (1\\leq i \\leq N), you are given a string S_i representing the verdict for that test case. Find the numbers of test cases for which the verdict is AC, WA, TLE, and RE, respectively.\nSee the Output section for the output format.\n\nConstraints\n1 \\leq N \\leq 10^5\nS_i is AC, WA, TLE, or RE.\n\nInputInput is given from Standard Input in the following format:\nN\nS_1\n\\vdots\nS_N\n\nOutputLet C_0, C_1, C_2, and C_3 be the numbers of test cases for which the verdict is AC, WA, TLE, and RE, respectively. Print the following:\nAC x C_0\nWA x C_1\nTLE x C_2\nRE x C_3\n\nSample Input 16\nAC\nTLE\nAC\nAC\nWA\nTLE\n\nSample Output 1AC x 3\nWA x 1\nTLE x 2\nRE x 0\n\nWe have 3, 1, 2, and 0 test case(s) for which the verdict is AC, WA, TLE, and RE, respectively.\n\nSample Input 210\nAC\nAC\nAC\nAC\nAC\nAC\nAC\nAC\nAC\nAC\n\nSample Output 2AC x 10\nWA x 0\nTLE x 0\nRE x 0",
        "desc": "This C++ problem requires counting the occurrences of specific verdict strings (\"AC\", \"WA\", \"TLE\", \"RE\") from a list of up to 10⁵ inputs, testing knowledge of efficient input handling and frequency counting using arrays or hash maps. It is categorized as an easy-level problem, suitable for beginners to practice basic string processing and counting techniques.",
        "program": "#include <bits/stdc++.h>\n#include <iostream>\n#include <string>\n#include <string.h>\n#include <ctype.h>\n#include <algorithm>\nusing namespace std;\nint main() {\n  int n;\n  int ac = 0, wa = 0, tle = 0, re = 0;\n  string s;\n  cin >> n;\n  for(int i = 0; i < n; i++) {\n    cin >> s;\n    if(s == \"AC\") ac++;\n    if(s == \"WA\") wa++;\n    if(s == \"TLE\") tle++;\n    if(s == \"RE\") re++;\n  }\n  cout << \"AC × \"  << ac << endl;\n  cout << \"WA × \"  << wa << endl;\n  cout << \"TLE × \"  << tle << endl;\n  cout << \"RE × \"  << re << endl;\n}",
        "error_desc": "1. The output uses “×” instead of the required “x” character.\n2. The program includes unnecessary header files such as `<string.h>` and `<ctype.h>`.\n3. The code does not return a value from the `main` function."
    },
    {
        "problem_id": "p02622",
        "question": "Score : 200 points\n\nProblem StatementGiven are strings S and T. Consider changing S to T by repeating the operation below. Find the minimum number of operations required to do so.\nOperation: Choose one character of S and replace it with a different character.\n\nConstraints\nS and T have lengths between 1 and 2\\times 10^5 (inclusive).\nS and T consists of lowercase English letters.\nS and T have equal lengths.\n\nInputInput is given from Standard Input in the following format:\nS\nT\n\nOutputPrint the answer.\n\nSample Input 1cupofcoffee\ncupofhottea\n\nSample Output 14\n\nWe can achieve the objective in four operations, such as the following:\n\nFirst, replace the sixth character c with h.\nSecond, replace the eighth character f with t.\nThird, replace the ninth character f with t.\nFourth, replace the eleventh character e with a.\n\nSample Input 2abcde\nbcdea\n\nSample Output 25\n\nSample Input 3apple\napple\n\nSample Output 30\n\nNo operations may be needed to achieve the objective.",
        "desc": "This C++ problem requires determining the minimum number of single-character replacement operations needed to transform one string into another of equal length, efficiently handling strings up to 200,000 characters. It tests knowledge of string manipulation, character comparison, and optimization techniques for large input sizes, and is classified as medium to hard difficulty.",
        "program": "#include <bits/stdc++.h>\n#include <iostream>\n#include <string>\n#include <string.h>\n#include <ctype.h>\n#include <algorithm>\nusing namespace std;\nint main() {\n  string s,t;\n  cin >> s >> t;\n  int c = 0;\n  for(int i = 0; i < s.size(); i++)\n    if(s[i] != t[i]) c++;\n  cout << c << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02628",
        "question": "Score : 200 points\n\nProblem StatementA shop sells N kinds of fruits, Fruit 1, \\ldots, N, at prices of p_1, \\ldots, p_N yen per item, respectively. (Yen is the currency of Japan.)\nHere, we will choose K kinds of fruits and buy one of each chosen kind. Find the minimum possible total price of those fruits.\n\nConstraints\n1 \\leq K \\leq N \\leq 1000\n1 \\leq p_i \\leq 1000\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nN K\np_1 p_2 \\ldots p_N\n\nOutputPrint an integer representing the minimum possible total price of fruits.\n\nSample Input 15 3\n50 100 80 120 80\n\nSample Output 1210\n\nThis shop sells Fruit 1, 2, 3, 4, and 5 for 50 yen, 100 yen, 80 yen, 120 yen, and 80 yen, respectively.\nThe minimum total price for three kinds of fruits is 50 + 80 + 80 = 210 yen when choosing Fruit 1, 3, and 5.\n\nSample Input 21 1\n1000\n\nSample Output 21000",
        "desc": "This C++ problem involves selecting the cheapest **K** fruits from a list of **N** priced items, requiring knowledge of sorting algorithms and efficient array handling to compute the minimum total cost. It assesses fundamental problem-solving skills and is classified as an **Easy to Medium** difficulty level.",
        "program": "#include <bits/stdc++.h>\n#include <iostream>\n#include <string>\n#include <string.h>\n#include <ctype.h>\n#include <algorithm>\nusing namespace std;\nvoid bubble(int p[], int n) {\n  for(int i = 0; i < n; i++) {\n    for(int j = n-1; j >= i+1; j--)\n      if(p[j] < p[j-1]) swap(p[j],p[j-1]);\n  }\n}\nint main() {\n  int n,k,p[1100];\n  cin >> n >> k;\n  for(int i = 0; i < n; i++)\n    cin >> p[i];\n  bubble(p,n);\n  int ans = 0;\n  for(int i = 0; i < k; i++) {\n    ans += p[i];\n  }\n  cout << ans << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03433",
        "question": "Score: 100 points\n\nProblem Statement\nE869120 has A 1-yen coins and infinitely many 500-yen coins.\nDetermine if he can pay exactly N yen using only these coins.\n\nConstraints\n\nN is an integer between 1 and 10000 (inclusive).\nA is an integer between 0 and 1000 (inclusive).\n\nInput\nInput is given from Standard Input in the following format:\nN\nA\n\nOutput\nIf E869120 can pay exactly N yen using only his 1-yen and 500-yen coins, print Yes; otherwise, print No.\n\nSample Input 12018\n218\n\nSample Output 1Yes\n\nWe can pay 2018 yen with four 500-yen coins and 18 1-yen coins, so the answer is Yes.\n\nSample Input 22763\n0\n\nSample Output 2No\n\nWhen we have no 1-yen coins, we can only pay a multiple of 500 yen using only 500-yen coins. Since 2763 is not a multiple of 500, we cannot pay this amount.\n\nSample Input 337\n514\n\nSample Output 3Yes",
        "desc": "This C++ problem assesses understanding of greedy algorithms and modular arithmetic by requiring determination of whether a specific amount can be formed using a limited number of 1-yen coins and unlimited 500-yen coins. It is categorized as a medium difficulty level problem.",
        "program": "#include <bits/stdc++.h>\n#include <iostream>\n#include <string>\n#include <string.h>\n#include <ctype.h>\n#include <algorithm>\nusing namespace std;\nint main() {\n  int n,a;\n  cin >> n >> a;\n  int num = n % 500;\n  if(num <= a) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03477",
        "question": "Score : 100 points\n\nProblem StatementA balance scale tips to the left if L&gt;R, where L is the total weight of the masses on the left pan and R is the total weight of the masses on the right pan. Similarly, it balances if L=R, and tips to the right if L&lt;R.\nTakahashi placed a mass of weight A and a mass of weight B on the left pan of a balance scale, and placed a mass of weight C and a mass of weight D on the right pan.\nPrint Left if the balance scale tips to the left; print Balanced if it balances; print Right if it tips to the right.\n\nConstraints\n1\\leq A,B,C,D \\leq 10\nAll input values are integers.\n\nInputInput is given from Standard Input in the following format:\nA B C D\n\nOutputPrint Left if the balance scale tips to the left; print Balanced if it balances; print Right if it tips to the right.\n\nSample Input 13 8 7 1\n\nSample Output 1Left\n\nThe total weight of the masses on the left pan is 11, and the total weight of the masses on the right pan is 8. Since 11&gt;8, we should print Left.\n\nSample Input 23 4 5 2\n\nSample Output 2Balanced\n\nThe total weight of the masses on the left pan is 7, and the total weight of the masses on the right pan is 7. Since 7=7, we should print Balanced.\n\nSample Input 31 7 6 4\n\nSample Output 3Right\n\nThe total weight of the masses on the left pan is 8, and the total weight of the masses on the right pan is 10. Since 8&lt;10, we should print Right.",
        "desc": "The problem requires reading four integer weights, calculating the sums on each side of a balance scale, and determining its state by comparing these sums. It tests basic input/output operations, arithmetic calculations, and conditional logic, and is classified as an easy-level C++ programming challenge.",
        "program": "#include <bits/stdc++.h>\n#include <iostream>\n#include <string>\n#include <string.h>\n#include <ctype.h>\n#include <algorithm>\nusing namespace std;\nint main() {\n  int a,b,c,d;\n  cin >> a >> b >> c >> d;\n  if(a+b == c+d)\n    cout << \"Balanced\" << endl;\n  else if(a+b > c+d)\n    cout << \"Left\" << endl;\n  else\n    cout << \"Right\" << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02640",
        "question": "Score : 200 points\n\nProblem StatementThere are some animals in a garden. Each of them is a crane with two legs or a turtle with four legs.\nTakahashi says: \"there are X animals in total in the garden, and they have Y legs in total.\" Determine whether there is a combination of numbers of cranes and turtles in which this statement is correct.\n\nConstraints\n1 \\leq X \\leq 100\n1 \\leq Y \\leq 100\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nX Y\n\nOutputIf there is a combination of numbers of cranes and turtles in which the statement is correct, print Yes; otherwise, print No.\n\nSample Input 13 8\n\nSample Output 1Yes\n\nThe statement \"there are 3 animals in total in the garden, and they have 8 legs in total\" is correct if there are two cranes and one turtle. Thus, there is a combination of numbers of cranes and turtles in which the statement is correct.\n\nSample Input 22 100\n\nSample Output 2No\n\nThere is no combination of numbers of cranes and turtles in which this statement is correct.\n\nSample Input 31 2\n\nSample Output 3Yes\n\nWe also consider the case in which there are only cranes or only turtles.",
        "desc": "This C++ problem requires determining if a given total number of animals and legs can be achieved using cranes (2 legs) and turtles (4 legs), testing understanding of integer arithmetic and conditional logic. It is classified as an easy to medium difficulty level programming challenge.",
        "program": "#include <bits/stdc++.h>\n#include <iostream>\n#include <string>\n#include <string.h>\n#include <ctype.h>\n#include <algorithm>\nusing namespace std;\nint main() {\n  int x,y;\n  cin >> x >> y;\n  for(int i = 0; i <= 100; i++) {\n    for(int j = 0; j <=100; j++) {\n      if(i+j == x & i*2+j*4 == y) {\n        cout << \"Yes\" << endl;\n        return 0;\n      }\n    }\n  }\n  cout << \"No\" << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02993",
        "question": "Score : 100 points\n\nProblem Statement\nThe door of Snuke's laboratory is locked with a security code.\nThe security code is a 4-digit number. We say the security code is hard to enter when it contains two consecutive digits that are the same.\nYou are given the current security code S. If S is hard to enter, print Bad; otherwise, print Good.\n\nConstraints\n\nS is a 4-character string consisting of digits.\n\nInput\nInput is given from Standard Input in the following format:\nS\n\nOutput\nIf S is hard to enter, print Bad; otherwise, print Good.\n\nSample Input 13776\n\nSample Output 1Bad\n\nThe second and third digits are the same, so 3776 is hard to enter.\n\nSample Input 28080\n\nSample Output 2Good\n\nThere are no two consecutive digits that are the same, so 8080 is not hard to enter.\n\nSample Input 31333\n\nSample Output 3Bad\n\nSample Input 40024\n\nSample Output 4Bad",
        "desc": "This C++ problem involves determining whether a 4-digit security code contains two identical consecutive digits, testing skills in string manipulation and iteration. It is categorized as an easy-level challenge.",
        "program": "#include <bits/stdc++.h>\n#include <iostream>\n#include <string>\n#include <string.h>\n#include <ctype.h>\n#include <algorithm>\nusing namespace std;\nint main() {\n  string s;\n  cin >> s;\n  if(s[0] == s[1]) cout << \"Bad\" << endl;\n  else if(s[1] == s[2]) cout << \"Bad\" << endl;\n  else if(s[2] == s[3]) cout << \"Bad\" << endl;\n  else cout << \"Yes\" << endl;\n}",
        "error_desc": "1. The program outputs \"Yes\" instead of \"Good\" when the security code is not hard to enter.\n2. The program includes unnecessary headers such as `<string.h>` and `<ctype.h>` which are not required for this solution.\n3. The final output \"Yes\" does not match the problem's requirement to print \"Good\"."
    },
    {
        "problem_id": "p02987",
        "question": "Score : 100 points\n\nProblem StatementYou are given a 4-character string S consisting of uppercase English letters.\nDetermine if S consists of exactly two kinds of characters which both appear twice in S.\n\nConstraints\nThe length of S is 4.\nS consists of uppercase English letters.\n\nInputInput is given from Standard Input in the following format:\nS\n\nOutputIf S consists of exactly two kinds of characters which both appear twice in S, print Yes; otherwise, print No.\n\nSample Input 1ASSA\n\nSample Output 1Yes\n\nS consists of A and S which both appear twice in S.\n\nSample Input 2STOP\n\nSample Output 2No\n\nSample Input 3FFEE\n\nSample Output 3Yes\n\nSample Input 4FREE\n\nSample Output 4No",
        "desc": "This C++ problem tests string manipulation and frequency counting skills by requiring the programmer to determine whether a given 4-character uppercase string contains exactly two distinct characters, each appearing twice. It is considered an easy-level challenge suitable for beginners.",
        "program": "#include <bits/stdc++.h>\n#include <iostream>\n#include <string>\n#include <string.h>\n#include <ctype.h>\n#include <algorithm>\nusing namespace std;\nint main() {\n  string s;\n  cin >> s;\n  if(s[0] == s[1]) {\n    if(s[2] == s[3]) cout << \"Yes\" << endl;\n  }\n  else if(s[1] == s[2]) {\n    if(s[0] == s[3]) cout << \"Yes\" << endl;\n  }\n  else if(s[2] == s[3]) {\n    if(s[0] == s[1]) cout << \"Yes\" << endl;\n  }\n  else if(s[3] == s[0]) {\n    if(s[1] == s[2]) cout << \"Yes\" << endl;\n  }\n  else cout << \"No\" << endl;\n}",
        "error_desc": "1. The code only checks for adjacent character pairs and misses other valid pairings like `s[0] == s[2]` and `s[1] == s[3]`.\n2. It incorrectly outputs \"Yes\" when all four characters are identical, despite requiring exactly two distinct characters each appearing twice.\n3. The conditional structure does not cover all possible combinations of character pairings needed to determine the correct result."
    },
    {
        "problem_id": "p02988",
        "question": "Score : 200 points\n\nProblem StatementWe have a permutation p = {p_1,\\ p_2,\\ ...,\\ p_n} of {1,\\ 2,\\ ...,\\ n}.\nPrint the number of elements p_i (1 &lt; i &lt; n) that satisfy the following condition:\n\np_i is the second smallest number among the three numbers p_{i - 1}, p_i, and p_{i + 1}.\n\nConstraints\nAll values in input are integers.\n3 \\leq n \\leq 20\np is a permutation of {1,\\ 2,\\ ...,\\ n}.\n\nInputInput is given from Standard Input in the following format:\nn\np_1 p_2 ... p_n\n\nOutputPrint the number of elements p_i (1 &lt; i &lt; n) that satisfy the condition.\n\nSample Input 15\n1 3 5 4 2\n\nSample Output 12\n\np_2 = 3 is the second smallest number among p_1 = 1, p_2 = 3, and p_3 = 5. Also, p_4 = 4 is the second smallest number among p_3 = 5, p_4 = 4, and p_5 = 2. These two elements satisfy the condition.\n\nSample Input 29\n9 6 3 2 5 8 7 4 1\n\nSample Output 25",
        "desc": "This C++ problem requires identifying elements in a permutation that are the second smallest among their immediate neighbors, testing understanding of array traversal and permutation properties. It is categorized as an easy to moderate difficulty level, suitable for beginners practicing basic algorithm implementation.",
        "program": "#include <bits/stdc++.h>\n#include <iostream>\n#include <string>\n#include <string.h>\n#include <ctype.h>\n#include <algorithm>\nusing namespace std;\nint main() {\n  int n,p[100],sum = 0;\n  cin >> n;\n  for(int i = 0; i < n; i++)\n    cin >> p[i];\n  for(int i = 1; i < n-1; i++) {\n    if(p[i-1] < p[i] & p[i] < p[i+1]) sum++;\n    else if(p[i+1] < p[i] & p[i] < p[i-1]) sum++;\n  }\n  cout << sum << endl;\n}",
        "error_desc": "No error."
    }
]