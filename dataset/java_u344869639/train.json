[
    {
        "problem_id": "p03632",
        "question": "Score : 200 points\n\nProblem StatementAlice and Bob are controlling a robot. They each have one switch that controls the robot.\nAlice started holding down her button A second after the start-up of the robot, and released her button B second after the start-up.\nBob started holding down his button C second after the start-up, and released his button D second after the start-up.\nFor how many seconds both Alice and Bob were holding down their buttons?\n\nConstraints\n0≤A&lt;B≤100\n0≤C&lt;D≤100\nAll input values are integers.\n\nInputInput is given from Standard Input in the following format:  \nA B C D\n\nOutputPrint the length of the duration (in seconds) in which both Alice and Bob were holding down their buttons.\n\nSample Input 10 75 25 100\n\nSample Output 150\n\nAlice started holding down her button 0 second after the start-up of the robot, and released her button 75 second after the start-up.\nBob started holding down his button 25 second after the start-up, and released his button 100 second after the start-up.\nTherefore, the time when both of them were holding down their buttons, is the 50 seconds from 25 seconds after the start-up to 75 seconds after the start-up.\n\nSample Input 20 33 66 99\n\nSample Output 20\n\nAlice and Bob were not holding their buttons at the same time, so the answer is zero seconds.\n\nSample Input 310 90 20 80\n\nSample Output 360",
        "desc": "This Java problem involves determining the overlapping duration between two time intervals based on start and end times, testing concepts such as interval arithmetic and conditional logic. It is categorized as a medium difficulty level.",
        "program": "import java.util.Scanner;\nclass Main {\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint a, b, c, d;\n\t\ta = scan.nextInt();\n\t\tb = scan.nextInt();\n\t\tc = scan.nextInt();\n\t\td = scan.nextInt();\n\t\tif(a <= c && c <= b)\n\t\t\tif(b >= c)System.out.print(b-c-a);\n\t\t\telse System.out.print(d-c);\n\t\telse if(c <= a && a <= d)\n\t\t\tif(d >= a)System.out.print(d-a-c);\n\t\t\telse System.out.print(b-a);\n\t\telse System.out.print(0);\n\t}\n}",
        "error_desc": "1. Uses incorrect expressions like `b-c-a` and `d-a-c` instead of calculating `min(b, d) - max(a, c)` for overlapping duration.\n2. The nested if conditions do not accurately determine when both buttons are being held simultaneously.\n3. Subtracting `a` and `c` from other variables can result in negative values, leading to incorrect output.\n4. Fails to correctly handle all overlapping scenarios, causing incorrect duration calculations.\n5. Does not account for cases where there is no overlap, potentially producing wrong non-zero results."
    },
    {
        "problem_id": "p03680",
        "question": "Score : 200 points\n\nProblem StatementTakahashi wants to gain muscle, and decides to work out at AtCoder Gym.\nThe exercise machine at the gym has N buttons, and exactly one of the buttons is lighten up.\nThese buttons are numbered 1 through N.\nWhen Button i is lighten up and you press it, the light is turned off, and then Button a_i will be lighten up. It is possible that i=a_i.\nWhen Button i is not lighten up, nothing will happen by pressing it.\nInitially, Button 1 is lighten up. Takahashi wants to quit pressing buttons when Button 2 is lighten up.\nDetermine whether this is possible. If the answer is positive, find the minimum number of times he needs to press buttons.\n\nConstraints\n2 ≤ N ≤ 10^5\n1 ≤ a_i ≤ N\n\nInputInput is given from Standard Input in the following format:\nN\na_1\na_2\n:\na_N\n\nOutputPrint -1 if it is impossible to lighten up Button 2.\nOtherwise, print the minimum number of times we need to press buttons in order to lighten up Button 2.\n\nSample Input 13\n3\n1\n2\n\nSample Output 12\n\nPress Button 1, then Button 3.\n\nSample Input 24\n3\n4\n1\n2\n\nSample Output 2-1\n\nPressing Button 1 lightens up Button 3, and vice versa, so Button 2 will never be lighten up.\n\nSample Input 35\n3\n3\n4\n2\n4\n\nSample Output 33",
        "desc": "This problem models a deterministic system using a functional graph where each button press transitions to another button based on predefined mappings. It tests understanding of graph traversal and cycle detection algorithms to determine reachability and compute the minimum number of presses, categorizing it as a medium to hard difficulty level.",
        "program": "import java.util.Scanner;\nclass Main {\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n;\n\t\tn = scan.nextInt();\n\t\tButton b[] = new Button[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tb[i] =  new Button();\n\t\t\tb[i].next = scan.nextInt()-1; \n\t\t}\n\t\tscan.close();\n\t\tint next = 0;\n\t\tint count = 0;\n\t\twhile(true){\n\t\t\tb[next].flag = false;\n\t\t\tnext = b[next].next;\n\t\t\tcount++;\n\t\t\tif(next == 1){\n\t\t\t\tSystem.out.print(count);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!b[next].flag){\n\t\t\t\tSystem.out.print(\"-1\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\nclass Button{\n\tint next;\n\tBoolean flag = true;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03449",
        "question": "Score : 300 points\n\nProblem StatementWe have a 2 \\times N grid. We will denote the square at the i-th row and j-th column (1 \\leq i \\leq 2, 1 \\leq j \\leq N) as (i, j).\nYou are initially in the top-left square, (1, 1).\nYou will travel to the bottom-right square, (2, N), by repeatedly moving right or down.\nThe square (i, j) contains A_{i, j} candies.\nYou will collect all the candies you visit during the travel.\nThe top-left and bottom-right squares also contain candies, and you will also collect them.\nAt most how many candies can you collect when you choose the best way to travel?\n\nConstraints\n1 \\leq N \\leq 100\n1 \\leq A_{i, j} \\leq 100 (1 \\leq i \\leq 2, 1 \\leq j \\leq N)\n\nInputInput is given from Standard Input in the following format:\nN\nA_{1, 1} A_{1, 2} ... A_{1, N}\nA_{2, 1} A_{2, 2} ... A_{2, N}\n\nOutputPrint the maximum number of candies that can be collected.\n\nSample Input 15\n3 2 2 4 1\n1 2 2 2 1\n\nSample Output 114\n\nThe number of collected candies will be maximized when you:\n\nmove right three times, then move down once, then move right once.\n\nSample Input 24\n1 1 1 1\n1 1 1 1\n\nSample Output 25\n\nYou will always collect the same number of candies, regardless of how you travel.\n\nSample Input 37\n3 3 4 5 4 5 3\n5 3 4 4 2 3 2\n\nSample Output 329\n\nSample Input 41\n2\n3\n\nSample Output 45",
        "desc": "This Java problem tests understanding of dynamic programming and grid traversal algorithms, requiring the implementation of a strategy to maximize candy collection on a 2×N grid with movement constraints. It is classified as medium to hard difficulty, suitable for intermediate programmers looking to enhance their problem-solving and optimization skills.",
        "program": "import java.util.Scanner;\nclass Main {\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n;\n\t\tn = scan.nextInt();\n\t\tint x[][] = new int[2][n];\n\t\tfor(int i = 0; i < 2; i++)\n\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t\tx[i][j] = scan.nextInt();\n\t\tscan.close();\n\t\tint sum;\n\t\tint max = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsum = 0;\n\t\t\tfor(int j = 0; j <= i; j++){\n\t\t\t\tsum += x[0][j];\n\t\t\t}\n\t\t\tfor(int j = i; j < n; j++){\n\t\t\t\tsum += x[1][j];\n\t\t\t}\n\t\t\tif(sum >= max)max =sum;\n\t\t}\t\n\t\tSystem.out.print(max);\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03545",
        "question": "Score : 300 points\n\nProblem StatementSitting in a station waiting room, Joisino is gazing at her train ticket.\nThe ticket is numbered with four digits A, B, C and D in this order, each between 0 and 9 (inclusive).\nIn the formula A op1 B op2 C op3 D = 7, replace each of the symbols op1, op2 and op3 with + or - so that the formula holds.\nThe given input guarantees that there is a solution. If there are multiple solutions, any of them will be accepted.\n\nConstraints\n0≤A,B,C,D≤9\nAll input values are integers.\nIt is guaranteed that there is a solution.\n\nInputInput is given from Standard Input in the following format:\nABCD\n\nOutputPrint the formula you made, including the part =7.\nUse the signs + and -.\nDo not print a space between a digit and a sign.\n\nSample Input 11222\n\nSample Output 11+2+2+2=7\n\nThis is the only valid solution.\n\nSample Input 20290\n\nSample Output 20-2+9+0=7\n\n0 - 2 + 9 - 0 = 7 is also a valid solution.\n\nSample Input 33242\n\nSample Output 33+2+4-2=7",
        "desc": "This Java problem tests the ability to parse digit sequences and implement brute-force search by generating all possible combinations of addition and subtraction operators to satisfy a given equation. It requires understanding of iteration, string manipulation, and basic algorithmic logic, and is classified as a high-difficulty (300 points) challenge.",
        "program": "import java.util.Scanner;\nclass Main {\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tString s = scan.next();\n\t\tint n = 4;\n\t\tint x[] = new int[n];\n\t\tfor(int i = 0;i < n; i++)\n\t\t\tx[i] = s.charAt(i)-'0';\n\t\tString X[] = new String[(int) Math.pow(2,n-1)];\n\t\tint sum = 0;\n\t\tString S =\"\";\n\t\tfor(int i = 0; i < Math.pow(2,n-1); i++){\n\t\t\tsum = x[0];\n\t\t\tS = String.valueOf(x[0]);\n\t\t\tfor(int j = 0; j < n-1; j++){\n\t\t\t\tif((1 & (i>>j)) == 1){\n\t\t\t\t\tsum += x[j+1];\n\t\t\t\t\tS += \"+\" + String.valueOf(x[j+1]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tsum -= x[j+1];\n\t\t\t\t\tS += \"-\" + String.valueOf(x[j+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(sum == 7){\n\t\t\t\tSystem.out.print(S+\"=7\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p04043",
        "question": "Score : 100 points\n\nProblem StatementIroha loves Haiku. Haiku is a short form of Japanese poetry. A Haiku consists of three phrases with 5, 7 and 5 syllables, in this order.\nTo create a Haiku, Iroha has come up with three different phrases. These phrases have A, B and C syllables, respectively. Determine whether she can construct a Haiku by using each of the phrases once, in some order.\n\nConstraints\n1≦A,B,C≦10\n\nInputThe input is given from Standard Input in the following format:\nA B C\n\nOutputIf it is possible to construct a Haiku by using each of the phrases once, print YES (case-sensitive). Otherwise, print NO.\n\nSample Input 15 5 7\n\nSample Output 1YES\n\nUsing three phrases of length 5, 5 and 7, it is possible to construct a Haiku.\n\nSample Input 27 7 5\n\nSample Output 2NO",
        "desc": "The problem requires determining if three given integers can be reordered to match the syllable pattern 5-7-5 of a Haiku, testing concepts like permutations and conditional logic. It is classified as an easy-level Java programming challenge.",
        "program": "import java.util.Scanner;\nclass Main {\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint a, b, c;\n\t\ta = scan.nextInt();\n\t\tb = scan.nextInt();\n\t\tc = scan.nextInt();\n\t\tif(a == 5){\n\t\t\tif(b == 5){\n\t\t\t\tif(c == 7)System.out.print(\"YES\");\n\t\t\t\telse System.out.print(\"NO\");\n\t\t\t}\n\t\t\telse if(b == 7){\n\t\t\t\tif(c == 5)System.out.print(\"YES\");\n\t\t\t\telse System.out.print(\"NO\");\n\t\t\t}\n\t\t}\n\t\telse if(a == 7){\n\t\t\tif(b == 5){\n\t\t\t\tif(c == 5)System.out.print(\"YES\");\n\t\t\t\telse System.out.print(\"NO\");\n\t\t\t}\n\t\t\telse System.out.print(\"NO\");\n\t\t}\n\t\telse System.out.print(\"NO\");\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p04044",
        "question": "Score : 200 points\n\nProblem StatementIroha has a sequence of N strings S_1, S_2, ..., S_N. The length of each string is L.\nShe will concatenate all of the strings in some order, to produce a long string.\nAmong all strings that she can produce in this way, find the lexicographically smallest one.\nHere, a string s=s_1s_2s_3...s_n is lexicographically smaller than another string t=t_1t_2t_3...t_m if and only if one of the following holds:\n\nThere exists an index i(1≦i≦min(n,m)), such that s_j = t_j for all indices j(1≦j&lt;i), and s_i&lt;t_i.\ns_i = t_i for all integers i(1≦i≦min(n,m)), and n&lt;m.\n\nConstraints\n1 ≦ N, L ≦ 100\nFor each i, the length of S_i equals L.\nFor each i, S_i consists of lowercase letters.\n\nInputThe input is given from Standard Input in the following format:\nN L\nS_1\nS_2\n:\nS_N\n\nOutputPrint the lexicographically smallest string that Iroha can produce.\n\nSample Input 13 3\ndxx\naxx\ncxx\n\nSample Output 1axxcxxdxx\n\nThe following order should be used: axx, cxx, dxx.",
        "desc": "The problem requires arranging N fixed-length lowercase strings in an order that, when concatenated, forms the lexicographically smallest possible string, testing concepts like string comparison and custom sorting algorithms. It is classified as a medium-difficulty question suitable for intermediate Java programmers.",
        "program": "import java.util.Scanner;\nclass Main {\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n,len;\n\t\tn = scan.nextInt();\n\t\tlen = scan.nextInt();\n\t\tString s[] = new String[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ts[i] = scan.next();\n\t\t}\n\t\tint min = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = i; j < n; j++){\n\t\t\t\tif( s[j].compareTo(s[min]) < 0 )\n\t\t\t\t\tswap(min,j,s);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tSystem.out.print(s[i]);\n\t\t}\n\t}\n\tstatic void swap(int x, int y, String[] s){\n\t\tString buf;\n\t\tbuf = s[x]; s[x] = s[y]; s[y] = buf;\n\t}\n}",
        "error_desc": "1. The `min` variable is not reset inside the outer loop, causing incorrect minimum selection in each iteration.\n2. The inner loop compares `s[j]` with `s[min]` instead of `s[i]`, preventing proper sorting for each position.\n3. The sorting algorithm only sorts strings lexicographically without considering the necessary concatenation order to achieve the smallest result.\n4. The program does not implement a custom comparator to determine the correct order based on concatenated string comparisons."
    },
    {
        "problem_id": "p04030",
        "question": "Score : 200 points\n\nProblem StatementSig has built his own keyboard. Designed for ultimate simplicity, this keyboard only has 3 keys on it: the 0 key, the 1 key and the backspace key.\nTo begin with, he is using a plain text editor with this keyboard. This editor always displays one string (possibly empty). Just after the editor is launched, this string is empty. When each key on the keyboard is pressed, the following changes occur to the string:\n\nThe 0 key: a letter 0 will be inserted to the right of the string.\nThe 1 key: a letter 1 will be inserted to the right of the string.\nThe backspace key: if the string is empty, nothing happens. Otherwise, the rightmost letter of the string is deleted.\n\nSig has launched the editor, and pressed these keys several times. You are given a string s, which is a record of his keystrokes in order. In this string, the letter 0 stands for the 0 key, the letter 1 stands for the 1 key and the letter B stands for the backspace key. What string is displayed in the editor now?\n\nConstraints\n1 ≦ |s| ≦ 10 (|s| denotes the length of s)\ns consists of the letters 0, 1 and B.\nThe correct answer is not an empty string.\n\nInputThe input is given from Standard Input in the following format:\ns\n\nOutputPrint the string displayed in the editor in the end.\n\nSample Input 101B0\n\nSample Output 100\n\nEach time the key is pressed, the string in the editor will change as follows: 0, 01, 0, 00.\n\nSample Input 20BB1\n\nSample Output 21\n\nEach time the key is pressed, the string in the editor will change as follows: 0, (empty), (empty), 1.",
        "desc": "This Java problem requires simulating a text editor by processing a sequence of key presses ('0', '1', and 'B') to determine the final string displayed, testing concepts like string manipulation and stack-like operations. It is classified as an easy to introductory-level programming challenge.",
        "program": "import java.util.Scanner;\nclass Main {\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tString s = scan.next();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tswitch(s.charAt(i)){\n\t\t\tcase '0':sb.append('0');\n\t\t\tbreak;\n\t\t\tcase '1':sb.append('1');\n\t\t\tbreak;\n\t\t\tcase 'B':if(sb.length() != 0)sb.deleteCharAt(sb.length()-1);\n\t\t\t}\n\t\t}\n\t\tSystem.out.print(sb.toString());\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p04012",
        "question": "Score : 200 points\n\nProblem StatementLet w be a string consisting of lowercase letters.\nWe will call w beautiful if the following condition is satisfied:\n\nEach lowercase letter of the English alphabet occurs even number of times in w.\n\nYou are given the string w. Determine if w is beautiful.\n\nConstraints\n1 \\leq |w| \\leq 100\nw consists of lowercase letters (a-z).\n\nInputThe input is given from Standard Input in the following format:\nw\n\nOutputPrint Yes if w is beautiful. Print No otherwise.\n\nSample Input 1abaccaba\n\nSample Output 1Yes\n\na occurs four times, b occurs twice, c occurs twice and the other letters occur zero times.\n\nSample Input 2hthth\n\nSample Output 2No",
        "desc": "This Java problem asks you to determine if a given lowercase string is \"beautiful,\" meaning every letter appears an even number of times. It tests understanding of string manipulation and frequency counting techniques, such as using arrays or hash maps, and is considered to have an easy to medium difficulty level.",
        "program": "import java.util.*;\nclass Main {\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tString s = scan.next();\n\t\tHashSet<Character> hash = new HashSet<Character>();\n\t\tchar c;\n\t\tBoolean flag = true;\n\t\tif(s.length() % 2 != 0)\n\t\t\tflag = false;\n\t\telse{\n\t\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\t\tc = s.charAt(i);\n\t\t\t\tif(!hash.contains(c))hash.add(c);\n\t\t\t\telse hash.remove(c);\n\t\t\t}\n\t\t}\n\t\tif(!flag)System.out.print(\"No\");\n\t\telse if(hash.size()==0)System.out.print(\"Yes\");\n\t\telse System.out.print(\"No\");\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03371",
        "question": "Score : 300 points\n\nProblem Statement\"Pizza At\", a fast food chain, offers three kinds of pizza: \"A-pizza\", \"B-pizza\" and \"AB-pizza\". A-pizza and B-pizza are completely different pizzas, and AB-pizza is one half of A-pizza and one half of B-pizza combined together. The prices of one A-pizza, B-pizza and AB-pizza are A yen, B yen and C yen (yen is the currency of Japan), respectively.\nNakahashi needs to prepare X A-pizzas and Y B-pizzas for a party tonight. He can only obtain these pizzas by directly buying A-pizzas and B-pizzas, or buying two AB-pizzas and then rearrange them into one A-pizza and one B-pizza. At least how much money does he need for this? It is fine to have more pizzas than necessary by rearranging pizzas.\n\nConstraints\n1 ≤ A, B, C ≤ 5000\n1 ≤ X, Y ≤ 10^5\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nA B C X Y\n\nOutputPrint the minimum amount of money required to prepare X A-pizzas and Y B-pizzas.\n\nSample Input 11500 2000 1600 3 2\n\nSample Output 17900\n\nIt is optimal to buy four AB-pizzas and rearrange them into two A-pizzas and two B-pizzas, then buy additional one A-pizza.\n\nSample Input 21500 2000 1900 3 2\n\nSample Output 28500\n\nIt is optimal to directly buy three A-pizzas and two B-pizzas.\n\nSample Input 31500 2000 500 90000 100000\n\nSample Output 3100000000\n\nIt is optimal to buy 200000 AB-pizzas and rearrange them into 100000 A-pizzas and 100000 B-pizzas. We will have 10000 more A-pizzas than necessary, but that is fine.",
        "desc": "This Java problem requires determining the minimum cost to purchase a specific number of A-pizzas and B-pizzas by choosing between direct purchases and combination purchases of AB-pizzas, testing skills in algorithmic optimization and conditional decision-making. It is categorized as a high-difficulty (300 points) challenge.",
        "program": "import java.util.Scanner;\nclass Main {\n    static public void main(String args[]){\n        Scanner scan = new Scanner(System.in);\n        int Apizza = scan.nextInt();\n        int Bpizza = scan.nextInt();\n        int ABpizza = scan.nextInt();\n        int X = scan.nextInt();\n        int Y = scan.nextInt();\n        int price=(int)1e9;\n        price = Math.min(price, ABpizza * Math.max(X,Y)) * 2;\n        price = Math.min(price, ABpizza * Math.min(X,Y) * 2 + (Math.max(X,Y)==X ? Apizza : Bpizza) * Math.abs(X-Y));\n        price = Math.min(price, Apizza * X + Bpizza * Y);\n        System.out.println(price);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02801",
        "question": "Score : 100 points\n\nProblem StatementGiven is a lowercase English letter C that is not z. Print the letter that follows C in alphabetical order.\n\nConstraints\nC is a lowercase English letter that is not z.\n\nInputInput is given from Standard Input in the following format:\nC\n\nOutputPrint the letter that follows C in alphabetical order.\n\nSample Input 1a\n\nSample Output 1b\n\na is followed by b.\n\nSample Input 2y\n\nSample Output 2z\n\ny is followed by z.",
        "desc": "This Java problem tests understanding of character manipulation and ASCII value operations by requiring the programmer to identify and print the next lowercase English letter following a given input character. It is classified as an easy-level question.",
        "program": "import java.util.*;\nclass Main {\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tchar ch = scan.next().charAt(0);\n\t\tSystem.out.println(++ch);\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02802",
        "question": "Score : 300 points\n\nProblem StatementTakahashi participated in a contest on AtCoder.\nThe contest had N problems.\nTakahashi made M submissions during the contest.\nThe i-th submission was made for the p_i-th problem and received the verdict S_i (AC or WA).\nThe number of Takahashi's correct answers is the number of problems on which he received an AC once or more.\nThe number of Takahashi's penalties is the sum of the following count for the problems on which he received an AC once or more: the number of WAs received before receiving an AC for the first time on that problem.\nFind the numbers of Takahashi's correct answers and penalties.\n\nConstraints\nN, M, and p_i are integers.\n1 \\leq N \\leq 10^5\n0 \\leq M \\leq 10^5\n1 \\leq p_i \\leq N\nS_i is AC or WA.\n\nInputInput is given from Standard Input in the following format:\nN M\np_1 S_1\n:\np_M S_M\n\nOutputPrint the number of Takahashi's correct answers and the number of Takahashi's penalties.\n\nSample Input 12 5\n1 WA\n1 AC\n2 WA\n2 AC\n2 WA\n\nSample Output 12 2\n\nIn his second submission, he received an AC on the first problem for the first time. Before this, he received one WA on this problem.\nIn his fourth submission, he received an AC on the second problem for the first time. Before this, he received one WA on this problem.\nThus, he has two correct answers and two penalties.\n\nSample Input 2100000 3\n7777 AC\n7777 AC\n7777 AC\n\nSample Output 21 0\n\nNote that it is pointless to get an AC more than once on the same problem.\n\nSample Input 36 0\n\nSample Output 30 0",
        "desc": "This Java problem involves efficiently tracking multiple problem submissions using data structures (like arrays or hash maps) to count correct answers and associated penalties based on submission outcomes. It assesses understanding of data processing, state management, and optimization techniques, and is classified as a high-difficulty (300 points) challenge.",
        "program": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint m = scan.nextInt();\n\t\tint p;\n\t\tString S;\n\t\tint ac = 0;\n\t\tint wa = 0;\n\t\tint score[] = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tscore[i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tp = scan.nextInt()-1;\n\t\t\tS = scan.next();\n\t\t\tif(score[p] >= 0){\n\t\t\t\tif(S.equals(\"AC\")){\n\t\t\t\t\tac++;\n\t\t\t\t\twa += score[p];\n\t\t\t\t\tscore[p] = -1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tscore[p]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ac+\" \"+wa);\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02790",
        "question": "Score : 200 points\n\nProblem StatementGiven are 1-digit positive integers a and b. Consider these two strings: the concatenation of b copies of the digit a, and the concatenation of a copies of the digit b. Which of these is lexicographically smaller?\n\nConstraints\n1 \\leq a \\leq 9\n1 \\leq b \\leq 9\na and b are integers.\n\nInputInput is given from Standard Input in the following format:\na b\n\nOutputPrint the lexicographically smaller of the two strings. (If the two strings are equal, print one of them.)\n\nSample Input 14 3\n\nSample Output 13333\n\nWe have two strings 444 and 3333. Between them, 3333 is the lexicographically smaller.\n\nSample Input 27 7\n\nSample Output 27777777",
        "desc": "This Java problem assesses the ability to construct strings by repeating single-digit integers and compare them lexicographically. It tests knowledge of string manipulation and comparison operations, and is considered to have a medium difficulty level.",
        "program": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint a = scan.nextInt();\n\t\tint b = scan.nextInt();\n\t\tint ax = a, bx = b;\n\t\tfor(int i = 1; i < b; i++){\n\t\t\tax *= 10;\n\t\t\tax += a;\n\t\t}\n\t\tfor(int i = 1; i < a; i++){\n\t\t\tbx *= 10;\n\t\t\tbx += b;\n\t\t}\n\t\tSystem.out.println(ax >= bx ? ax : bx);\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02791",
        "question": "Score : 300 points\n\nProblem Statement\nGiven is a permutation P_1, \\ldots, P_N of 1, \\ldots, N.\nFind the number of integers i (1 \\leq i \\leq N) that satisfy the following condition:  \n\nFor any integer j (1 \\leq j \\leq i), P_i \\leq P_j.\n\nConstraints\n\n1 \\leq N \\leq 2 \\times 10^5\nP_1, \\ldots, P_N is a permutation of 1, \\ldots, N.  \nAll values in input are integers.\n\nInput\nInput is given from Standard Input in the following format:\nN\nP_1 ... P_N\n\nOutput\nPrint the number of integers i that satisfy the condition.\n\nSample Input 15\n4 2 5 1 3\n\nSample Output 13\n\ni=1, 2, and 4 satisfy the condition, but i=3 does not - for example, P_i &gt; P_j holds for j = 1.\nSimilarly, i=5 does not satisfy the condition, either. Thus, there are three integers that satisfy the condition.\n\nSample Input 24\n4 3 2 1\n\nSample Output 24\n\nAll integers i (1 \\leq i \\leq N) satisfy the condition.\n\nSample Input 36\n1 2 3 4 5 6\n\nSample Output 31\n\nOnly i=1 satisfies the condition.\n\nSample Input 48\n5 7 4 2 6 8 1 3\n\nSample Output 44\n\nSample Input 51\n1\n\nSample Output 51",
        "desc": "This Java problem assesses understanding of permutations, efficient iteration, and condition-based index counting under large input constraints, requiring optimized algorithms to handle up to 200,000 elements. It is classified as a hard-level question, suitable for testing advanced problem-solving and algorithmic skills.",
        "program": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint p[] = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tp[i] = scan.nextInt();\n\t\t}\n\t\tint ans = 0;\n\t\tint min = n + 1;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(min > p[i]){\n\t\t\t\tmin = p[i];\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\t\n\t\tSystem.out.println(ans);\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02783",
        "question": "Score : 100 points\n\nProblem StatementServal is fighting with a monster.\nThe health of the monster is H.\nIn one attack, Serval can decrease the monster's health by A.\nThere is no other way to decrease the monster's health.\nServal wins when the monster's health becomes 0 or below.\nFind the number of attacks Serval needs to make before winning.\n\nConstraints\n1 \\leq H \\leq 10^4\n1 \\leq A \\leq 10^4\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nH A\n\nOutputPrint the number of attacks Serval needs to make before winning.\n\nSample Input 110 4\n\nSample Output 13\n\nAfter one attack, the monster's health will be 6.\nAfter two attacks, the monster's health will be 2.\nAfter three attacks, the monster's health will be -2.\n\nThus, Serval needs to make three attacks to win.\n\nSample Input 21 10000\n\nSample Output 21\n\nSample Input 310000 1\n\nSample Output 310000",
        "desc": "This Java problem assesses the ability to perform integer arithmetic and implement ceiling division to determine the minimum number of attacks needed to reduce a monster's health to zero or below. It is classified as an easy-level problem, suitable for beginners practicing basic control structures and mathematical operations.",
        "program": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tdouble h = scan.nextInt();\n\t\tdouble a = scan.nextInt();\n\t\tSystem.out.println((int)Math.ceil(h/a));\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02784",
        "question": "Score : 200 points\n\nProblem StatementRaccoon is fighting with a monster.\nThe health of the monster is H.\nRaccoon can use N kinds of special moves. Using the i-th move decreases the monster's health by A_i.\nThere is no other way to decrease the monster's health.\nRaccoon wins when the monster's health becomes 0 or below.\nIf Raccoon can win without using the same move twice or more, print Yes; otherwise, print No.\n\nConstraints\n1 \\leq H \\leq 10^9\n1 \\leq N \\leq 10^5\n1 \\leq A_i \\leq 10^4\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nH N\nA_1 A_2 ... A_N\n\nOutputIf Raccoon can win without using the same move twice or more, print Yes; otherwise, print No.\n\nSample Input 110 3\n4 5 6\n\nSample Output 1Yes\n\nThe monster's health will become 0 or below after, for example, using the second and third moves.\n\nSample Input 220 3\n4 5 6\n\nSample Output 2No\n\nSample Input 3210 5\n31 41 59 26 53\n\nSample Output 3Yes\n\nSample Input 4211 5\n31 41 59 26 53\n\nSample Output 4No",
        "desc": "This Java problem tests the ability to apply greedy algorithms and efficiently handle large input sizes to determine if a subset of unique moves can reduce a monster's health to zero or below. It is classified as intermediate to hard in difficulty due to the requirement for optimized solutions within tight computational constraints.",
        "program": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint h = scan.nextInt();\n\t\tint n = scan.nextInt();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\th -= scan.nextInt(); \n\t\t}\n\t\tSystem.out.println(h <= 0 ? \"Yes\" : \"No\");\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02785",
        "question": "Score : 300 points\n\nProblem StatementFennec is fighting with N monsters.\nThe health of the i-th monster is H_i.\nFennec can do the following two actions:\n\nAttack: Fennec chooses one monster. That monster's health will decrease by 1.\nSpecial Move: Fennec chooses one monster. That monster's health will become 0.\n\nThere is no way other than Attack and Special Move to decrease the monsters' health.\nFennec wins when all the monsters' healths become 0 or below.\nFind the minimum number of times Fennec needs to do Attack (not counting Special Move) before winning when she can use Special Move at most K times.\n\nConstraints\n1 \\leq N \\leq 2 \\times 10^5\n0 \\leq K \\leq 2 \\times 10^5\n1 \\leq H_i \\leq 10^9\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nN K\nH_1 ... H_N\n\nOutputPrint the minimum number of times Fennec needs to do Attack (not counting Special Move) before winning.\n\nSample Input 13 1\n4 1 5\n\nSample Output 15\n\nBy using Special Move on the third monster, and doing Attack four times on the first monster and once on the second monster, Fennec can win with five Attacks.\n\nSample Input 28 9\n7 9 3 2 3 8 4 6\n\nSample Output 20\n\nShe can use Special Move on all the monsters.\n\nSample Input 33 0\n1000000000 1000000000 1000000000\n\nSample Output 33000000000\n\nWatch out for overflow.",
        "desc": "This Java problem assesses understanding of greedy algorithms and efficient data handling, requiring the optimization of attack and special move actions to minimize total attacks on monsters with varying health. With constraints up to 2×10⁵ elements and large health values, it is classified as a challenging (hard) level problem.",
        "program": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint k = scan.nextInt();\n\t\tlong sum = 0;\n\t\tArrayList<Long> h = new ArrayList<Long>();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\th.add(scan.nextLong()); \n\t\t}\n\t\tCollections.sort(h,Collections.reverseOrder());\n\t\tfor(int i = k; i < n; i++){\n\t\t\tsum += h.get(i);\n\t\t}\n\t\tSystem.out.println(sum);\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02786",
        "question": "Score : 400 points\n\nProblem StatementCaracal is fighting with a monster.\nThe health of the monster is H.\nCaracal can attack by choosing one monster. When a monster is attacked, depending on that monster's health, the following happens:\n\nIf the monster's health is 1, it drops to 0.\nIf the monster's health, X, is greater than 1, that monster disappears. Then, two new monsters appear, each with the health of \\lfloor X/2 \\rfloor.\n\n(\\lfloor r \\rfloor denotes the greatest integer not exceeding r.)\nCaracal wins when the healths of all existing monsters become 0 or below.\nFind the minimum number of attacks Caracal needs to make before winning.\n\nConstraints\n1 \\leq H \\leq 10^{12}\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nH\n\nOutputFind the minimum number of attacks Caracal needs to make before winning.\n\nSample Input 12\n\nSample Output 13\n\nWhen Caracal attacks the initial monster, it disappears, and two monsters appear, each with the health of 1.\nThen, Caracal can attack each of these new monsters once and win with a total of three attacks.\n\nSample Input 24\n\nSample Output 27\n\nSample Input 31000000000000\n\nSample Output 31099511627775",
        "desc": "This Java problem assesses the ability to implement recursive or divide-and-conquer strategies to determine the minimum number of attacks required to reduce a monster's health to zero, especially handling large input values efficiently. It is considered a challenging, high-difficulty level question suitable for experienced programmers.",
        "program": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tlong h = scan.nextLong();\n\t\tint ans = 0;\n\t\tlong two[] = new long[40];\n\t\ttwo[0] = 1;\n\t\tfor(int i = 1; i < 40; i++){\n\t\t\ttwo[i] = two[i-1]*2;\n\t\t}\n\t\tlong twoadd[] = new long[40];\n\t\ttwoadd[0] = 1;\n\t\tfor(int i = 1; i < 40; i++){\n\t\t\ttwoadd[i] = twoadd[i-1] + two[i];\n\t\t}\n\t\twhile((h /= 2) != 0)ans++;\n\t\tSystem.out.println(twoadd[ans]);\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02777",
        "question": "Score : 100 points\n\nProblem Statement\nWe have A balls with the string S written on each of them and B balls with the string T written on each of them.\nFrom these balls, Takahashi chooses one with the string U written on it and throws it away.\nFind the number of balls with the string S and balls with the string T that we have now.\n\nConstraints\n\nS, T, and U are strings consisting of lowercase English letters.\nThe lengths of S and T are each between 1 and 10 (inclusive).\nS \\not= T\nS=U or T=U.\n1 \\leq A,B \\leq 10\nA and B are integers.\n\nInput\nInput is given from Standard Input in the following format:\nS T\nA B\nU\n\nOutput\nPrint the answer, with space in between.\n\nSample Input 1red blue\n3 4\nred\n\nSample Output 12 4\n\nTakahashi chose a ball with red written on it and threw it away.\nNow we have two balls with the string S and four balls with the string T.\n\nSample Input 2red blue\n5 5\nblue\n\nSample Output 25 4\n\nTakahashi chose a ball with blue written on it and threw it away.\nNow we have five balls with the string S and four balls with the string T.",
        "desc": "This Java problem assesses understanding of string handling, conditional logic, and basic arithmetic operations. It is categorized as an easy-level challenge, requiring students to manipulate counts based on string comparisons and output the updated values accordingly.",
        "program": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tString s1 = scan.next();\n\t\tString s2 = scan.next();\n\t\tint n1 = scan.nextInt();\n\t\tint n2 = scan.nextInt();\n\t\tif(scan.next().equals(s1))n1--;\n\t\telse n2--;\n\t\tSystem.out.println(n1 + \" \" + n2);\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02778",
        "question": "Score : 200 points\n\nProblem Statement\nGiven is a string S. Replace every character in S with x and print the result.\n\nConstraints\n\nS is a string consisting of lowercase English letters.\nThe length of S is between 1 and 100 (inclusive).\n\nInput\nInput is given from Standard Input in the following format:\nS\n\nOutput\nReplace every character in S with x and print the result.\n\nSample Input 1sardine\n\nSample Output 1xxxxxxx\n\nReplacing every character in S with x results in xxxxxxx.\n\nSample Input 2xxxx\n\nSample Output 2xxxx\n\nSample Input 3gone\n\nSample Output 3xxxx",
        "desc": "This Java problem assesses basic string manipulation skills, specifically replacing characters within a string. It is categorized as an easy-level task, suitable for beginners learning string handling and simple iteration or built-in string methods.",
        "program": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tString s = scan.next();\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tSystem.out.print(\"x\");\n\t\t}\n\t\tSystem.out.println();\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02779",
        "question": "Score : 300 points\n\nProblem StatementGiven is a sequence of integers A_1, A_2, ..., A_N.\nIf its elements are pairwise distinct, print YES; otherwise, print NO.\n\nConstraints\n2 ≤ N ≤ 200000\n1 ≤ A_i ≤ 10^9\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nN\nA_1 ... A_N\n\nOutputIf the elements of the sequence are pairwise distinct, print YES; otherwise, print NO.\n\nSample Input 15\n2 6 1 4 5\n\nSample Output 1YES\n\nThe elements are pairwise distinct.\n\nSample Input 26\n4 1 3 1 6 2\n\nSample Output 2NO\n\nThe second and fourth elements are identical.\n\nSample Input 32\n10000000 10000000\n\nSample Output 3NO",
        "desc": "This Java problem asks the programmer to determine whether all elements in a large integer sequence are unique, testing knowledge of efficient data structures such as HashSet or sorting techniques to handle up to 200,000 elements. It is classified as medium difficulty due to the need for optimal performance with large inputs.",
        "program": "import java.util.Scanner;\nimport java.util.Set;\nimport java.util.HashSet;\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tSet<Long> set = new HashSet<Long>();\n\t\tint n = scan.nextInt();\n\t\tfor(int i = 0; i < n ; i++){\n\t\t\tset.add(scan.nextLong());\n\t\t}\n\t\tSystem.out.println( set.size() == n ? \"Yes\":\"No\");\n\t}\n}",
        "error_desc": "1. The output strings use \"Yes\" and \"No\" instead of the required all-uppercase \"YES\" and \"NO\"."
    },
    {
        "problem_id": "p02771",
        "question": "Score: 100 points\n\nProblem Statement\nA triple of numbers is said to be poor when two of those numbers are equal but the other number is different from those two numbers.\nYou will be given three integers A, B, and C. If this triple is poor, print Yes; otherwise, print No.\n\nConstraints\n\nA, B, and C are all integers between 1 and 9 (inclusive).\n\nInput\nInput is given from Standard Input in the following format:\nA B C\n\nOutput\nIf the given triple is poor, print Yes; otherwise, print No.\n\nSample Input 15 7 5\n\nSample Output 1Yes\n\nA and C are equal, but B is different from those two numbers, so this triple is poor.\n\nSample Input 24 4 4\n\nSample Output 2No\n\nA, B, and C are all equal, so this triple is not poor.\n\nSample Input 34 9 6\n\nSample Output 3No\n\nSample Input 43 3 4\n\nSample Output 4Yes",
        "desc": "This Java problem requires determining if exactly two out of three given integers are equal while the third is different, testing the programmer’s ability to use conditional statements and equality checks. It is classified as an easy-level exercise suitable for beginners.",
        "program": "import java.util.Scanner;\nimport java.util.Set;\nimport java.util.HashSet;\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tset.add(scan.nextInt());\n\t\tset.add(scan.nextInt());\n\t\tset.add(scan.nextInt());\n\t\tSystem.out.println(set.size()==2?\"Yes\":\"No\");\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02772",
        "question": "Score: 200 points\n\nProblem Statement\nYou are an immigration officer in the Kingdom of AtCoder. The document carried by an immigrant has some number of integers written on it, and you need to check whether they meet certain criteria.\nAccording to the regulation, the immigrant should be allowed entry to the kingdom if and only if the following condition is satisfied:\n\nAll even numbers written on the document are divisible by 3 or 5.\n\nIf the immigrant should be allowed entry according to the regulation, output APPROVED; otherwise, print DENIED.\n\nNotes\n\nThe condition in the statement can be rephrased as \"If x is an even number written on the document, x is divisible by 3 or 5\".\nHere \"if\" and \"or\" are logical terms.\n\nConstraints\n\nAll values in input are integers.\n1 \\leq N \\leq 100\n1 \\leq A_i \\leq 1000\n\nInput\nInput is given from Standard Input in the following format:\nN\nA_1 A_2 \\dots A_N\n\nOutput\nIf the immigrant should be allowed entry according to the regulation, print APPROVED; otherwise, print DENIED.\n\nSample Input 15\n6 7 9 10 31\n\nSample Output 1APPROVED\n\nThe even numbers written on the document are 6 and 10.\nAll of them are divisible by 3 or 5, so the immigrant should be allowed entry.\n\nSample Input 23\n28 27 24\n\nSample Output 2DENIED\n\n28 violates the condition, so the immigrant should not be allowed entry.",
        "desc": "The problem asks you to determine if all even numbers in a given list are divisible by either 3 or 5, requiring the use of array iteration, conditional statements, and logical operators in Java. It assesses understanding of basic input handling and logical logic, and is classified as a medium difficulty level.",
        "program": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint x = 0; \n\t\tboolean flag = true;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tx = scan.nextInt();\n\t\t\tif(x%2 == 0)\n\t\t\t\tif(x%3 != 0 && x%5 != 0)\n\t\t\t\t\tflag = false;\n\t\t}\n\t\tSystem.out.println(flag?\"APPROVED\":\"DENIED\");\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02773",
        "question": "Score: 300 points\n\nProblem Statement\nWe have N voting papers. The i-th vote (1 \\leq i \\leq N) has the string S_i written on it.\nPrint all strings that are written on the most number of votes, in lexicographical order.\n\nConstraints\n\n1 \\leq N \\leq 2 \\times 10^5\nS_i (1 \\leq i \\leq N) are strings consisting of lowercase English letters.\nThe length of S_i (1 \\leq i \\leq N) is between 1 and 10 (inclusive).\n\nInput\nInput is given from Standard Input in the following format:\nN\nS_1\n:\nS_N\n\nOutput\nPrint all strings in question in lexicographical order.\n\nSample Input 17\nbeat\nvet\nbeet\nbed\nvet\nbet\nbeet\n\nSample Output 1beet\nvet\n\nbeet and vet are written on two sheets each, while beat, bed, and bet are written on one vote each. Thus, we should print the strings beet and vet.\n\nSample Input 28\nbuffalo\nbuffalo\nbuffalo\nbuffalo\nbuffalo\nbuffalo\nbuffalo\nbuffalo\n\nSample Output 2buffalo\n\nSample Input 37\nbass\nbass\nkick\nkick\nbass\nkick\nkick\n\nSample Output 3kick\n\nSample Input 44\nushi\ntapu\nnichia\nkun\n\nSample Output 4kun\nnichia\ntapu\nushi",
        "desc": "This Java problem evaluates the ability to efficiently handle large datasets using data structures like hash maps for counting string occurrences and applying sorting algorithms for lexicographical ordering. It is classified as a medium to hard difficulty level, testing skills in string manipulation, frequency counting, and optimized data processing.",
        "program": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeMap;\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tString s;\n\t\tMap<String, Integer> poll = new TreeMap<String, Integer>();\n\t\tint max = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ts = scan.next();\n\t\t\tif(poll.containsKey(s)){\n\t\t\t\tpoll.put(s, poll.get(s)+1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpoll.put(s, 1);\n\t\t\t}\n\t\t}\n        for (String key : poll.keySet()) {\n        \tif(max < poll.get(key)){\n        \t\tmax = poll.get(key);\n        \t}\n\t\t}\n        Object[] mapkey = poll.keySet().toArray();\n        Arrays.sort(mapkey);\n        for (String key : poll.keySet()) {\n        \tif(poll.get(key)== max){\n    \t\t\tSystem.out.println(key);        \t\t\n        \t}\n\t\t}\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02753",
        "question": "Score : 100 points\n\nProblem StatementIn AtCoder City, there are three stations numbered 1, 2, and 3.\nEach of these stations is operated by one of the two railway companies, A and B. A string S of length 3 represents which company operates each station. If S_i is A, Company A operates Station i; if S_i is B, Company B operates Station i.\nTo improve the transportation condition, for each pair of a station operated by Company A and one operated by Company B, there will be a bus service connecting them.\nDetermine if there is a pair of stations that will be connected by a bus service.\n\nConstraints\nEach character of S is A or B.\n|S| = 3\n\nInputInput is given from Standard Input in the following format:\nS\n\nOutputIf there is a pair of stations that will be connected by a bus service, print Yes; otherwise, print No.\n\nSample Input 1ABA\n\nSample Output 1Yes\n\nCompany A operates Station 1 and 3, while Company B operates Station 2.\nThere will be a bus service between Station 1 and 2, and between Station 2 and 3, so print Yes.\n\nSample Input 2BBA\n\nSample Output 2Yes\n\nCompany B operates Station 1 and 2, while Company A operates Station 3.\nThere will be a bus service between Station 1 and 3, and between Station 2 and 3, so print Yes.\n\nSample Input 3BBB\n\nSample Output 3No\n\nCompany B operates all the stations. Thus, there will be no bus service, so print No.",
        "desc": "This Java problem evaluates proficiency in string manipulation and conditional logic by requiring the identification of pairs of railway stations operated by different companies based on a three-character input string. It is considered an easy-level task, suitable for beginners aiming to demonstrate fundamental programming skills.",
        "program": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tString s = scan.next();\n        System.out.println(s.equals(\"AAA\")||s.equals(\"BBB\")?\"No\":\"Yes\");\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02754",
        "question": "Score : 200 points\n\nProblem StatementTakahashi has many red balls and blue balls. Now, he will place them in a row.\nInitially, there is no ball placed.\nTakahashi, who is very patient, will do the following operation 10^{100} times:\n\nPlace A blue balls at the end of the row of balls already placed. Then, place B red balls at the end of the row.\n\nHow many blue balls will be there among the first N balls in the row of balls made this way?\n\nConstraints\n1 \\leq N \\leq 10^{18}\nA, B \\geq 0\n0 &lt; A + B \\leq 10^{18}\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nN A B\n\nOutputPrint the number of blue balls that will be there among the first N balls in the row of balls.\n\nSample Input 18 3 4\n\nSample Output 14\n\nLet b denote a blue ball, and r denote a red ball. The first eight balls in the row will be bbbrrrrb, among which there are four blue balls.\n\nSample Input 28 0 4\n\nSample Output 20\n\nHe placed only red balls from the beginning.\n\nSample Input 36 2 4\n\nSample Output 32\n\nAmong bbrrrr, there are two blue balls.",
        "desc": "This Java problem asks for calculating the number of blue balls among the first N positions in a sequence formed by repeatedly appending A blue balls followed by B red balls. It tests concepts such as arithmetic operations with large numbers, efficient loop calculations, and handling large input constraints, and is considered to be of medium to hard difficulty.",
        "program": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint b = scan.nextInt();\n\t\tint r = scan.nextInt();\n\t\tint count = n/(r+b);\n\t\tint rest = Math.min((n%(r+b)),b);\n        System.out.println(count * b + rest);\n\t}\n}",
        "error_desc": "1. Variables `n`, `b`, and `r` are declared as `int`, but they should be `long` to handle values up to 10¹⁸.\n2. The program uses `scan.nextInt()` to read inputs, which cannot accommodate the large input ranges specified.\n3. Calculations like `count * b` may cause integer overflow due to the use of `int` instead of `long`."
    },
    {
        "problem_id": "p02755",
        "question": "Score : 300 points\n\nProblem StatementFind the price of a product before tax such that, when the consumption tax rate is 8 percent and 10 percent, the amount of consumption tax levied on it is A yen and B yen, respectively. (Yen is the currency of Japan.)\nHere, the price before tax must be a positive integer, and the amount of consumption tax is rounded down to the nearest integer.\nIf multiple prices satisfy the condition, print the lowest such price; if no price satisfies the condition, print -1.\n\nConstraints\n1 \\leq A \\leq B \\leq 100\nA and B are integers.\n\nInputInput is given from Standard Input in the following format:\nA B\n\nOutputIf there is a price that satisfies the condition, print an integer representing the lowest such price; otherwise, print -1.\n\nSample Input 12 2\n\nSample Output 125\n\nIf the price of a product before tax is 25 yen, the amount of consumption tax levied on it is:\n\nWhen the consumption tax rate is 8 percent: \\lfloor 25 \\times 0.08 \\rfloor = \\lfloor 2 \\rfloor = 2 yen.\nWhen the consumption tax rate is 10 percent: \\lfloor 25 \\times 0.1 \\rfloor = \\lfloor 2.5 \\rfloor = 2 yen.\n\nThus, the price of 25 yen satisfies the condition. There are other possible prices, such as 26 yen, but print the minimum such price, 25.\n\nSample Input 28 10\n\nSample Output 2100\n\nIf the price of a product before tax is 100 yen, the amount of consumption tax levied on it is:\n\nWhen the consumption tax rate is 8 percent: \\lfloor 100 \\times 0.08 \\rfloor = 8 yen.\nWhen the consumption tax rate is 10 percent: \\lfloor 100 \\times 0.1 \\rfloor = 10 yen.\n\nSample Input 319 99\n\nSample Output 3-1\n\nThere is no price before tax satisfying this condition, so print -1.",
        "desc": "This Java problem assesses knowledge of integer arithmetic, the use of floor operations, and efficient search algorithms to determine a minimal valid price under given tax constraints. It is categorized as medium to hard difficulty due to the need for careful handling of rounding and iterating within specified bounds.",
        "program": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint a = scan.nextInt();\n\t\tint b = scan.nextInt();\n        System.out.println(Math.max((int)(a / 0.08),(int)(b / 0.1)));\n\t}\n}",
        "error_desc": "1. Uses `Math.max` to determine the price instead of searching for the minimum valid price that satisfies both tax conditions.\n2. Incorrectly calculates the price by dividing `a` by `0.08` and `b` by `0.1`, ignoring the requirement to handle the floor operation for tax amounts.\n3. Does not iterate through possible price values to find a price that results in the given tax amounts `A` and `B`.\n4. Fails to handle cases where no valid price exists by not outputting `-1` as specified."
    },
    {
        "problem_id": "p03455",
        "question": "Score : 100 points\n\nProblem StatementAtCoDeer the deer found two positive integers, a and b.\nDetermine whether the product of a and b is even or odd.\n\nConstraints\n1 ≤ a,b ≤ 10000\na and b are integers.\n\nInputInput is given from Standard Input in the following format:\na b\n\nOutputIf the product is odd, print Odd; if it is even, print Even.\n\nSample Input 13 4\n\nSample Output 1Even\n\nAs 3 × 4 = 12 is even, print Even.\n\nSample Input 21 21\n\nSample Output 2Odd\n\nAs 1 × 21 = 21 is odd, print Odd.",
        "desc": "This Java problem assesses understanding of arithmetic operations and the use of conditional statements or modulus operator to determine the parity of a product. It is categorized as an easy-level question, suitable for beginners learning basic programming concepts.",
        "program": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tSystem.out.println((scan.nextInt()*scan.nextInt()% 2 == 1) ? \"Odd\" : \"Even\");\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03493",
        "question": "Score : 100 points\n\nProblem StatementSnuke has a grid consisting of three squares numbered 1, 2 and 3.\nIn each square, either 0 or 1 is written. The number written in Square i is s_i.\nSnuke will place a marble on each square that says 1.\nFind the number of squares on which Snuke will place a marble.\n\nConstraints\nEach of s_1, s_2 and s_3 is either 1 or 0.\n\nInputInput is given from Standard Input in the following format:\ns_{1}s_{2}s_{3}\n\nOutputPrint the answer.\n\nSample Input 1101\n\nSample Output 12\n\nA marble will be placed on Square 1 and 3.\n\nSample Input 2000\n\nSample Output 20\n\nNo marble will be placed on any square.",
        "desc": "This problem involves reading a three-digit binary input and counting the number of digits that are `1`, testing concepts like input handling, string manipulation, and conditional counting in Java. It is considered an easy-level programming challenge.",
        "program": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tString s = scan.next();\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tsum += s.charAt(i)-'0';\n\t\t}\n\t\tSystem.out.println(sum);\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03494",
        "question": "Score : 200 points\n\nProblem StatementThere are N positive integers written on a blackboard: A_1, ..., A_N.\nSnuke can perform the following operation when all integers on the blackboard are even:\n\nReplace each integer X on the blackboard by X divided by 2.\n\nFind the maximum possible number of operations that Snuke can perform.\n\nConstraints\n1 \\leq N \\leq 200\n1 \\leq A_i \\leq 10^9\n\nInputInput is given from Standard Input in the following format:\nN\nA_1 A_2 ... A_N\n\nOutputPrint the maximum possible number of operations that Snuke can perform.\n\nSample Input 13\n8 12 40\n\nSample Output 12\n\nInitially, [8, 12, 40] are written on the blackboard.\nSince all those integers are even, Snuke can perform the operation.\nAfter the operation is performed once, [4, 6, 20] are written on the blackboard.\nSince all those integers are again even, he can perform the operation.\nAfter the operation is performed twice, [2, 3, 10] are written on the blackboard.\nNow, there is an odd number 3 on the blackboard, so he cannot perform the operation any more.\nThus, Snuke can perform the operation at most twice.\n\nSample Input 24\n5 6 8 10\n\nSample Output 20\n\nSince there is an odd number 5 on the blackboard already in the beginning, Snuke cannot perform the operation at all.\n\nSample Input 36\n382253568 723152896 37802240 379425024 404894720 471526144\n\nSample Output 38",
        "desc": "The problem assesses understanding of bit manipulation and number theory by requiring the calculation of the maximum number of times all given integers can be evenly divided by two. It is classified as a **Medium** difficulty level question.",
        "program": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint count = 0;\n\t\t\tLong x = scan.nextLong();\n\t\t\twhile((x % 2)==0){\n\t\t\t\tx /= 2;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif(count <= min)min = count;\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03448",
        "question": "Score : 200 points\n\nProblem StatementYou have A 500-yen coins, B 100-yen coins and C 50-yen coins (yen is the currency of Japan).\nIn how many ways can we select some of these coins so that they are X yen in total?\nCoins of the same kind cannot be distinguished. Two ways to select coins are distinguished when, for some kind of coin, the numbers of that coin are different.\n\nConstraints\n0 \\leq A, B, C \\leq 50\nA + B + C \\geq 1\n50 \\leq X \\leq 20 000\nA, B and C are integers.\nX is a multiple of 50.\n\nInputInput is given from Standard Input in the following format:\nA\nB\nC\nX\n\nOutputPrint the number of ways to select coins.\n\nSample Input 12\n2\n2\n100\n\nSample Output 12\n\nThere are two ways to satisfy the condition:\n\nSelect zero 500-yen coins, one 100-yen coin and zero 50-yen coins.\nSelect zero 500-yen coins, zero 100-yen coins and two 50-yen coins.\n\nSample Input 25\n1\n0\n150\n\nSample Output 20\n\nNote that the total must be exactly X yen.\n\nSample Input 330\n40\n50\n6000\n\nSample Output 3213",
        "desc": "This Java problem requires calculating the number of distinct combinations of 500, 100, and 50-yen coins that sum to a specified total, given limited quantities of each coin type. It tests understanding of combinatorial enumeration or dynamic programming with constraints and is classified as a medium-difficulty problem.",
        "program": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint a = scan.nextInt();\n\t\tint b = scan.nextInt();\n\t\tint c = scan.nextInt();\n\t\tint price = scan.nextInt();\n\t\tint count = 0;\n\t\tfor(int x = 0; x <= a; x++){\n\t\t\tfor(int y = 0; y <= b; y++){\n\t\t\t\tfor(int z = 0; z <= c; z++){\n\t\t\t\t\tif(500 * x + 100 * y + 50 * z == price)count++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03478",
        "question": "Score : 200 points\n\nProblem StatementFind the sum of the integers between 1 and N (inclusive), whose sum of digits written in base 10 is between A and B (inclusive).\n\nConstraints\n1 \\leq N \\leq 10^4\n1 \\leq A \\leq B \\leq 36\nAll input values are integers.\n\nInputInput is given from Standard Input in the following format:\nN A B\n\nOutputPrint the sum of the integers between 1 and N (inclusive), whose sum of digits written in base 10 is between A and B (inclusive).\n\nSample Input 120 2 5\n\nSample Output 184\n\nAmong the integers not greater than 20, the ones whose sums of digits are between 2 and 5, are: 2,3,4,5,11,12,13,14 and 20. We should print the sum of these, 84.\n\nSample Input 210 1 2\n\nSample Output 213\n\nSample Input 3100 4 16\n\nSample Output 34554",
        "desc": "This problem assesses the ability to iterate through a range of numbers and calculate the sum of their digits in base 10, applying conditional filters based on specified thresholds. It tests fundamental concepts in loops, digit manipulation, and conditional logic in Java, and is considered to be of medium difficulty.",
        "program": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint a = scan.nextInt();\n\t\tint b = scan.nextInt();\n\t\tint count = 0;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tint sum = 0;\n\t\t\tfor(int j = 0; j < String.valueOf(i).length(); j++){\n\t\t\t\tsum += String.valueOf(i).charAt(j)-'0';\n\t\t\t}\n\t\t\tif(a <= sum && sum <= b)count += i;\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03434",
        "question": "Score: 200 points\n\nProblem Statement\nWe have N cards. A number a_i is written on the i-th card.\nAlice and Bob will play a game using these cards. In this game, Alice and Bob alternately take one card. Alice goes first.\nThe game ends when all the cards are taken by the two players, and the score of each player is the sum of the numbers written on the cards he/she has taken. When both players take the optimal strategy to maximize their scores, find Alice's score minus Bob's score.\n\nConstraints\n\nN is an integer between 1 and 100 (inclusive).\na_i \\ (1 \\leq i \\leq N) is an integer between 1 and 100 (inclusive).\n\nInput\nInput is given from Standard Input in the following format:  \nN\na_1 a_2 a_3 ... a_N\n\nOutput\nPrint Alice's score minus Bob's score when both players take the optimal strategy to maximize their scores.\n\nSample Input 12\n3 1\n\nSample Output 12\n\nFirst, Alice will take the card with 3. Then, Bob will take the card with 1.\nThe difference of their scores will be 3 - 1 = 2.\n\nSample Input 23\n2 7 4\n\nSample Output 25\n\nFirst, Alice will take the card with 7. Then, Bob will take the card with 4. Lastly, Alice will take the card with 2. The difference of their scores will be 7 - 4 + 2 = 5. The difference of their scores will be 3 - 1 = 2.\n\nSample Input 34\n20 18 2 18\n\nSample Output 318",
        "desc": "This Java problem assesses the ability to implement dynamic programming or game theory strategies to determine the optimal score difference between two players alternately selecting cards. It tests concepts such as optimal strategy computation and state management, and is considered to be of medium to high difficulty.",
        "program": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint a = 0, b = 0;\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tlist.add(scan.nextInt());\n\t\t}\n\t\tif(n%2==1)list.add(0);\n\t\tCollections.sort(list, Collections.reverseOrder());\n\t\tfor(int i = 0; i < list.size(); i += 2){\n\t\t\ta += list.get(i);\n\t\t\tb += list.get(i+1);\n\t\t}\n\t\tSystem.out.println(a - b);\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03470",
        "question": "Score : 200 points\n\nProblem StatementAn X-layered kagami mochi (X ≥ 1) is a pile of X round mochi (rice cake) stacked vertically where each mochi (except the bottom one) has a smaller diameter than that of the mochi directly below it. For example, if you stack three mochi with diameters of 10, 8 and 6 centimeters from bottom to top in this order, you have a 3-layered kagami mochi; if you put just one mochi, you have a 1-layered kagami mochi.\nLunlun the dachshund has N round mochi, and the diameter of the i-th mochi is d_i centimeters. When we make a kagami mochi using some or all of them, at most how many layers can our kagami mochi have?\n\nConstraints\n1 ≤ N ≤ 100\n1 ≤ d_i ≤ 100\nAll input values are integers.\n\nInputInput is given from Standard Input in the following format:\nN\nd_1\n:\nd_N\n\nOutputPrint the maximum number of layers in a kagami mochi that can be made.\n\nSample Input 14\n10\n8\n8\n6\n\nSample Output 13\n\nIf we stack the mochi with diameters of 10, 8 and 6 centimeters from bottom to top in this order, we have a 3-layered kagami mochi, which is the maximum number of layers.\n\nSample Input 23\n15\n15\n15\n\nSample Output 21\n\nWhen all the mochi have the same diameter, we can only have a 1-layered kagami mochi.\n\nSample Input 37\n50\n30\n50\n100\n50\n80\n30\n\nSample Output 34",
        "desc": "This Java problem requires determining the maximum number of layers in a kagami mochi by selecting and ordering mochi with strictly decreasing diameters, effectively testing understanding of dynamic programming and longest decreasing subsequence algorithms. It is classified as a medium-difficulty question suitable for intermediate programmers.",
        "program": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tSet<Integer> hs = new HashSet<Integer>();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ths.add(scan.nextInt());\n\t\t}\n\t\tSystem.out.println(hs.size());\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02995",
        "question": "Score : 300 points\n\nProblem StatementYou are given four integers A, B, C, and D. Find the number of integers between A and B (inclusive) that can be evenly divided by neither C nor D.\n\nConstraints\n1\\leq A\\leq B\\leq 10^{18}\n1\\leq C,D\\leq 10^9\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nA B C D\n\nOutputPrint the number of integers between A and B (inclusive) that can be evenly divided by neither C nor D.\n\nSample Input 14 9 2 3\n\nSample Output 12\n\n5 and 7 satisfy the condition.\n\nSample Input 210 40 6 8\n\nSample Output 223\n\nSample Input 3314159265358979323 846264338327950288 419716939 937510582\n\nSample Output 3532105071133627368",
        "desc": "This Java problem evaluates the ability to apply the inclusion-exclusion principle and efficiently manage large numerical ranges using appropriate data types. It is considered to be of medium to high difficulty level.",
        "program": "import java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tlong a = scan.nextLong()-1;\n\t\tlong b = scan.nextLong();\n\t\tlong c = scan.nextLong();\n\t\tlong d = scan.nextLong();\n\t\tlong x = a - (a / c) - (a / d) + (a / (c * d));\n\t\tlong y = b - (b / c) - (b / d) + (b / (c * d));\n\t\tSystem.out.println(y-x);\n\t}\n}",
        "error_desc": "1. Uses `c * d` instead of the least common multiple (LCM) of `c` and `d` in the inclusion-exclusion formula.\n2. Outputs the number of integers divisible by `C` or `D` instead of those not divisible by either.\n3. Incorrectly calculates `y - x` to find the desired count instead of subtracting from the total range."
    },
    {
        "problem_id": "p02729",
        "question": "Score : 100 points\n\nProblem Statement\nWe have N+M balls, each of which has an integer written on it.\nIt is known that:  \n\nThe numbers written on N of the balls are even.\nThe numbers written on M of the balls are odd.\n\nFind the number of ways to choose two of the N+M balls (disregarding order) so that the sum of the numbers written on them is even.\nIt can be shown that this count does not depend on the actual values written on the balls.\n\nConstraints\n\n0 \\leq N,M \\leq 100\n2 \\leq N+M\nAll values in input are integers.\n\nInput\nInput is given from Standard Input in the following format:\nN M\n\nOutput\nPrint the answer.\n\nSample Input 12 1\n\nSample Output 11\n\nFor example, let us assume that the numbers written on the three balls are 1,2,4.\n\nIf we choose the two balls with 1 and 2, the sum is odd;\nIf we choose the two balls with 1 and 4, the sum is odd;\nIf we choose the two balls with 2 and 4, the sum is even.\n\nThus, the answer is 1.\n\nSample Input 24 3\n\nSample Output 29\n\nSample Input 31 1\n\nSample Output 30\n\nSample Input 413 3\n\nSample Output 481\n\nSample Input 50 3\n\nSample Output 53",
        "desc": "The problem asks for the number of unique pairs that can be formed from N even and M odd integers such that their sum is even. It tests understanding of combinatorial combinations and parity (even/odd) properties, and is considered to have an easy to medium difficulty level.",
        "program": "import java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint m = scan.nextInt();\n\t\tint x = (n*(n-1))/2;\n\t\tint y = (m*(m-1))/2;\n\t\tSystem.out.println(x+y);\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02730",
        "question": "Score : 200 points\n\nProblem StatementA string S of an odd length is said to be a strong palindrome if and only if all of the following conditions are satisfied:\n\nS is a palindrome.\nLet N be the length of S. The string formed by the 1-st through ((N-1)/2)-th characters of S is a palindrome.\nThe string consisting of the (N+3)/2-st through N-th characters of S is a palindrome.\n\nDetermine whether S is a strong palindrome.\n\nConstraints\nS consists of lowercase English letters.\nThe length of S is an odd number between 3 and 99 (inclusive).\n\nInputInput is given from Standard Input in the following format:\nS\n\nOutputIf S is a strong palindrome, print Yes;\notherwise, print No.\n\nSample Input 1akasaka\n\nSample Output 1Yes\n\nS is akasaka.\nThe string formed by the 1-st through the 3-rd characters is aka.\nThe string formed by the 5-th through the 7-th characters is aka.\nAll of these are palindromes, so S is a strong palindrome.\n\nSample Input 2level\n\nSample Output 2No\n\nSample Input 3atcoder\n\nSample Output 3No",
        "desc": "This problem requires determining if an odd-length string is a strong palindrome by verifying that the entire string and two specific substrings are palindromes, testing concepts like string manipulation and palindrome checking in Java. It is classified as a medium difficulty level.",
        "program": "import java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tString str = scan.next();\n\t\tint n = str.length();\n\t\tboolean flag = true;\n\t\tStringBuffer sb = new StringBuffer(str);\n\t\tString dst = sb.reverse().toString();\n\t\tif(!dst.equals(str))flag = false;\n\t\tint x =(n-1)/2;\n\t\tint y =(n+3)/2;\n\t\tsb = new StringBuffer(str.substring(0, x));\n\t\tdst = sb.reverse().toString();\n\t\tif(!dst.equals(str.substring(0, x)))flag = false;\n\t\tsb = new StringBuffer(str.substring(y - 1, n));\n\t\tdst = sb.reverse().toString();\n\t\tif(!dst.equals(str.substring(y - 1, n)))flag = false;\n\t\tSystem.out.println(((flag)?\"Yes\":\"No\"));\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02731",
        "question": "Score : 300 points\n\nProblem StatementGiven is a positive integer L.\nFind the maximum possible volume of a rectangular cuboid whose sum of the dimensions (not necessarily integers) is L.\n\nConstraints\n1 ≤ L ≤ 1000\nL is an integer.\n\nInputInput is given from Standard Input in the following format:\nL\n\nOutputPrint the maximum possible volume of a rectangular cuboid whose sum of the dimensions (not necessarily integers) is L.\nYour output is considered correct if its absolute or relative error from our answer is at most 10^{-6}.\n\nSample Input 13\n\nSample Output 11.000000000000\n\nFor example, a rectangular cuboid whose dimensions are 0.8, 1, and 1.2 has a volume of 0.96.\nOn the other hand, if the dimensions are 1, 1, and 1, the volume of the rectangular cuboid is 1, which is greater.\n\nSample Input 2999\n\nSample Output 236926037.000000000000",
        "desc": "This Java problem assesses understanding of optimization techniques and mathematical concepts such as the Arithmetic Mean-Geometric Mean (AM-GM) inequality to maximize the volume of a rectangular cuboid given a fixed sum of its dimensions. It is classified as a high-difficulty (300 points) problem due to the need for precise mathematical reasoning and efficient implementation to handle floating-point precision.",
        "program": "import java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tlong n = scan.nextLong();\n\t\tlong v = (long) Math.pow((n/3), 3);\n\t\tSystem.out.println(v);\n\t}\n}",
        "error_desc": "1. Uses integer division `(n/3)` instead of floating-point division, causing precision loss.\n2. Casts the result of `Math.pow` to `long`, which removes the decimal part of the volume.\n3. Outputs the volume as a long integer instead of a floating-point number with the required decimal precision."
    },
    {
        "problem_id": "p02759",
        "question": "Score : 100 points\n\nProblem StatementTakahashi wants to print a document with N pages double-sided, where two pages of data can be printed on one sheet of paper.\nAt least how many sheets of paper does he need?\n\nConstraints\nN is an integer.\n1 \\leq N \\leq 100\n\nInputInput is given from Standard Input in the following format:\nN\n\nOutputPrint the answer.\n\nSample Input 15\n\nSample Output 13\n\nBy printing the 1-st, 2-nd pages on the 1-st sheet, 3-rd and 4-th pages on the 2-nd sheet, and 5-th page on the 3-rd sheet, we can print all the data on 3 sheets of paper.\n\nSample Input 22\n\nSample Output 21\n\nSample Input 3100\n\nSample Output 350",
        "desc": "This Java problem requires determining the minimum number of double-sided sheets needed to print a document with N pages, testing concepts such as integer division and ceiling operations. It is classified as an easy-level programming challenge.",
        "program": "import java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tSystem.out.println((n+1)/2);\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02766",
        "question": "Score : 200 points\n\nProblem StatementGiven is an integer N. Find the number of digits that N has in base K.\n\nNotesFor information on base-K representation, see Positional notation - Wikipedia.\n\nConstraints\nAll values in input are integers.\n1 \\leq N \\leq 10^9\n2 \\leq K \\leq 10\n\nInputInput is given from Standard Input in the following format:\nN K\n\nOutputPrint the number of digits that N has in base K.\n\nSample Input 111 2\n\nSample Output 14\n\nIn binary, 11 is represented as 1011.\n\nSample Input 21010101 10\n\nSample Output 27\n\nSample Input 3314159265 3\n\nSample Output 318",
        "desc": "This Java problem asks for calculating the number of digits an integer \\( N \\) has when represented in base \\( K \\). It tests understanding of number base conversions and mathematical calculations related to positional notation, and is categorized as an intermediate difficulty level.",
        "program": "import java.util.*;\npublic class Main{\n    public static void main(String args[]){\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int K = sc.nextInt();\n        int result = 0;\n        while(N > 0){\n        \tN /= K;\n        \tresult++;\n        }\n        System.out.println(result);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02767",
        "question": "Score : 300 points\n\nProblem StatementThere are N people living on a number line.\nThe i-th person lives at coordinate X_i.\nYou are going to hold a meeting that all N people have to attend.\nThe meeting can be held at any integer coordinate. If you choose to hold the meeting at coordinate P, the i-th person will spend (X_i - P)^2 points of stamina to attend the meeting.\nFind the minimum total points of stamina the N people have to spend.\n\nConstraints\nAll values in input are integers.\n1 \\leq N \\leq 100\n1 \\leq X_i \\leq 100\n\nInputInput is given from Standard Input in the following format:\nN\nX_1 X_2 ... X_N\n\nOutputPrint the minimum total stamina the N people have to spend.\n\nSample Input 12\n1 4\n\nSample Output 15\n\nAssume the meeting is held at coordinate 2. In this case, the first person will spend (1 - 2)^2 points of stamina, and the second person will spend (4 - 2)^2 = 4 points of stamina, for a total of 5 points of stamina. This is the minimum total stamina that the 2 people have to spend.\nNote that you can hold the meeting only at an integer coordinate.\n\nSample Input 27\n14 14 2 13 56 2 37\n\nSample Output 22354",
        "desc": "This Java problem requires determining the optimal integer meeting point on a number line that minimizes the sum of squared distances for N people, testing concepts such as brute-force search and optimization of quadratic functions. It is categorized as medium difficulty due to the need for efficient iteration within given constraints.",
        "program": "import java.util.*;\npublic class Main{\n    public static void main(String args[]){\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int X[] = new int[N];\n        for(int i = 0; i < N; i++){\n        \tX[i] = sc.nextInt();\n        }\n        int min = Integer.MAX_VALUE;\n        for(int i = 0; i <= 100; i++){\n        \tint sum = 0;\n            for(int j = 0; j < N; j++){\n            \tsum += Math.pow((i - X[j]), 2);\n            }\n            min = Math.min(min, sum);\n        }\n        System.out.println(min);\n    }\n}",
        "error_desc": "No error."
    }
]