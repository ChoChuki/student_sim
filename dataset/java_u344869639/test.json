[
    {
        "problem_id": "p02723",
        "question": "Score : 100 points\n\nProblem StatementA string of length 6 consisting of lowercase English letters is said to be coffee-like if and only if its 3-rd and 4-th characters are equal and its 5-th and 6-th characters are also equal.\nGiven a string S, determine whether it is coffee-like.\n\nConstraints\nS is a string of length 6 consisting of lowercase English letters.\n\nInputInput is given from Standard Input in the following format:\nS\n\nOutputIf S is coffee-like, print Yes; otherwise, print No.\n\nSample Input 1sippuu\n\nSample Output 1Yes\n\nIn sippuu, the 3-rd and 4-th characters are equal, and the 5-th and 6-th characters are also equal.\n\nSample Input 2iphone\n\nSample Output 2No\n\nSample Input 3coffee\n\nSample Output 3Yes",
        "desc": "This Java problem assesses understanding of string manipulation and indexing by requiring verification of specific character positions within a fixed-length string. It is rated as an easy-level question, suitable for beginners practicing basic conditional logic and string operations.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tString s = sc.next();\n\t\tif(s.charAt(2) == s.charAt(3) && s.charAt(4) == s.charAt(5))\n\t\t\tSystem.out.println(\"Yes\");\n\t\telse\n\t\t\tSystem.out.println(\"No\");\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02724",
        "question": "Score : 200 points\n\nProblem StatementTakahashi loves gold coins. He gains 1000 happiness points for each 500-yen coin he has and gains 5 happiness points for each 5-yen coin he has. (Yen is the currency of Japan.)\nTakahashi has X yen. If he exchanges his money so that he will gain the most happiness points, how many happiness points will he earn?\n(We assume that there are six kinds of coins available: 500-yen, 100-yen, 50-yen, 10-yen, 5-yen, and 1-yen coins.)\n\nConstraints\n0 \\leq X \\leq 10^9\nX is an integer.\n\nInputInput is given from Standard Input in the following format:\nX\n\nOutputPrint the maximum number of happiness points that can be earned.\n\nSample Input 11024\n\nSample Output 12020\n\nBy exchanging his money so that he gets two 500-yen coins and four 5-yen coins, he gains 2020 happiness points, which is the maximum number of happiness points that can be earned.\n\nSample Input 20\n\nSample Output 20\n\nHe is penniless - or yenless.\n\nSample Input 31000000000\n\nSample Output 32000000000\n\nHe is a billionaire - in yen.",
        "desc": "This problem evaluates the ability to apply greedy algorithms and perform integer arithmetic (division and modulo operations) to optimize the allocation of resources for maximum benefit. It is categorized as a medium difficulty level Java programming challenge.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint result = (n/500)*1000;\n\t\tn %= 500;\n\t\tresult += (n/5)*5;\n\t\tSystem.out.println(result);\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02725",
        "question": "Score : 300 points\n\nProblem StatementThere is a circular pond with a perimeter of K meters, and N houses around them.\nThe i-th house is built at a distance of A_i meters from the northmost point of the pond, measured clockwise around the pond.\nWhen traveling between these houses, you can only go around the pond.\nFind the minimum distance that needs to be traveled when you start at one of the houses and visit all the N houses.\n\nConstraints\n2 \\leq K \\leq 10^6\n2 \\leq N \\leq 2 \\times 10^5\n0 \\leq A_1 &lt; ... &lt; A_N &lt; K\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nK N\nA_1 A_2 ... A_N\n\nOutputPrint the minimum distance that needs to be traveled when you start at one of the houses and visit all the N houses.\n\nSample Input 120 3\n5 10 15\n\nSample Output 110\n\nIf you start at the 1-st house and go to the 2-nd and 3-rd houses in this order, the total distance traveled will be 10.\n\nSample Input 220 3\n0 5 15\n\nSample Output 210\n\nIf you start at the 2-nd house and go to the 1-st and 3-rd houses in this order, the total distance traveled will be 10.",
        "desc": "This problem involves calculating the shortest path to visit all houses positioned around a circular perimeter, testing concepts such as circular distance calculations and efficient algorithm design for handling large inputs. It is classified as a medium to hard difficulty level, suitable for competitive programming and algorithmic challenges.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint K = sc.nextInt();\n\t\tint N = sc.nextInt();\n\t\tint a[] = new int[N + 1];\n\t\tfor(int i = 0; i < N; i++){\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\ta[N] = K + a[0];\n\t\tArrays.sort(a);\n\t\tint max = Integer.MIN_VALUE;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint dis = a[i + 1] - a[i];\n\t\t\tmax = Math.max(max, dis);\n\t\t}\n\t\tSystem.out.println(K - max);\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02812",
        "question": "Score : 200 points\n\nProblem StatementWe have a string S of length N consisting of uppercase English letters.\nHow many times does ABC occur in S as contiguous subsequences (see Sample Inputs and Outputs)?\n\nConstraints\n3 \\leq N \\leq 50\nS consists of uppercase English letters.\n\nInputInput is given from Standard Input in the following format:\nN\nS\n\nOutputPrint number of occurrences of ABC in S as contiguous subsequences.\n\nSample Input 110\nZABCDBABCQ\n\nSample Output 12\n\nTwo contiguous subsequences of S are equal to ABC: the 2-nd through 4-th characters, and the 7-th through 9-th characters.\n\nSample Input 219\nTHREEONEFOURONEFIVE\n\nSample Output 20\n\nNo contiguous subsequences of S are equal to ABC.\n\nSample Input 333\nABCCABCBABCCABACBCBBABCBCBCBCABCB\n\nSample Output 35",
        "desc": "This Java problem tests understanding of string manipulation and pattern recognition by requiring the counting of contiguous \"ABC\" subsequences within a given uppercase string. It is categorized as a medium difficulty level challenge.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tString s = sc.next();\n\t\tint count = 0;\n\t\tfor(int i = 0; i < N - 2; i++){\n\t\t\tif(s.substring(i, i + 3).equals(\"ABC\")){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02818",
        "question": "Score : 200 points\n\nProblem StatementTakahashi has A cookies, and Aoki has B cookies.\nTakahashi will do the following action K times:\n\nIf Takahashi has one or more cookies, eat one of his cookies.\nOtherwise, if Aoki has one or more cookies, eat one of Aoki's cookies.\nIf they both have no cookies, do nothing.\n\nIn the end, how many cookies will Takahashi and Aoki have, respectively?\n\nConstraints\n0 \\leq A \\leq 10^{12}\n0 \\leq B \\leq 10^{12}\n0 \\leq K \\leq 10^{12}\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nA B K\n\nOutputPrint the numbers of Takahashi's and Aoki's cookies after K actions.\n\nSample Input 12 3 3\n\nSample Output 10 2\n\nTakahashi will do the following:\n\nHe has two cookies, so he eats one of them.\nNow he has one cookie left, and he eats it.\nNow he has no cookies left, but Aoki has three, so Takahashi eats one of them.\n\nThus, in the end, Takahashi will have 0 cookies, and Aoki will have 2.\n\nSample Input 2500000000000 500000000000 1000000000000\n\nSample Output 20 0\n\nWatch out for overflows.",
        "desc": "This Java problem evaluates the ability to handle large integer operations and implement efficient control flow logic under high constraints. It is categorized as a medium to hard difficulty level, testing concepts such as conditional statements, loops or mathematical optimization, and careful management of potential integer overflows.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tlong A = sc.nextLong();\n\t\tlong B = sc.nextLong();\n\t\tlong K = sc.nextLong();\n\t\tSystem.out.println(Math.max(0, A - K) + \" \" + Math.min(B, B - (K - A)));\n\t}\n}",
        "error_desc": "1. Incorrectly uses `Math.min` instead of `Math.max` when calculating Aoki's remaining cookies.\n2. Allows `B - (K - A)` to become negative without ensuring it stays at zero.\n3. Fails to handle cases where `K` is greater than the total number of cookies (`A + B`), leading to negative values."
    },
    {
        "problem_id": "p02819",
        "question": "Score: 300 points\n\nProblem Statement\nFind the minimum prime number greater than or equal to X.\n\nNotes\nA prime number is an integer greater than 1 that cannot be evenly divided by any positive integer except 1 and itself.\nFor example, 2, 3, and 5 are prime numbers, while 4 and 6 are not.\n\nConstraints\n\n 2 \\le X \\le 10^5 \nAll values in input are integers.\n\nInput\nInput is given from Standard Input in the following format:\nX\n\nOutput\nPrint the minimum prime number greater than or equal to X.\n\nSample Input 120\n\nSample Output 123\n\nThe minimum prime number greater than or equal to 20 is 23.\n\nSample Input 22\n\nSample Output 22\n\nX itself can be a prime number.\n\nSample Input 399992\n\nSample Output 3100003",
        "desc": "This Java problem assesses the ability to implement prime number detection and efficient search algorithms to find the smallest prime number that is greater than or equal to a given integerâ€¯X. It tests concepts related to loops, conditionals, and optimization techniques, and is classified as a hard difficulty level.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint X = sc.nextInt();\n\t\tboolean flag = true;\n\t\twhile(flag){\n\t\t\tflag = false;\n\t\t\tfor(int i = 2; i < X; i++){\n\t\t\t\tif(X % i == 0){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)X++;\n\t\t}\n\t\tSystem.out.println(X);\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02832",
        "question": "Score : 400 points\n\nProblem StatementWe have N bricks arranged in a row from left to right.\nThe i-th brick from the left (1 \\leq i \\leq N) has an integer a_i written on it.\nAmong them, you can break at most N-1 bricks of your choice.\nLet us say there are K bricks remaining. Snuke will be satisfied if, for each integer i (1 \\leq i \\leq K), the i-th of those brick from the left has the integer i written on it.\nFind the minimum number of bricks you need to break to satisfy Snuke's desire. If his desire is unsatisfiable, print -1 instead.\n\nConstraints\nAll values in input are integers.\n1 \\leq N \\leq 200000\n1 \\leq a_i \\leq N\n\nInputInput is given from Standard Input in the following format:\nN\na_1 a_2 ... a_N\n\nOutputPrint the minimum number of bricks that need to be broken to satisfy Snuke's desire, or print -1 if his desire is unsatisfiable.\n\nSample Input 13\n2 1 2\n\nSample Output 11\n\nIf we break the leftmost brick, the remaining bricks have integers 1 and 2 written on them from left to right, in which case Snuke will be satisfied.\n\nSample Input 23\n2 2 2\n\nSample Output 2-1\n\nIn this case, there is no way to break some of the bricks to satisfy Snuke's desire.\n\nSample Input 310\n3 1 4 1 5 9 2 6 5 3\n\nSample Output 37\n\nSample Input 41\n1\n\nSample Output 40\n\nThere may be no need to break the bricks at all.",
        "desc": "This Java problem requires determining the minimum number of bricks to remove from a sequence so that the remaining bricks form a consecutive increasing sequence starting from 1. It tests understanding of efficient algorithms for subsequence optimization and handling large input sizes, classifying it as a challenging-level problem.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tint count = 0;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint x = sc.nextInt();\n\t\t\tif(x == (count + 1)){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println((count == 0)?\"-1\":N - count);\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02829",
        "question": "Score: 100 points\n\nProblem Statement\nTakahashi is solving quizzes. He has easily solved all but the last one.\nThe last quiz has three choices: 1, 2, and 3.\nWith his supernatural power, Takahashi has found out that the choices A and B are both wrong.\nPrint the correct choice for this problem.\n\nConstraints\n\nEach of the numbers A and B is 1, 2, or 3.\nA and B are different.\n\nInput\nInput is given from Standard Input in the following format:\nA\nB\n\nOutput\nPrint the correct choice.\n\nSample Input 13\n1\n\nSample Output 12\n\nWhen we know 3 and 1 are both wrong, the correct choice is 2.\n\nSample Input 21\n2\n\nSample Output 23",
        "desc": "This problem requires identifying the remaining correct choice from three options after two incorrect ones are provided, testing basic input handling and conditional logic in Java. It is classified as an easy-level programming challenge.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tSystem.out.println(6 - (sc.nextInt() + sc.nextInt()));\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02830",
        "question": "Score : 200 points\n\nProblem StatementGiven are strings s and t of length N each, both consisting of lowercase English letters.\nLet us form a new string by alternating the characters of S and the characters of T, as follows: the first character of S, the first character of T, the second character of S, the second character of T, ..., the N-th character of S, the N-th character of T. Print this new string.\n\nConstraints\n1 \\leq N \\leq 100\n|S| = |T| = N\nS and T are strings consisting of lowercase English letters.\n\nInputInput is given from Standard Input in the following format:\nN\nS T\n\nOutputPrint the string formed.\n\nSample Input 12\nip cc\n\nSample Output 1icpc\n\nSample Input 28\nhmhmnknk uuuuuuuu\n\nSample Output 2humuhumunukunuku\n\nSample Input 35\naaaaa aaaaa\n\nSample Output 3aaaaaaaaaa",
        "desc": "This Java problem tests string manipulation and iteration skills, requiring the programmer to alternate characters from two equally long lowercase strings to form a new string. It is considered to have medium difficulty due to its straightforward logic but necessitates careful handling of string indices.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tString S = sc.next();\n\t\tString T = sc.next();\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tSystem.out.print(S.charAt(i));\n\t\t\tSystem.out.print(T.charAt(i));\n\t\t}\n\t\tSystem.out.println();\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02831",
        "question": "Score : 300 points\n\nProblem Statement\nTakahashi is organizing a party.\nAt the party, each guest will receive one or more snack pieces.\nTakahashi predicts that the number of guests at this party will be A or B.\nFind the minimum number of pieces that can be evenly distributed to the guests in both of the cases predicted.\nWe assume that a piece cannot be divided and distributed to multiple guests.\n\nConstraints\n\n1 \\leq A, B \\leq 10^5\nA \\neq B\nAll values in input are integers.\n\nInput\nInput is given from Standard Input in the following format:\nA B\n\nOutput\nPrint the minimum number of pieces that can be evenly distributed to the guests in both of the cases with A guests and B guests.\n\nSample Input 12 3\n\nSample Output 16\n\nWhen we have six snack pieces, each guest can take three pieces if we have two guests, and each guest can take two if we have three guests.\n\nSample Input 2123 456\n\nSample Output 218696\n\nSample Input 3100000 99999\n\nSample Output 39999900000",
        "desc": "This Java problem requires calculating the smallest number of snack pieces that can be evenly distributed to either \\( A \\) or \\( B \\) guests, testing concepts such as least common multiple (LCM) computation and efficient integer handling. It is classified as a medium-difficulty problem.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tlong A = sc.nextInt();\n\t\tlong B = sc.nextInt();\n\t\tlong temp = Math.min(A, B);\n\t\tA = Math.max(A, B);\n\t\tB = temp;\n\t\tlong result = A * B;\n\t\tlong gcd = 1;\n\t\twhile(gcd != 0){\n\t\t\tgcd = A % B;\n\t\t\tA = B;\n\t\t\tB = gcd;\n\t\t}\n\t\tgcd = A;\n\t\tSystem.out.println(result);\n\t}\n}",
        "error_desc": "1. The program uses `sc.nextInt()` to read input into `long` variables instead of `sc.nextLong()`.\n2. It incorrectly calculates the LCM as `A * B` without dividing by the greatest common divisor.\n3. The computed `gcd` is not utilized to determine the correct minimum number of pieces.\n4. The program outputs `result`, which is the product of `A` and `B`, instead of the actual LCM."
    }
]