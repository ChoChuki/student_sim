[
    {
        "problem_id": "p03071",
        "question": "Score : 100 points\n\nProblem StatementThere are two buttons, one of size A and one of size B.\nWhen you press a button of size X, you get X coins and the size of that button decreases by 1.\nYou will press a button twice. Here, you can press the same button twice, or press both buttons once.\nAt most how many coins can you get?\n\nConstraints\nAll values in input are integers.\n3 \\leq A, B \\leq 20\n\nInputInput is given from Standard Input in the following format:\nA B\n\nOutputPrint the maximum number of coins you can get.\n\nSample Input 15 3\n\nSample Output 19\n\nYou can get 5 + 4 = 9 coins by pressing the button of size 5 twice, and this is the maximum result.\n\nSample Input 23 4\n\nSample Output 27\n\nSample Input 36 6\n\nSample Output 312",
        "desc": "This Java problem requires calculating the maximum coins obtainable by strategically pressing two buttons with diminishing sizes, testing concepts like conditional logic and simple optimization algorithms. It is classified as an easy to medium difficulty level.",
        "program": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scn = new Scanner(System.in);\n\t\tString input = scn.nextLine();\n\t\tint a = Integer.valueOf(input.split(\" \")[0]).intValue();\n\t\tint b = Integer.valueOf(input.split(\" \")[1]).intValue();\n\t\tint N = 2;\n\t\tint myCoins = 0;\n\t\tfor(int i = 0;i < N;i++) {\n\t\t\tif(a == b) {\n\t\t\t\tmyCoins += a;\n\t\t\t\ta--;\n\t\t\t}\n\t\t\telse if(a > b) {\n\t\t\t\tmyCoins += a;\n\t\t\t\ta--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmyCoins += b;\n\t\t\t\tb--;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(myCoins);\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03072",
        "question": "Score : 200 points\n\nProblem StatementThere are N mountains ranging from east to west, and an ocean to the west.\nAt the top of each mountain, there is an inn. You have decided to choose where to stay from these inns.\nThe height of the i-th mountain from the west is H_i.\nYou can certainly see the ocean from the inn at the top of the westmost mountain.\nFor the inn at the top of the i-th mountain from the west (i = 2, 3, ..., N), you can see the ocean if and only if H_1 \\leq H_i, H_2 \\leq H_i, ..., and H_{i-1} \\leq H_i.\nFrom how many of these N inns can you see the ocean?\n\nConstraints\nAll values in input are integers.\n1 \\leq N \\leq 20\n1 \\leq H_i \\leq 100\n\nInputInput is given from Standard Input in the following format:\nN\nH_1 H_2 ... H_N\n\nOutputPrint the number of inns from which you can see the ocean.\n\nSample Input 14\n6 5 6 8\n\nSample Output 13\n\nYou can see the ocean from the first, third and fourth inns from the west.\n\nSample Input 25\n4 5 3 5 4\n\nSample Output 23\n\nSample Input 35\n9 5 6 8 4\n\nSample Output 31",
        "desc": "The problem requires iterating through an array of mountain heights to count how many inns can see the ocean by ensuring each current height is at least as tall as all previous ones, testing array manipulation and comparison logic. It is considered to have an easy to medium difficulty level.",
        "program": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scn = new Scanner(System.in);\n\t\tint N = Integer.valueOf(scn.nextLine()).intValue();\n\t\tString line2[] = scn.nextLine().split(\" \");\n\t\tint H[] = new int[N];\n\t\tfor(int i = 0;i < N;i++) {\n\t\t\tH[i] = Integer.valueOf(line2[i]).intValue();\n\t\t}\n\t\tint countOceanViewHotels = 1;\n\t\tint biggestHotelsHigh = H[0];\n\t\tfor(int i = 1;i < N;i++) {\n\t\t\tif(H[i] >= biggestHotelsHigh) {\n\t\t\t\tcountOceanViewHotels++;\n\t\t\t\tbiggestHotelsHigh = H[i];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(countOceanViewHotels);\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03073",
        "question": "Score : 300 points\n\nProblem StatementN tiles are arranged in a row from left to right. The initial color of each tile is represented by a string S of length N.\nThe i-th tile from the left is painted black if the i-th character of S is 0, and painted white if that character is 1.\nYou want to repaint some of the tiles black or white, so that any two adjacent tiles have different colors.\nAt least how many tiles need to be repainted to satisfy the condition?\n\nConstraints\n1 \\leq |S| \\leq 10^5\nS_i is 0 or 1.\n\nInputInput is given from Standard Input in the following format:\nS\n\nOutputPrint the minimum number of tiles that need to be repainted to satisfy the condition.\n\nSample Input 1000\n\nSample Output 11\n\nThe condition can be satisfied by repainting the middle tile white.\n\nSample Input 210010010\n\nSample Output 23\n\nSample Input 30\n\nSample Output 30",
        "desc": "This Java problem requires determining the minimum number of tile repaints needed to arrange a sequence of tiles in an alternating black and white pattern. It tests knowledge of string manipulation and efficient algorithm design (such as greedy approaches) to handle large input sizes, and is considered to be of medium to high difficulty.",
        "program": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scn = new Scanner(System.in);\n\t\tString line = scn.nextLine();\n\t\tint length = line.length();\n\t\tString S[] = line.split(\"\");\n\t\tString answer = S[0].equals(\"0\") ? \"1\" : \"0\";\n\t\tint count = 0;\n\t\tfor(int i = 1;i < length;i++) {\n\t\t\tif(!S[i].equals(answer)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tanswer = answer.equals(\"0\") ? \"1\" : \"0\";\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02699",
        "question": "Score : 100 points\n\nProblem StatementThere are S sheep and W wolves.\nIf the number of wolves is greater than or equal to that of sheep, the wolves will attack the sheep.\nIf the wolves will attack the sheep, print unsafe; otherwise, print safe.\n\nConstraints\n1 \\leq S \\leq 100\n1 \\leq W \\leq 100\n\nInputInput is given from Standard Input in the following format:\nS W\n\nOutputIf the wolves will attack the sheep, print unsafe; otherwise, print safe.\n\nSample Input 14 5\n\nSample Output 1unsafe\n\nThere are four sheep and five wolves. The number of wolves is not less than that of sheep, so they will attack them.\n\nSample Input 2100 2\n\nSample Output 2safe\n\nMany a sheep drive away two wolves.\n\nSample Input 310 10\n\nSample Output 3unsafe",
        "desc": "This Java problem tests basic input handling, integer parsing, and the use of conditional statements to compare two values. It assesses beginner-level programming skills by requiring the determination of whether the number of wolves is greater than or equal to the number of sheep and outputting \"unsafe\" or \"safe\" accordingly.",
        "program": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint s = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tString result = w >= s ? \"unsafe\" : \"safe\";\n\t\tSystem.out.println(result);\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02700",
        "question": "Score : 200 points\n\nProblem StatementTakahashi and Aoki will have a battle using their monsters.\nThe health and strength of Takahashi's monster are A and B, respectively, and those of Aoki's monster are C and D, respectively.\nThe two monsters will take turns attacking, in the order Takahashi's, Aoki's, Takahashi's, Aoki's, ...\nHere, an attack decreases the opponent's health by the value equal to the attacker's strength.\nThe monsters keep attacking until the health of one monster becomes 0 or below. The person with the monster whose health becomes 0 or below loses, and the other person wins.\nIf Takahashi will win, print Yes; if he will lose, print No.\n\nConstraints\n1 \\leq A,B,C,D \\leq 100\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nA B C D\n\nOutputIf Takahashi will win, print Yes; if he will lose, print No.\n\nSample Input 110 9 10 10\n\nSample Output 1No\n\nFirst, Takahashi's monster attacks Aoki's monster, whose health is now 10-9=1.\nNext, Aoki's monster attacks Takahashi's monster, whose health is now 10-10=0.\nTakahashi's monster is the first to have 0 or less health, so Takahashi loses.\n\nSample Input 246 4 40 5\n\nSample Output 2Yes",
        "desc": "This problem evaluates the ability to perform arithmetic calculations and apply conditional logic to simulate a turn-based battle scenario. It tests concepts such as integer division and decision-making, and is classified as an easy-level Java programming challenge.",
        "program": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint a = sc.nextInt();\n\t\tint b = sc.nextInt();\n\t\tint c = sc.nextInt();\n\t\tint d = sc.nextInt();\n      \tString result = \"\";\n\t\tint battleCount = 0;\n      \twhile(a > 0 && c > 0){\n          battleCount += 1;\n          if(battleCount % 2 == 0){\n            a -= d;\n          }\n          else{\n            c -= b;\n          }\n        }\n\t\tresult = battleCount % 2 == 0 ? \"No\" : \"Yes\";\n\t\tSystem.out.println(result);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02701",
        "question": "Score : 300 points\n\nProblem StatementYou drew lottery N times. In the i-th draw, you got an item of the kind represented by a string S_i.\nHow many kinds of items did you get?\n\nConstraints\n1 \\leq N \\leq 2\\times 10^5\nS_i consists of lowercase English letters and has a length between 1 and 10 (inclusive).\n\nInputInput is given from Standard Input in the following format:\nN\nS_1\n:\nS_N\n\nOutputPrint the number of kinds of items you got.\n\nSample Input 13\napple\norange\napple\n\nSample Output 12\n\nYou got two kinds of items: apple and orange.\n\nSample Input 25\ngrape\ngrape\ngrape\ngrape\ngrape\n\nSample Output 21\n\nSample Input 34\naaaa\na\naaa\naa\n\nSample Output 34",
        "desc": "This Java problem requires counting the number of distinct strings from N input entries, testing knowledge of efficient data structures like hash sets or sorting algorithms to handle large datasets (up to 200,000 entries). It is classified as a medium to hard difficulty level, suitable for assessing understanding of time and space optimization in programming.",
        "program": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = Integer.parseInt(sc.nextLine());\n\t\tString[] s = new String[n];\n\t\tfor(int i = 0;i < n;i++) {\n\t\t\ts[i] = sc.nextLine();\n\t\t}\n\t\tSystem.out.println(Arrays.stream(s).distinct().count());\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03835",
        "question": "Score : 200 points\n\nProblem StatementYou are given two integers K and S.\nThree variable X, Y and Z takes integer values satisfying 0≤X,Y,Z≤K.\nHow many different assignments of values to X, Y and Z are there such that X + Y + Z = S?  \n\nConstraints\n2≤K≤2500 \n0≤S≤3K \nK and S are integers.  \n\nInputThe input is given from Standard Input in the following format:\nK S\n\nOutputPrint the number of the triples of X, Y and Z that satisfy the condition.\n\nSample Input 12 2\n\nSample Output 16\n\nThere are six triples of X, Y and Z that satisfy the condition:\n\nX = 0, Y = 0, Z = 2 \nX = 0, Y = 2, Z = 0 \nX = 2, Y = 0, Z = 0 \nX = 0, Y = 1, Z = 1 \nX = 1, Y = 0, Z = 1 \nX = 1, Y = 1, Z = 0\n\nSample Input 25 15\n\nSample Output 21\n\nThe maximum value of X + Y + Z is 15, achieved by one triple of X, Y and Z.",
        "desc": "This problem requires determining the number of non-negative integer triples (X, Y, Z) within a specified range that sum to a given value, testing combinatorial counting and efficient algorithm implementation skills. It is categorized as a medium-difficulty question suitable for competitive programming scenarios.",
        "program": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint k = sc.nextInt();\n\t\tint s = sc.nextInt();\n\t\tint count = 0;\n\t\tfor(int x = 0;x <= k;x++) {\n\t\t\tfor(int y = 0;y <= k;y++) {\n\t\t\t\tfor(int z = 0;z <= k;z++) {\n\t\t\t\t\tif(x + y + z == s) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n    }\n}",
        "error_desc": "1. The student used three nested loops, resulting in a time complexity of O(K³), which is too slow for the given constraints.\n2. The approach does not optimize the search for triples, causing the program to exceed the time limit for large values of K.\n3. The student did not implement a more efficient algorithm, such as using combinatorial mathematics, to calculate the number of valid assignments."
    },
    {
        "problem_id": "p03471",
        "question": "Score : 300 points\n\nProblem StatementThe commonly used bills in Japan are 10000-yen, 5000-yen and 1000-yen bills. Below, the word \"bill\" refers to only these.\nAccording to Aohashi, he received an otoshidama (New Year money gift) envelope from his grandfather that contained N bills for a total of Y yen, but he may be lying. Determine whether such a situation is possible, and if it is, find a possible set of bills contained in the envelope. Assume that his grandfather is rich enough, and the envelope was large enough.\n\nConstraints\n1 ≤ N ≤ 2000\n1000 ≤ Y ≤ 2 × 10^7\nN is an integer.\nY is a multiple of 1000.\n\nInputInput is given from Standard Input in the following format:\nN Y\n\nOutputIf the total value of N bills cannot be Y yen, print -1 -1 -1.\nIf the total value of N bills can be Y yen, let one such set of bills be \"x 10000-yen bills, y 5000-yen bills and z 1000-yen bills\", and print x, y, z with spaces in between. If there are multiple possibilities, any of them may be printed.\n\nSample Input 19 45000\n\nSample Output 14 0 5\n\nIf the envelope contained 4 10000-yen bills and 5 1000-yen bills, he had 9 bills and 45000 yen in total. It is also possible that the envelope contained 9 5000-yen bills, so the output 0 9 0 is also correct.\n\nSample Input 220 196000\n\nSample Output 2-1 -1 -1\n\nWhen the envelope contained 20 bills in total, the total value would be 200000 yen if all the bills were 10000-yen bills, and would be at most 195000 yen otherwise, so it would never be 196000 yen.\n\nSample Input 31000 1234000\n\nSample Output 314 27 959\n\nThere are also many other possibilities.\n\nSample Input 42000 20000000\n\nSample Output 42000 0 0",
        "desc": "This Java problem tests understanding of combinatorial logic and efficient algorithm implementation to solve integer linear equations involving specific bill denominations. It is classified as a medium to hard difficulty level due to the need for optimized searching within given constraints.",
        "program": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint y = sc.nextInt();\n\t\tint[] count = {-1, -1, -1};\n\t\tint[] amount = {10000, 5000, 1000};\n\t\tboolean isExist = false;\n\t\tfor(int i = 0;(i <= n) && (amount[0] * i <= y);i++) {\n\t\t\tfor(int j = 0;(amount[1] * j <= y) && (j <= n - i);j++) {\n\t\t\t\tint k = n - j - i;\n\t\t\t\tif(amount[0] * i + amount[1] * j + amount[2] * k == y) {\n\t\t\t\t\tcount[0] = i;\n\t\t\t\t\tcount[1] = j;\n\t\t\t\t\tcount[2] = k;\n\t\t\t\t\tisExist = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(isExist) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count[0] + \" \" + count[1] + \" \" + count[2]);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03545",
        "question": "Score : 300 points\n\nProblem StatementSitting in a station waiting room, Joisino is gazing at her train ticket.\nThe ticket is numbered with four digits A, B, C and D in this order, each between 0 and 9 (inclusive).\nIn the formula A op1 B op2 C op3 D = 7, replace each of the symbols op1, op2 and op3 with + or - so that the formula holds.\nThe given input guarantees that there is a solution. If there are multiple solutions, any of them will be accepted.\n\nConstraints\n0≤A,B,C,D≤9\nAll input values are integers.\nIt is guaranteed that there is a solution.\n\nInputInput is given from Standard Input in the following format:\nABCD\n\nOutputPrint the formula you made, including the part =7.\nUse the signs + and -.\nDo not print a space between a digit and a sign.\n\nSample Input 11222\n\nSample Output 11+2+2+2=7\n\nThis is the only valid solution.\n\nSample Input 20290\n\nSample Output 20-2+9+0=7\n\n0 - 2 + 9 - 0 = 7 is also a valid solution.\n\nSample Input 33242\n\nSample Output 33+2+4-2=7",
        "desc": "This Java problem tests the ability to parse digit sequences and implement brute-force search by generating all possible combinations of addition and subtraction operators to satisfy a given equation. It requires understanding of iteration, string manipulation, and basic algorithmic logic, and is classified as a high-difficulty (300 points) challenge.",
        "program": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tchar[] line = sc.nextLine().toCharArray();\n\t\tint n = line.length;\n\t\tint[] s = new int[n];\n\t\tfor(int i = 0;i < n;i++) s[i] = line[i] - '0';\n\t\tlong sum = s[0];\n\t\tint op = 0;\n\t\tfor(int i = 0;i < (1 << n - 1);i++) {\n\t\t\tsum = s[0];\n\t\t\top = i;\n\t\t\tfor(int j = 0;j < n - 1;j++) {\n\t\t\t\tif((i >> j & 1) != 1) {\n\t\t\t\t\tsum -= s[j + 1];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsum += s[j + 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(sum == 7) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;i++) {\n\t\t\tSystem.out.print(s[i]);\n\t\t\tif((op >> i & 1) == 1 && i != n - 1) {\n\t\t\t\tSystem.out.print(\"+\");\n\t\t\t}\n\t\t\telse if(i != n - 1){\n\t\t\t\tSystem.out.print(\"-\");\n\t\t\t}\n\t\t}\n    }\n}",
        "error_desc": "1. Incorrect operator precedence in `(1 << n - 1)`, which should be `(1 << (n - 1))`.\n2. The program does not append `=7` to the output formula.\n3. The output loop shifts `op` by `i`, causing operators to be incorrectly assigned between digits.\n4. The solution does not handle multi-digit numbers as demonstrated in the sample inputs.\n5. The variable `sum` is not correctly reset for each iteration, leading to inaccurate calculations."
    },
    {
        "problem_id": "p03455",
        "question": "Score : 100 points\n\nProblem StatementAtCoDeer the deer found two positive integers, a and b.\nDetermine whether the product of a and b is even or odd.\n\nConstraints\n1 ≤ a,b ≤ 10000\na and b are integers.\n\nInputInput is given from Standard Input in the following format:\na b\n\nOutputIf the product is odd, print Odd; if it is even, print Even.\n\nSample Input 13 4\n\nSample Output 1Even\n\nAs 3 × 4 = 12 is even, print Even.\n\nSample Input 21 21\n\nSample Output 2Odd\n\nAs 1 × 21 = 21 is odd, print Odd.",
        "desc": "This Java problem assesses understanding of arithmetic operations and the use of conditional statements or modulus operator to determine the parity of a product. It is categorized as an easy-level question, suitable for beginners learning basic programming concepts.",
        "program": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint a = sc.nextInt();\n\t\tint b = sc.nextInt();\n\t\tString ans = (a % 2 == 1) && (b % 2 == 1) ? \"Odd\" : \"Even\";\n\t\tSystem.out.println(ans);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03493",
        "question": "Score : 100 points\n\nProblem StatementSnuke has a grid consisting of three squares numbered 1, 2 and 3.\nIn each square, either 0 or 1 is written. The number written in Square i is s_i.\nSnuke will place a marble on each square that says 1.\nFind the number of squares on which Snuke will place a marble.\n\nConstraints\nEach of s_1, s_2 and s_3 is either 1 or 0.\n\nInputInput is given from Standard Input in the following format:\ns_{1}s_{2}s_{3}\n\nOutputPrint the answer.\n\nSample Input 1101\n\nSample Output 12\n\nA marble will be placed on Square 1 and 3.\n\nSample Input 2000\n\nSample Output 20\n\nNo marble will be placed on any square.",
        "desc": "This problem involves reading a three-digit binary input and counting the number of digits that are `1`, testing concepts like input handling, string manipulation, and conditional counting in Java. It is considered an easy-level programming challenge.",
        "program": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tchar[] s = sc.next().toCharArray();\n\t\tint count = 0;\n\t\tfor(int i = 0;i < 3;i++) {\n\t\t    if(s[i] - '0' == 1) count++; \n\t\t}\n\t\tSystem.out.println(count);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03494",
        "question": "Score : 200 points\n\nProblem StatementThere are N positive integers written on a blackboard: A_1, ..., A_N.\nSnuke can perform the following operation when all integers on the blackboard are even:\n\nReplace each integer X on the blackboard by X divided by 2.\n\nFind the maximum possible number of operations that Snuke can perform.\n\nConstraints\n1 \\leq N \\leq 200\n1 \\leq A_i \\leq 10^9\n\nInputInput is given from Standard Input in the following format:\nN\nA_1 A_2 ... A_N\n\nOutputPrint the maximum possible number of operations that Snuke can perform.\n\nSample Input 13\n8 12 40\n\nSample Output 12\n\nInitially, [8, 12, 40] are written on the blackboard.\nSince all those integers are even, Snuke can perform the operation.\nAfter the operation is performed once, [4, 6, 20] are written on the blackboard.\nSince all those integers are again even, he can perform the operation.\nAfter the operation is performed twice, [2, 3, 10] are written on the blackboard.\nNow, there is an odd number 3 on the blackboard, so he cannot perform the operation any more.\nThus, Snuke can perform the operation at most twice.\n\nSample Input 24\n5 6 8 10\n\nSample Output 20\n\nSince there is an odd number 5 on the blackboard already in the beginning, Snuke cannot perform the operation at all.\n\nSample Input 36\n382253568 723152896 37802240 379425024 404894720 471526144\n\nSample Output 38",
        "desc": "The problem assesses understanding of bit manipulation and number theory by requiring the calculation of the maximum number of times all given integers can be evenly divided by two. It is classified as a **Medium** difficulty level question.",
        "program": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++) a[i] = sc.nextInt();\n\t\tint count = 0;\n\t\twhile(isAllEven(a)) {\n\t\t    count++;\n\t\t    for(int i = 0;i < n;i++) a[i] /= 2;\n\t\t}\n\t\tSystem.out.println(count);\n    }\n    private static boolean isAllEven(int[] a) {\n        for(int i = 0;i < a.length;i++) {\n            if(a[i] % 2 == 1) return false;\n        }\n        return true;\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03448",
        "question": "Score : 200 points\n\nProblem StatementYou have A 500-yen coins, B 100-yen coins and C 50-yen coins (yen is the currency of Japan).\nIn how many ways can we select some of these coins so that they are X yen in total?\nCoins of the same kind cannot be distinguished. Two ways to select coins are distinguished when, for some kind of coin, the numbers of that coin are different.\n\nConstraints\n0 \\leq A, B, C \\leq 50\nA + B + C \\geq 1\n50 \\leq X \\leq 20 000\nA, B and C are integers.\nX is a multiple of 50.\n\nInputInput is given from Standard Input in the following format:\nA\nB\nC\nX\n\nOutputPrint the number of ways to select coins.\n\nSample Input 12\n2\n2\n100\n\nSample Output 12\n\nThere are two ways to satisfy the condition:\n\nSelect zero 500-yen coins, one 100-yen coin and zero 50-yen coins.\nSelect zero 500-yen coins, zero 100-yen coins and two 50-yen coins.\n\nSample Input 25\n1\n0\n150\n\nSample Output 20\n\nNote that the total must be exactly X yen.\n\nSample Input 330\n40\n50\n6000\n\nSample Output 3213",
        "desc": "This Java problem requires calculating the number of distinct combinations of 500, 100, and 50-yen coins that sum to a specified total, given limited quantities of each coin type. It tests understanding of combinatorial enumeration or dynamic programming with constraints and is classified as a medium-difficulty problem.",
        "program": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint a = sc.nextInt();\n\t\tint b = sc.nextInt();\n\t\tint c = sc.nextInt();\n\t\tint x = sc.nextInt();\n\t\tint count = 0;\n\t\tfor(int numA = 0;numA <= a;numA++) {\n\t\t    for(int numB = 0;numB <= b;numB++) {\n\t\t        int numC = (x - (500 * numA + 100 * numB)) / 50;\n\t\t        int total = 500 * numA + 100 * numB + 50 * numC;\n\t\t        if(numC >= 0 && numC <= c && total == x) count++;\n\t\t    }\n\t\t}\n\t\tSystem.out.println(count);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03478",
        "question": "Score : 200 points\n\nProblem StatementFind the sum of the integers between 1 and N (inclusive), whose sum of digits written in base 10 is between A and B (inclusive).\n\nConstraints\n1 \\leq N \\leq 10^4\n1 \\leq A \\leq B \\leq 36\nAll input values are integers.\n\nInputInput is given from Standard Input in the following format:\nN A B\n\nOutputPrint the sum of the integers between 1 and N (inclusive), whose sum of digits written in base 10 is between A and B (inclusive).\n\nSample Input 120 2 5\n\nSample Output 184\n\nAmong the integers not greater than 20, the ones whose sums of digits are between 2 and 5, are: 2,3,4,5,11,12,13,14 and 20. We should print the sum of these, 84.\n\nSample Input 210 1 2\n\nSample Output 213\n\nSample Input 3100 4 16\n\nSample Output 34554",
        "desc": "This problem assesses the ability to iterate through a range of numbers and calculate the sum of their digits in base 10, applying conditional filters based on specified thresholds. It tests fundamental concepts in loops, digit manipulation, and conditional logic in Java, and is considered to be of medium difficulty.",
        "program": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint a = sc.nextInt();\n\t\tint b = sc.nextInt();\n\t\tint numDigit = 1;\n\t\tint total = 0;\n\t\tfor(int i = 1;i <= n;i++) {\n\t\t    if(i % 10 == 0) numDigit++;\n\t\t    int sum = 0;\n\t\t    int tmp = i;\n\t\t    for(int j = numDigit;j > 0;j--) {\n\t\t        int num = (int) (tmp * Math.pow(10, -1 * (j - 1)));\n\t\t        sum += num;\n\t\t        if(sum > b) break;\n\t\t        tmp -= num * Math.pow(10, j - 1);\n\t\t    }\n\t\t    if(sum >= a && sum <= b) total += i;\n\t\t}\n\t\tSystem.out.println(total);\n    }\n}",
        "error_desc": "1. The logic for determining the number of digits using `numDigit` and incrementing it when `i % 10 == 0` is incorrect.\n2. The method for extracting each digit with `tmp * Math.pow(10, -1 * (j - 1))` does not correctly isolate individual digits.\n3. Floating-point arithmetic is used instead of integer operations, which can cause precision errors in digit sum calculations.\n4. The calculation of `sum` does not accurately compute the sum of digits due to flawed digit extraction logic.\n5. The variable `numDigit` is not properly reset for each number, leading to incorrect digit counts for numbers with varying lengths."
    },
    {
        "problem_id": "p03434",
        "question": "Score: 200 points\n\nProblem Statement\nWe have N cards. A number a_i is written on the i-th card.\nAlice and Bob will play a game using these cards. In this game, Alice and Bob alternately take one card. Alice goes first.\nThe game ends when all the cards are taken by the two players, and the score of each player is the sum of the numbers written on the cards he/she has taken. When both players take the optimal strategy to maximize their scores, find Alice's score minus Bob's score.\n\nConstraints\n\nN is an integer between 1 and 100 (inclusive).\na_i \\ (1 \\leq i \\leq N) is an integer between 1 and 100 (inclusive).\n\nInput\nInput is given from Standard Input in the following format:  \nN\na_1 a_2 a_3 ... a_N\n\nOutput\nPrint Alice's score minus Bob's score when both players take the optimal strategy to maximize their scores.\n\nSample Input 12\n3 1\n\nSample Output 12\n\nFirst, Alice will take the card with 3. Then, Bob will take the card with 1.\nThe difference of their scores will be 3 - 1 = 2.\n\nSample Input 23\n2 7 4\n\nSample Output 25\n\nFirst, Alice will take the card with 7. Then, Bob will take the card with 4. Lastly, Alice will take the card with 2. The difference of their scores will be 7 - 4 + 2 = 5. The difference of their scores will be 3 - 1 = 2.\n\nSample Input 34\n20 18 2 18\n\nSample Output 318",
        "desc": "This Java problem assesses the ability to implement dynamic programming or game theory strategies to determine the optimal score difference between two players alternately selecting cards. It tests concepts such as optimal strategy computation and state management, and is considered to be of medium to high difficulty.",
        "program": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tInteger[] a = new Integer[n];\n\t\tfor(int i = 0;i < n;i++) a[i] = sc.nextInt();\n\t\tArrays.sort(a, Collections.reverseOrder());\n\t\tint dif = 0;\n\t\tfor(int i = 0;i < a.length;i++) {\n\t\t    if(i % 2 == 0) dif += a[i];\n\t\t    else dif -= a[i];\n\t\t}\n\t\tSystem.out.println(dif);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03680",
        "question": "Score : 200 points\n\nProblem StatementTakahashi wants to gain muscle, and decides to work out at AtCoder Gym.\nThe exercise machine at the gym has N buttons, and exactly one of the buttons is lighten up.\nThese buttons are numbered 1 through N.\nWhen Button i is lighten up and you press it, the light is turned off, and then Button a_i will be lighten up. It is possible that i=a_i.\nWhen Button i is not lighten up, nothing will happen by pressing it.\nInitially, Button 1 is lighten up. Takahashi wants to quit pressing buttons when Button 2 is lighten up.\nDetermine whether this is possible. If the answer is positive, find the minimum number of times he needs to press buttons.\n\nConstraints\n2 ≤ N ≤ 10^5\n1 ≤ a_i ≤ N\n\nInputInput is given from Standard Input in the following format:\nN\na_1\na_2\n:\na_N\n\nOutputPrint -1 if it is impossible to lighten up Button 2.\nOtherwise, print the minimum number of times we need to press buttons in order to lighten up Button 2.\n\nSample Input 13\n3\n1\n2\n\nSample Output 12\n\nPress Button 1, then Button 3.\n\nSample Input 24\n3\n4\n1\n2\n\nSample Output 2-1\n\nPressing Button 1 lightens up Button 3, and vice versa, so Button 2 will never be lighten up.\n\nSample Input 35\n3\n3\n4\n2\n4\n\nSample Output 33",
        "desc": "This problem models a deterministic system using a functional graph where each button press transitions to another button based on predefined mappings. It tests understanding of graph traversal and cycle detection algorithms to determine reachability and compute the minimum number of presses, categorizing it as a medium to hard difficulty level.",
        "program": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++) a[i] = sc.nextInt();\n        boolean[] history = new boolean[n];\n        boolean success = false;\n        int i = 0;\n        int count = 0;\n        while(true) {\n            if(history[i]) break;\n            if(i == 1) {\n                success = true;\n                break;\n            }\n            history[i] = true;\n            i = a[i] - 1;\n            count++;\n        }\n        String ans = success ? String.valueOf(count) : \"-1\";\n        System.out.println(ans);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03470",
        "question": "Score : 200 points\n\nProblem StatementAn X-layered kagami mochi (X ≥ 1) is a pile of X round mochi (rice cake) stacked vertically where each mochi (except the bottom one) has a smaller diameter than that of the mochi directly below it. For example, if you stack three mochi with diameters of 10, 8 and 6 centimeters from bottom to top in this order, you have a 3-layered kagami mochi; if you put just one mochi, you have a 1-layered kagami mochi.\nLunlun the dachshund has N round mochi, and the diameter of the i-th mochi is d_i centimeters. When we make a kagami mochi using some or all of them, at most how many layers can our kagami mochi have?\n\nConstraints\n1 ≤ N ≤ 100\n1 ≤ d_i ≤ 100\nAll input values are integers.\n\nInputInput is given from Standard Input in the following format:\nN\nd_1\n:\nd_N\n\nOutputPrint the maximum number of layers in a kagami mochi that can be made.\n\nSample Input 14\n10\n8\n8\n6\n\nSample Output 13\n\nIf we stack the mochi with diameters of 10, 8 and 6 centimeters from bottom to top in this order, we have a 3-layered kagami mochi, which is the maximum number of layers.\n\nSample Input 23\n15\n15\n15\n\nSample Output 21\n\nWhen all the mochi have the same diameter, we can only have a 1-layered kagami mochi.\n\nSample Input 37\n50\n30\n50\n100\n50\n80\n30\n\nSample Output 34",
        "desc": "This Java problem requires determining the maximum number of layers in a kagami mochi by selecting and ordering mochi with strictly decreasing diameters, effectively testing understanding of dynamic programming and longest decreasing subsequence algorithms. It is classified as a medium-difficulty question suitable for intermediate programmers.",
        "program": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] d = new int[n];\n        for(int i = 0;i < n;i++) d[i] = sc.nextInt();\n        System.out.println(Arrays.stream(d).distinct().count());\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03854",
        "question": "Score : 300 points\n\nProblem StatementYou are given a string S consisting of lowercase English letters.\nAnother string T is initially empty.\nDetermine whether it is possible to obtain S = T by performing the following operation an arbitrary number of times:\n\nAppend one of the following at the end of T: dream, dreamer, erase and eraser.\n\nConstraints\n1≦|S|≦10^5\nS consists of lowercase English letters.\n\nInputThe input is given from Standard Input in the following format:\nS\n\nOutputIf it is possible to obtain S = T, print YES. Otherwise, print NO.\n\nSample Input 1erasedream\n\nSample Output 1YES\n\nAppend erase and dream at the end of T in this order, to obtain S = T.\n\nSample Input 2dreameraser\n\nSample Output 2YES\n\nAppend dream and eraser at the end of T in this order, to obtain S = T.\n\nSample Input 3dreamerer\n\nSample Output 3NO",
        "desc": "This Java problem assesses understanding of string manipulation and dynamic programming by requiring the determination of whether a given string can be constructed by sequentially appending specific substrings (\"dream\", \"dreamer\", \"erase\", \"eraser\"). It is categorized as a challenging problem (300 points) due to the need for efficient handling of large input sizes and careful pattern matching.",
        "program": "import java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        char[] s = sc.next().toCharArray();\n        char[][] candidate = {{'d', 'r', 'e', 'a', 'm', 'e', 'r'}, {'e', 'r', 'a', 's', 'e', 'r'}, {'d', 'r', 'e', 'a', 'm'}, {'e', 'r', 'a', 's', 'e'}};\n        int i = 0;\n        boolean isSuccess = false;\n        Deque<Integer> q = new ArrayDeque<>();\n        int nextK = -1;\n        while(true) {\n            for(int k = 0;k < 4;k++) {\n                int tmp = candidate[k].length;\n                if(tmp + i > s.length) continue;\n                boolean isSame = true;\n                for(int l = 0;l < tmp;l++) {\n                    if(s[l + i] != candidate[k][l]) {\n                        isSame = false;\n                        break;\n                    }\n                }\n                if(isSame) {\n                    if(i + candidate[k].length != s.length) q.offer(k);\n                    else {\n                        q.clear();\n                        i += candidate[k].length;\n                        break;\n                    }\n                }\n            }\n            if(q.isEmpty()) {\n                isSuccess = i == s.length;\n                break;\n            }\n            int oldK = nextK;\n            nextK = q.poll();\n            if(oldK == -1) i += candidate[nextK].length;\n            else i += (candidate[nextK].length - candidate[oldK].length);\n        }\n        String ans = isSuccess ? \"YES\" : \"NO\";\n        System.out.println(ans);\n    }\n}",
        "error_desc": "1. Incorrectly updates the index `i` by subtracting the length of the previous candidate, causing incorrect progression through the string.\n2. Uses a deque to manage candidate indices improperly, preventing the exploration of all valid concatenation paths.\n3. Defines candidate strings as separate character arrays instead of using string literals, complicating the matching logic.\n4. The condition `if(i + candidate[k].length != s.length)` incorrectly handles the termination of the loop, leading to wrong results."
    },
    {
        "problem_id": "p03457",
        "question": "Score : 300 points\n\nProblem StatementAtCoDeer the deer is going on a trip in a two-dimensional plane.\nIn his plan, he will depart from point (0, 0) at time 0, then for each i between 1 and N (inclusive), he will visit point (x_i,y_i) at time t_i.\nIf AtCoDeer is at point (x, y) at time t, he can be at one of the following points at time t+1: (x+1,y), (x-1,y), (x,y+1) and (x,y-1).\nNote that he cannot stay at his place.\nDetermine whether he can carry out his plan.\n\nConstraints\n1 ≤ N ≤ 10^5\n0 ≤ x_i ≤ 10^5\n0 ≤ y_i ≤ 10^5\n1 ≤ t_i ≤ 10^5\nt_i &lt; t_{i+1} (1 ≤ i ≤ N-1)\nAll input values are integers.\n\nInputInput is given from Standard Input in the following format:\nN\nt_1 x_1 y_1\nt_2 x_2 y_2\n:\nt_N x_N y_N\n\nOutputIf AtCoDeer can carry out his plan, print Yes; if he cannot, print No.\n\nSample Input 12\n3 1 2\n6 1 1\n\nSample Output 1Yes\n\nFor example, he can travel as follows: (0,0), (0,1), (1,1), (1,2), (1,1), (1,0), then (1,1).\n\nSample Input 21\n2 100 100\n\nSample Output 2No\n\nIt is impossible to be at (100,100) two seconds after being at (0,0).\n\nSample Input 32\n5 1 1\n100 1 1\n\nSample Output 3No",
        "desc": "The problem evaluates the ability to determine the feasibility of a sequence of moves on a 2D grid within specific time constraints, utilizing concepts like Manhattan distance and efficient iteration for large datasets. It is categorized as a challenging (hard) level Java programming question.",
        "program": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] t = new int[n + 1];\n        int[] x = new int[n + 1];\n        int[] y = new int[n + 1];\n        for(int i = 1;i <= n;i++) {\n            t[i] = sc.nextInt();\n            x[i] = sc.nextInt();\n            y[i] = sc.nextInt();\n        }\n        boolean isPossible = true;\n        for(int i = 1;i <= n;i++) {\n            int dt = t[i] - t[i - 1];\n            int dx = Math.abs(x[i] - x[i - 1]);\n            int dy = Math.abs(y[i] - y[i - 1]);\n            if(dx + dy > dt) {\n                isPossible = false;\n                break;\n            }\n            else if(dt % 2 == 0) {\n                if(dx + dy % 2 != 0) {\n                    isPossible = false;\n                    break;\n                }\n            }\n            else if(dt % 2 != 0) {\n                if(dx + dy % 2 == 0) {\n                    isPossible = false;\n                    break;\n                }\n            }\n        }\n        String ans = isPossible ? \"Yes\" : \"No\";\n        System.out.println(ans);\n    }\n}",
        "error_desc": "1. Missing parentheses around `(dx + dy)` cause `dx + dy % 2` to be evaluated incorrectly as `dx + (dy % 2)` instead of `(dx + dy) % 2`.\n2. Incorrect parity check due to operator precedence leads to wrong determination of whether the sum of differences matches the required time parity."
    },
    {
        "problem_id": "p02922",
        "question": "Score : 200 points\n\nProblem StatementTakahashi's house has only one socket.\nTakahashi wants to extend it with some number of power strips, each with A sockets, into B or more empty sockets.\nOne power strip with A sockets can extend one empty socket into A empty sockets.\nFind the minimum number of power strips required.\n\nConstraints\nAll values in input are integers.\n2 \\leq A \\leq 20\n1 \\leq B \\leq 20\n\nInputInput is given from Standard Input in the following format:\nA B\n\nOutputPrint the minimum number of power strips required.\n\nSample Input 14 10\n\nSample Output 13\n\n3 power strips, each with 4 sockets, extend the socket into 10 empty sockets.\n\nSample Input 28 9\n\nSample Output 22\n\n2 power strips, each with 8 sockets, extend the socket into 15 empty sockets.\n\nSample Input 38 8\n\nSample Output 31",
        "desc": "This Java problem asks for calculating the minimum number of power strips needed to achieve at least B sockets using strips that each provide A sockets, testing understanding of arithmetic operations and optimization strategies. It is considered an intermediate-level algorithmic challenge.",
        "program": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        System.out.println((int)Math.ceil((double)(b - 1) / (a - 1)));\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02693",
        "question": "Score: 100 points\n\nProblem Statement\nTakahashi the Jumbo will practice golf.\nHis objective is to get a carry distance that is a multiple of K, while he can only make a carry distance of between A and B (inclusive).\nIf he can achieve the objective, print OK; if he cannot, print NG.\n\nConstraints\n\nAll values in input are integers.\n1 \\leq A \\leq B \\leq 1000\n1 \\leq K \\leq 1000\n\nInput\nInput is given from Standard Input in the following format:\nK\nA B\n\nOutput\nIf he can achieve the objective, print OK; if he cannot, print NG.\n\nSample Input 17\n500 600\n\nSample Output 1OK\n\nAmong the multiples of 7, for example, 567 lies between 500 and 600.\n\nSample Input 24\n5 7\n\nSample Output 2NG\n\nNo multiple of 4 lies between 5 and 7.\n\nSample Input 31\n11 11\n\nSample Output 3OK",
        "desc": "This Java problem assesses the ability to use arithmetic operations or looping constructs to determine if any multiple of a given integer K exists within a specified range [A, B], involving concepts like modular arithmetic and conditional statements. It is categorized as an easy to intermediate difficulty level.",
        "program": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        boolean isPossible = false;\n        for(int i = a;i <= b;i++) {\n            if(i % n == 0) {\n                isPossible = true;\n                break;\n            }\n        }\n        String ans = isPossible ? \"OK\" : \"NG\";\n        System.out.println(ans);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02694",
        "question": "Score : 200 points\n\nProblem Statement\nTakahashi has a deposit of 100 yen (the currency of Japan) in AtCoder Bank.\nThe bank pays an annual interest rate of 1 % compounded annually. (A fraction of less than one yen is discarded.)\nAssuming that nothing other than the interest affects Takahashi's balance, in how many years does the balance reach X yen or above for the first time?\n\nConstraints\n\n 101 \\le X \\le 10^{18} \nAll values in input are integers.\n\nInput\nInput is given from Standard Input in the following format:\nX\n\nOutput\nPrint the number of years it takes for Takahashi's balance to reach X yen or above for the first time.\n\nSample Input 1103\n\nSample Output 13\n\nThe balance after one year is 101 yen.\nThe balance after two years is 102 yen.\nThe balance after three years is 103 yen.\n\nThus, it takes three years for the balance to reach 103 yen or above.\n\nSample Input 21000000000000000000\n\nSample Output 23760\n\nSample Input 31333333333\n\nSample Output 31706",
        "desc": "This problem asks you to determine how many years it takes for an initial deposit of 100 yen to reach or exceed a target amount \\( X \\) yen with a 1% annual compound interest, discarding fractional yen. It tests understanding of loops or iterative calculations, handling large integers, and compound interest concepts, and is categorized as an Easy to Medium difficulty level.",
        "program": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        long x = sc.nextLong();\n        long sum = 100;\n        long year = 0;\n        while(sum < x) {\n            year++;\n            sum *= 1.01;\n        }\n        System.out.println(year);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02687",
        "question": "Score : 100 points\n\nProblem StatementAtCoder Inc. holds a contest every Saturday.\nThere are two types of contests called ABC and ARC, and just one of them is held at a time.\nThe company holds these two types of contests alternately: an ARC follows an ABC and vice versa.\nGiven a string S representing the type of the contest held last week, print the string representing the type of the contest held this week.\n\nConstraints\nS is ABC or ARC.\n\nInputInput is given from Standard Input in the following format:\nS\n\nOutputPrint the string representing the type of the contest held this week.\n\nSample Input 1ABC\n\nSample Output 1ARC\n\nThey held an ABC last week, so they will hold an ARC this week.",
        "desc": "This Java problem assesses understanding of conditional statements and string manipulation by requiring the programmer to determine the next contest type based on the given input (\"ABC\" or \"ARC\"). It is categorized as an easy-level question, suitable for beginners to practice basic control flow and string handling.",
        "program": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.next();\n        String ans = s.equals(\"ABC\") ? \"ARC\" : \"ABC\";\n        System.out.println(ans);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02688",
        "question": "Score : 200 points\n\nProblem StatementN Snukes called Snuke 1, Snuke 2, ..., Snuke N live in a town.\nThere are K kinds of snacks sold in this town, called Snack 1, Snack 2, ..., Snack K. The following d_i Snukes have Snack i: Snuke A_{i, 1}, A_{i, 2}, \\cdots, A_{i, {d_i}}.\nTakahashi will walk around this town and make mischief on the Snukes who have no snacks. How many Snukes will fall victim to Takahashi's mischief?\n\nConstraints\nAll values in input are integers.\n1 \\leq N \\leq 100\n1 \\leq K \\leq 100\n1 \\leq d_i \\leq N\n1 \\leq A_{i, 1} &lt; \\cdots &lt; A_{i, d_i} \\leq N\n\nInputInput is given from Standard Input in the following format:\nN K\nd_1\nA_{1, 1} \\cdots A_{1, d_1}\n\\vdots\nd_K\nA_{K, 1} \\cdots A_{K, d_K}\n\nOutputPrint the answer.\n\nSample Input 13 2\n2\n1 3\n1\n3\n\nSample Output 11\n\nSnuke 1 has Snack 1.\nSnuke 2 has no snacks.\nSnuke 3 has Snack 1 and 2.\n\nThus, there will be one victim: Snuke 2.\n\nSample Input 23 3\n1\n3\n1\n3\n1\n3\n\nSample Output 22",
        "desc": "This Java problem involves determining how many of N Snukes have no associated snacks by processing K lists of snack ownership, testing skills in array handling and set operations. It is classified as an intermediate difficulty level.",
        "program": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        int[] d = new int[k];\n        boolean[] canGet = new boolean[n];\n        for(int i = 0;i < k;i++) {\n            d[i] = sc.nextInt();\n            for(int j = 0;j < d[i];j++) {\n                canGet[sc.nextInt() - 1] = true;\n            }\n        }\n        int count = 0;\n        for(int i = 0;i < canGet.length;i++) {\n            if(!canGet[i]) count++;\n        }\n        System.out.println(count);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03435",
        "question": "Score: 300 points\n\nProblem Statement\nWe have a 3 \\times 3 grid. A number c_{i, j} is written in the square (i, j), where (i, j) denotes the square at the i-th row from the top and the j-th column from the left.\nAccording to Takahashi, there are six integers a_1, a_2, a_3, b_1, b_2, b_3 whose values are fixed, and the number written in the square (i, j) is equal to a_i + b_j.\nDetermine if he is correct.  \n\nConstraints\n\nc_{i, j} \\ (1 \\leq i \\leq 3, 1 \\leq j \\leq 3) is an integer between 0 and 100 (inclusive).\n\nInput\nInput is given from Standard Input in the following format:\nc_{1,1} c_{1,2} c_{1,3}\nc_{2,1} c_{2,2} c_{2,3}\nc_{3,1} c_{3,2} c_{3,3}\n\nOutput\nIf Takahashi's statement is correct, print Yes; otherwise, print No.\n\nSample Input 11 0 1\n2 1 2\n1 0 1\n\nSample Output 1Yes\n\nTakahashi is correct, since there are possible sets of integers such as: a_1=0,a_2=1,a_3=0,b_1=1,b_2=0,b_3=1.\n\nSample Input 22 2 2\n2 1 2\n2 2 2\n\nSample Output 2No\n\nTakahashi is incorrect in this case.\n\nSample Input 30 8 8\n0 8 8\n0 8 8\n\nSample Output 3Yes\n\nSample Input 41 8 6\n2 9 7\n0 7 7\n\nSample Output 4No",
        "desc": "This Java problem asks whether a given 3×3 grid of integers can be expressed as the sum of two fixed sets of integers, one for each row and one for each column, effectively testing knowledge of matrix manipulation and system of equations. It is categorized as a high-difficulty challenge, typically suited for advanced programming contests.",
        "program": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int[][] c = new int[3][3];\n        for(int i = 0;i < 3;i++) {\n            for(int j = 0;j < 3;j++) c[i][j] = sc.nextInt();\n        }\n        boolean isOK = true;\n        isOK &= (c[0][0] - c[0][1]) == (c[1][0] - c[1][1]);\n        isOK &= (c[0][0] - c[0][1]) == (c[2][0] - c[2][1]);\n        isOK &= (c[1][0] - c[1][1]) == (c[2][0] - c[2][1]);\n        isOK &= (c[0][0] - c[0][2]) == (c[1][0] - c[1][2]);\n        isOK &= (c[0][0] - c[0][2]) == (c[2][0] - c[2][2]);\n        isOK &= (c[1][0] - c[1][2]) == (c[2][0] - c[2][2]);\n        isOK &= (c[0][1] - c[0][2]) == (c[1][1] - c[1][2]);\n        isOK &= (c[0][1] - c[0][2]) == (c[2][1] - c[2][2]);\n        isOK &= (c[1][1] - c[1][2]) == (c[2][1] - c[2][2]);\n        String ans = isOK ? \"Yes\" : \"No\";\n        System.out.println(ans);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02791",
        "question": "Score : 300 points\n\nProblem Statement\nGiven is a permutation P_1, \\ldots, P_N of 1, \\ldots, N.\nFind the number of integers i (1 \\leq i \\leq N) that satisfy the following condition:  \n\nFor any integer j (1 \\leq j \\leq i), P_i \\leq P_j.\n\nConstraints\n\n1 \\leq N \\leq 2 \\times 10^5\nP_1, \\ldots, P_N is a permutation of 1, \\ldots, N.  \nAll values in input are integers.\n\nInput\nInput is given from Standard Input in the following format:\nN\nP_1 ... P_N\n\nOutput\nPrint the number of integers i that satisfy the condition.\n\nSample Input 15\n4 2 5 1 3\n\nSample Output 13\n\ni=1, 2, and 4 satisfy the condition, but i=3 does not - for example, P_i &gt; P_j holds for j = 1.\nSimilarly, i=5 does not satisfy the condition, either. Thus, there are three integers that satisfy the condition.\n\nSample Input 24\n4 3 2 1\n\nSample Output 24\n\nAll integers i (1 \\leq i \\leq N) satisfy the condition.\n\nSample Input 36\n1 2 3 4 5 6\n\nSample Output 31\n\nOnly i=1 satisfies the condition.\n\nSample Input 48\n5 7 4 2 6 8 1 3\n\nSample Output 44\n\nSample Input 51\n1\n\nSample Output 51",
        "desc": "This Java problem assesses understanding of permutations, efficient iteration, and condition-based index counting under large input constraints, requiring optimized algorithms to handle up to 200,000 elements. It is classified as a hard-level question, suitable for testing advanced problem-solving and algorithmic skills.",
        "program": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long[] min = new long[n];\n        int count = 1;\n        min[0] = sc.nextLong();\n        for(int i = 1;i < n;i++) {\n            long p = sc.nextLong();\n            if(p <= min[i - 1]) {\n                min[i] = p;\n                count++;\n            }\n            else {\n                min[i] = min[i - 1];\n            }\n        }\n        System.out.println(count);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03160",
        "question": "Score : 100 points\n\nProblem StatementThere are N stones, numbered 1, 2, \\ldots, N.\nFor each i (1 \\leq i \\leq N), the height of Stone i is h_i.\nThere is a frog who is initially on Stone 1.\nHe will repeat the following action some number of times to reach Stone N:\n\nIf the frog is currently on Stone i, jump to Stone i + 1 or Stone i + 2. Here, a cost of |h_i - h_j| is incurred, where j is the stone to land on.\n\nFind the minimum possible total cost incurred before the frog reaches Stone N.\n\nConstraints\nAll values in input are integers.\n2 \\leq N \\leq 10^5\n1 \\leq h_i \\leq 10^4\n\nInputInput is given from Standard Input in the following format:\nN\nh_1 h_2 \\ldots h_N\n\nOutputPrint the minimum possible total cost incurred.\n\nSample Input 14\n10 30 40 20\n\nSample Output 130\n\nIf we follow the path 1 → 2 → 4, the total cost incurred would be |10 - 30| + |30 - 20| = 30.\n\nSample Input 22\n10 10\n\nSample Output 20\n\nIf we follow the path 1 → 2, the total cost incurred would be |10 - 10| = 0.\n\nSample Input 36\n30 10 60 10 60 50\n\nSample Output 340\n\nIf we follow the path 1 → 3 → 5 → 6, the total cost incurred would be |30 - 60| + |60 - 60| + |60 - 50| = 40.",
        "desc": "This Java problem assesses understanding of dynamic programming and optimization strategies to determine the minimum cost path for a frog jumping across stones with variable heights. Given the constraints (N up to 10⁵), it is classified as a medium to hard difficulty level.",
        "program": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] h = new int[n];\n        for(int i = 0;i < n;i++) h[i] = sc.nextInt();\n        long[] memo = new long[n];\n        for(int i = 0;i < n;i++) memo[i] = -1;\n        System.out.println(dp(n, h, n - 1, memo));\n    }\n    private static long dp(int n, int[] h, int i, long[] memo) {\n        if(memo[i] != -1) return memo[i];\n        else {\n            long cost1;\n            long cost2;\n            if(i == 0) {\n                cost1 = 0;\n                cost2 = 0;\n            }\n            else if(i == 1) {\n                cost1 = dp(n, h, i - 1, memo) + Math.abs(h[i] - h[i - 1]);\n                cost2 = Long.MAX_VALUE;\n            }\n            else {\n                cost1 = dp(n, h, i - 1, memo) + Math.abs(h[i] - h[i - 1]);\n                cost2 = dp(n, h, i - 2, memo) + Math.abs(h[i] - h[i - 2]);  \n            }\n            long result = Long.min(cost1, cost2);\n            memo[i] = result;\n            return result;\n        }\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03161",
        "question": "Score : 100 points\n\nProblem StatementThere are N stones, numbered 1, 2, \\ldots, N.\nFor each i (1 \\leq i \\leq N), the height of Stone i is h_i.\nThere is a frog who is initially on Stone 1.\nHe will repeat the following action some number of times to reach Stone N:\n\nIf the frog is currently on Stone i, jump to one of the following: Stone i + 1, i + 2, \\ldots, i + K. Here, a cost of |h_i - h_j| is incurred, where j is the stone to land on.\n\nFind the minimum possible total cost incurred before the frog reaches Stone N.\n\nConstraints\nAll values in input are integers.\n2 \\leq N \\leq 10^5\n1 \\leq K \\leq 100\n1 \\leq h_i \\leq 10^4\n\nInputInput is given from Standard Input in the following format:\nN K\nh_1 h_2 \\ldots h_N\n\nOutputPrint the minimum possible total cost incurred.\n\nSample Input 15 3\n10 30 40 50 20\n\nSample Output 130\n\nIf we follow the path 1 → 2 → 5, the total cost incurred would be |10 - 30| + |30 - 20| = 30.\n\nSample Input 23 1\n10 20 10\n\nSample Output 220\n\nIf we follow the path 1 → 2 → 3, the total cost incurred would be |10 - 20| + |20 - 10| = 20.\n\nSample Input 32 100\n10 10\n\nSample Output 30\n\nIf we follow the path 1 → 2, the total cost incurred would be |10 - 10| = 0.\n\nSample Input 410 4\n40 10 20 70 80 10 20 70 80 60\n\nSample Output 440\n\nIf we follow the path 1 → 4 → 8 → 10, the total cost incurred would be |40 - 70| + |70 - 70| + |70 - 60| = 40.",
        "desc": "This Java problem involves calculating the minimum total cost for a frog to jump from the first to the Nth stone, where each jump can span up to K stones and incurs a cost based on height differences. It tests concepts in dynamic programming and optimization, and is considered to have a medium to high difficulty level.",
        "program": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        int[] h = new int[n];\n        for(int i = 0;i < n;i++) h[i] = sc.nextInt();\n        long[] memo = new long[n];\n        for(int i = 0;i < n;i++) memo[i] = -1;\n        System.out.println(dp(n, k, h, n - 1, memo));\n    }\n    private static long dp(int n, int k, int[] h, int i, long[] memo) {\n        if(i == 0) return 0;\n        else if(memo[i] != -1) return memo[i];\n        else {\n            long minCost = Long.MAX_VALUE;\n            for(int j = k;j > 0;j--) {\n                int tmpIdx = i - j;\n                long tmpCost = Long.MAX_VALUE;\n                if(tmpIdx >= 0) tmpCost = dp(n, k, h, tmpIdx, memo) + Math.abs(h[i] - h[tmpIdx]);\n                if(minCost > tmpCost) minCost = tmpCost;\n            }\n            memo[i] = minCost;\n            return minCost;\n        }\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03720",
        "question": "Score : 200 points\n\nProblem StatementThere are N cities and M roads.\nThe i-th road (1≤i≤M) connects two cities a_i and b_i (1≤a_i,b_i≤N) bidirectionally.\nThere may be more than one road that connects the same pair of two cities.\nFor each city, how many roads are connected to the city?\n\nConstraints\n2≤N,M≤50\n1≤a_i,b_i≤N\na_i ≠ b_i\nAll input values are integers.\n\nInputInput is given from Standard Input in the following format:  \nN M\na_1 b_1\n:  \na_M b_M\n\nOutputPrint the answer in N lines.\nIn the i-th line (1≤i≤N), print the number of roads connected to city i.\n\nSample Input 14 3\n1 2\n2 3\n1 4\n\nSample Output 12\n2\n1\n1\n\nCity 1 is connected to the 1-st and 3-rd roads.\nCity 2 is connected to the 1-st and 2-nd roads.\nCity 3 is connected to the 2-nd road.\nCity 4 is connected to the 3-rd road.\n\nSample Input 22 5\n1 2\n2 1\n1 2\n2 1\n1 2\n\nSample Output 25\n5\n\nSample Input 38 8\n1 2\n3 4\n1 5\n2 8\n3 7\n5 2\n4 1\n6 8\n\nSample Output 33\n3\n2\n2\n2\n1\n1\n2",
        "desc": "The problem asks to determine the number of roads connected to each of N cities given M bidirectional roads, potentially with multiple connections between the same cities. It tests knowledge of graph representation, data counting, and array manipulation in Java, and is considered to be of easy to intermediate difficulty.",
        "program": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int[] count = new int[n];\n        for(int i = 0;i < m;i++) {\n            count[sc.nextInt() - 1]++;\n            count[sc.nextInt() - 1]++;\n        }\n        Arrays.stream(count).forEach(System.out::println);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02995",
        "question": "Score : 300 points\n\nProblem StatementYou are given four integers A, B, C, and D. Find the number of integers between A and B (inclusive) that can be evenly divided by neither C nor D.\n\nConstraints\n1\\leq A\\leq B\\leq 10^{18}\n1\\leq C,D\\leq 10^9\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nA B C D\n\nOutputPrint the number of integers between A and B (inclusive) that can be evenly divided by neither C nor D.\n\nSample Input 14 9 2 3\n\nSample Output 12\n\n5 and 7 satisfy the condition.\n\nSample Input 210 40 6 8\n\nSample Output 223\n\nSample Input 3314159265358979323 846264338327950288 419716939 937510582\n\nSample Output 3532105071133627368",
        "desc": "This Java problem evaluates the ability to apply the inclusion-exclusion principle and efficiently manage large numerical ranges using appropriate data types. It is considered to be of medium to high difficulty level.",
        "program": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        long a = sc.nextLong();\n        long b = sc.nextLong();\n        long c = sc.nextLong();\n        long d = sc.nextLong();\n        long countA = b / c;\n        long countB = b / d;\n        long countC = (a - 1) / c;\n        long countD = (a - 1) / d;\n        long cd = lcm(c, d);\n        long countE = b / cd;\n        long countF = (a - 1) / cd;\n        long ans = countA + countB - countC - countD - (countE - countF);\n        ans = b - a + 1 - ans;\n        System.out.println(ans);\n    }\n    private static long lcm(long m, long n) {\n        return m * n / gcd(m, n);\n    }\n    private static long gcd(long m, long n) {\n        if(m < n) {\n            long tmp = m;\n            m = n;\n            n = tmp;\n        }\n        long reminder = 0;\n        while((reminder = m % n) != 0) {\n            m = n;\n            n = reminder;\n        }\n        return n;\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02947",
        "question": "Score : 300 points\n\nProblem StatementWe will call a string obtained by arranging the characters contained in a string a in some order, an anagram of a.\nFor example, greenbin is an anagram of beginner. As seen here, when the same character occurs multiple times, that character must be used that number of times.\nGiven are N strings s_1, s_2, \\ldots, s_N. Each of these strings has a length of 10 and consists of lowercase English characters. Additionally, all of these strings are distinct. Find the number of pairs of integers i, j (1 \\leq i &lt; j \\leq N) such that s_i is an anagram of s_j.\n\nConstraints\n2 \\leq N \\leq 10^5\ns_i is a string of length 10.\nEach character in s_i is a lowercase English letter.\ns_1, s_2, \\ldots, s_N are all distinct.\n\nInputInput is given from Standard Input in the following format:\nN\ns_1\ns_2\n:\ns_N\n\nOutputPrint the number of pairs of integers i, j (1 \\leq i &lt; j \\leq N) such that s_i is an anagram of s_j.\n\nSample Input 13\nacornistnt\npeanutbomb\nconstraint\n\nSample Output 11\n\ns_1 = acornistnt is an anagram of s_3 = constraint. There are no other pairs i, j such that s_i is an anagram of s_j, so the answer is 1.\n\nSample Input 22\noneplustwo\nninemodsix\n\nSample Output 20\n\nIf there is no pair i, j such that s_i is an anagram of s_j, print 0.\n\nSample Input 35\nabaaaaaaaa\noneplustwo\naaaaaaaaba\ntwoplusone\naaaabaaaaa\n\nSample Output 34\n\nNote that the answer may not fit into a 32-bit integer type, though we cannot put such a case here.",
        "desc": "This Java problem asks you to find the number of anagrammatic pairs among N distinct 10-character lowercase strings, testing your understanding of string manipulation, hashing or sorting for anagram detection, and efficient data counting techniques suitable for large datasets. It is classified as a medium to hard difficulty level due to the need for optimized algorithms to handle up to 10⁵ strings.",
        "program": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        char[][] s = new char[n][];\n        for(int i = 0;i < n;i++) s[i] = sc.next().toCharArray();\n        long[][] charCountTable = new long[n][26];\n        for(int i = 0;i < n;i++) {\n            for(int j = 0;j < 10;j++) charCountTable[i][s[i][j] - 'a']++;\n        }\n        long result = 0;\n        boolean[] isChecked = new boolean[n];\n        for(int i = 0;i < n - 1;i++) {\n            if(isChecked[i]) continue;\n            long count = 1;\n            for(int j = i + 1;j < n;j++) {\n                if(sameXAsY(charCountTable[i], charCountTable[j])) {\n                    isChecked[j] = true;\n                    count++;\n                }\n            }\n            result += ((count) * (count - 1) / 2);\n        }\n        System.out.println(result);\n    }\n    private static boolean sameXAsY(long[] x, long[] y) {\n        boolean same = true;\n        for(int i = 0;i < x.length;i++) {\n            if(x[i] != y[i]) {\n                same = false;\n                break;\n            }\n        }\n        return same;\n    }\n}",
        "error_desc": "1. The solution uses a nested loop structure with two for-loops, resulting in O(N²) time complexity which is inefficient for N up to 10⁵.\n2. The `isChecked` array is unnecessary and adds extra overhead to the computation.\n3. The `sameXAsY` method compares all 26 character counts for each pair, further increasing the runtime.\n4. Storing character counts in a 2D array `long[n][26]` leads to high memory usage, which can contribute to the time limit being exceeded."
    },
    {
        "problem_id": "p02711",
        "question": "Score : 100 points\n\nProblem StatementGiven is a three-digit integer N. Does N contain the digit 7?\nIf so, print Yes; otherwise, print No.\n\nConstraints\n100 \\leq N \\leq 999\n\nInputInput is given from Standard Input in the following format:\nN\n\nOutputIf N contains the digit 7, print Yes; otherwise, print No.\n\nSample Input 1117\n\nSample Output 1Yes\n\n117 contains 7 as its last digit.\n\nSample Input 2123\n\nSample Output 2No\n\n123 does not contain the digit 7.\n\nSample Input 3777\n\nSample Output 3Yes",
        "desc": "This Java problem assesses the ability to manipulate and analyze individual digits of an integer using control structures. It is classified as an easy-level question, focusing on basic conditional statements and number handling.",
        "program": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        char[] n = sc.next().toCharArray();\n        String ans = \"NO\";\n        for(int i = 0;i < n.length;i++) {\n            if(n[i] == '7') ans = \"YES\";\n        }\n        System.out.println(ans);\n    }\n}",
        "error_desc": "1. The output strings use \"YES\" and \"NO\" instead of the required \"Yes\" and \"No\".\n2. The program does not enforce that the input number is a three-digit integer within the specified range.\n3. The input is read as a string, allowing for numbers beyond three digits, which violates the problem constraints."
    },
    {
        "problem_id": "p03281",
        "question": "Score: 200 points\n\nProblem Statement\nThe number 105 is quite special - it is odd but still it has eight divisors.\nNow, your task is this: how many odd numbers with exactly eight positive divisors are there between 1 and N (inclusive)?\n\nConstraints\n\nN is an integer between 1 and 200 (inclusive).\n\nInput\nInput is given from Standard Input in the following format:\nN\n\nOutput\nPrint the count.\n\nSample Input 1105\n\nSample Output 11\n\nAmong the numbers between 1 and 105, the only number that is odd and has exactly eight divisors is 105.\n\nSample Input 27\n\nSample Output 20\n\n1 has one divisor. 3, 5 and 7 are all prime and have two divisors. Thus, there is no number that satisfies the condition.",
        "desc": "This Java problem evaluates a programmer’s grasp of number theory concepts, specifically identifying odd numbers with exactly eight divisors through efficient iteration and divisor counting techniques. It is classified as a medium difficulty level due to the need for optimizing divisor calculations within the given constraints.",
        "program": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int ans = 0;\n        for(int i = 1;i <= n;i += 2) {\n            int count = 0;\n            for(int j = 1;j <= i;j++) {\n                if(i % j == 0) count++;\n            }\n            if(count == 8) ans++;\n        }\n        System.out.println(ans);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03086",
        "question": "Score : 200 points\n\nProblem StatementYou are given a string S consisting of uppercase English letters. Find the length of the longest ACGT string that is a substring (see Notes) of S.\nHere, a ACGT string is a string that contains no characters other than A, C, G and T.\n\nNotesA substring of a string T is a string obtained by removing zero or more characters from the beginning and the end of T.\nFor example, the substrings of ATCODER include TCO, AT, CODER, ATCODER and  (the empty string), but not AC.\n\nConstraints\nS is a string of length between 1 and 10 (inclusive).\nEach character in S is an uppercase English letter.\n\nInputInput is given from Standard Input in the following format:\nS\n\nOutputPrint the length of the longest ACGT string that is a substring of S.\n\nSample Input 1ATCODER\n\nSample Output 13\n\nAmong the ACGT strings that are substrings of ATCODER, the longest one is ATC.\n\nSample Input 2HATAGAYA\n\nSample Output 25\n\nAmong the ACGT strings that are substrings of HATAGAYA, the longest one is ATAGA.\n\nSample Input 3SHINJUKU\n\nSample Output 30\n\nAmong the ACGT strings that are substrings of SHINJUKU, the longest one is  (the empty string).",
        "desc": "This Java problem requires identifying the longest contiguous substring containing only the characters A, C, G, and T within a given uppercase string, testing skills in string manipulation and iteration. It is classified as a medium difficulty level question.",
        "program": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        char[] s = sc.next().toCharArray();\n        char[] atgc = {'A', 'T', 'G', 'C'};\n        int length = 0;\n        int tmpLength = 0;\n        boolean checkNow = false;\n        for(int i = 0;i < s.length;i++) {\n            boolean preCheckNow = false;\n            for(int j = 0;j < 4;j++) {\n                if(s[i] == atgc[j]) preCheckNow = true;\n            }\n            if(preCheckNow) {\n                if(checkNow) tmpLength++;\n                else {\n                    checkNow = true;\n                    tmpLength++;\n                }\n            }\n            else {\n                if(checkNow) {\n                    checkNow = false;\n                    length = length < tmpLength ? tmpLength : length;\n                    tmpLength = 0;\n                }\n            }\n            checkNow = preCheckNow;\n        }\n        if(checkNow) length = length < tmpLength ? tmpLength : length;\n        System.out.println(length);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03282",
        "question": "﻿Score: 300 points\n\nProblem Statement\nMr. Infinity has a string S consisting of digits from 1 to 9. Each time the date changes, this string changes as follows:\n\nEach occurrence of 2 in S is replaced with 22. Similarly, each 3 becomes 333, 4 becomes 4444, 5 becomes 55555, 6 becomes 666666, 7 becomes 7777777, 8 becomes 88888888 and 9 becomes 999999999. 1 remains as 1.\n\nFor example, if S is 1324, it becomes 1333224444 the next day, and it becomes 133333333322224444444444444444 the day after next.\nYou are interested in what the string looks like after 5 \\times 10^{15} days. What is the K-th character from the left in the string after 5 \\times 10^{15} days?\n\nConstraints\n\nS is a string of length between 1 and 100 (inclusive).\nK is an integer between 1 and 10^{18} (inclusive).\nThe length of the string after 5 \\times 10^{15} days is at least K.\n\nInput\nInput is given from Standard Input in the following format:\nS\nK\n\nOutput\nPrint the K-th character from the left in Mr. Infinity's string after 5 \\times 10^{15} days.\n\nSample Input 11214\n4\n\nSample Output 12\n\nThe string S changes as follows:  \n\nNow: 1214\nAfter one day: 12214444\nAfter two days: 1222214444444444444444\nAfter three days: 12222222214444444444444444444444444444444444444444444444444444444444444444\n\nThe first five characters in the string after 5 \\times 10^{15} days is 12222. As K=4, we should print the fourth character, 2.\n\nSample Input 23\n157\n\nSample Output 23\n\nThe initial string is 3. The string after 5 \\times 10^{15} days consists only of 3.\n\nSample Input 3299792458\n9460730472580800\n\nSample Output 32",
        "desc": "This Java problem requires determining the K-th character in a string that undergoes exponential digit-based expansions over an extremely large number of iterations, testing concepts such as efficient string manipulation, recursion or iterative transformation techniques, and handling large numerical computations. It is classified as a difficult, high-level challenge typically suited for advanced competitive programming scenarios.",
        "program": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        char[] s = sc.next().toCharArray();\n        long k = sc.nextLong();\n        char ans = '1';\n        for(char str : s) {\n            if(str != '1') {\n                ans = str;\n                break;\n            }\n        }\n        System.out.println(ans);\n    }\n}",
        "error_desc": "1. The program only searches for the first non-'1' character instead of simulating the string's transformation over 5×10¹⁵ days.\n2. It does not account for the exponential growth of the string, making it unable to determine the correct K-th character.\n3. The logic improperly sets `ans` based solely on the first non-'1' character without considering the value of K."
    },
    {
        "problem_id": "p03371",
        "question": "Score : 300 points\n\nProblem Statement\"Pizza At\", a fast food chain, offers three kinds of pizza: \"A-pizza\", \"B-pizza\" and \"AB-pizza\". A-pizza and B-pizza are completely different pizzas, and AB-pizza is one half of A-pizza and one half of B-pizza combined together. The prices of one A-pizza, B-pizza and AB-pizza are A yen, B yen and C yen (yen is the currency of Japan), respectively.\nNakahashi needs to prepare X A-pizzas and Y B-pizzas for a party tonight. He can only obtain these pizzas by directly buying A-pizzas and B-pizzas, or buying two AB-pizzas and then rearrange them into one A-pizza and one B-pizza. At least how much money does he need for this? It is fine to have more pizzas than necessary by rearranging pizzas.\n\nConstraints\n1 ≤ A, B, C ≤ 5000\n1 ≤ X, Y ≤ 10^5\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nA B C X Y\n\nOutputPrint the minimum amount of money required to prepare X A-pizzas and Y B-pizzas.\n\nSample Input 11500 2000 1600 3 2\n\nSample Output 17900\n\nIt is optimal to buy four AB-pizzas and rearrange them into two A-pizzas and two B-pizzas, then buy additional one A-pizza.\n\nSample Input 21500 2000 1900 3 2\n\nSample Output 28500\n\nIt is optimal to directly buy three A-pizzas and two B-pizzas.\n\nSample Input 31500 2000 500 90000 100000\n\nSample Output 3100000000\n\nIt is optimal to buy 200000 AB-pizzas and rearrange them into 100000 A-pizzas and 100000 B-pizzas. We will have 10000 more A-pizzas than necessary, but that is fine.",
        "desc": "This Java problem requires determining the minimum cost to purchase a specific number of A-pizzas and B-pizzas by choosing between direct purchases and combination purchases of AB-pizzas, testing skills in algorithmic optimization and conditional decision-making. It is categorized as a high-difficulty (300 points) challenge.",
        "program": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        long a = sc.nextLong();\n        long b = sc.nextLong();\n        long c = sc.nextLong();\n        long x = sc.nextLong();\n        long y = sc.nextLong();\n        long price1 = a * x + b * y;\n        long price2 = a * Long.max(0, x - y) + 2 * c * y;\n        long price3 = 2 * c * x + b * Long.max(0, y - x);\n        long price4 = c * 2 * Long.max(x, y);\n        long ans = Long.min(Long.min(Long.min(price4, price3), price2), price1);\n        System.out.println(ans);\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02707",
        "question": "Score : 300 points\n\nProblem StatementA company has N members, who are assigned ID numbers 1, ..., N.\nEvery member, except the member numbered 1, has exactly one immediate boss with a smaller ID number.\nWhen a person X is the immediate boss of a person Y, the person Y is said to be an immediate subordinate of the person X.\nYou are given the information that the immediate boss of the member numbered i is the member numbered A_i. For each member, find how many immediate subordinates it has.\n\nConstraints\n2 \\leq N \\leq 2 \\times 10^5\n1 \\leq A_i &lt; i\n\nInputInput is given from Standard Input in the following format:\nN\nA_2 ... A_N\n\nOutputFor each of the members numbered 1, 2, ..., N, print the number of immediate subordinates it has, in its own line.\n\nSample Input 15\n1 1 2 2\n\nSample Output 12\n2\n0\n0\n0\n\nThe member numbered 1 has two immediate subordinates: the members numbered 2 and 3.\nThe member numbered 2 has two immediate subordinates: the members numbered 4 and 5.\nThe members numbered 3, 4, and 5 do not have immediate subordinates.\n\nSample Input 210\n1 1 1 1 1 1 1 1 1\n\nSample Output 29\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\nSample Input 37\n1 2 3 4 5 6\n\nSample Output 31\n1\n1\n1\n1\n1\n0",
        "desc": "The problem assesses the ability to efficiently process and count hierarchical relationships using array manipulation and frequency counting techniques, especially under large input constraints. It is categorized as a medium-difficulty Java programming challenge.",
        "program": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\npublic class Main implements Runnable {\n    public static void main(String[] args) {\n        new Thread(null,new Main(), \"\" ,Runtime.getRuntime().maxMemory()).start();\n    }\n    public void run() {\n        FastScanner sc = new FastScanner();\n        int n = sc.nextInt();\n        int[] ans = new int[n];\n        for(int i = 0;i < n - 1;i++) ans[sc.nextInt() - 1]++;\n        Arrays.stream(ans).forEachOrdered(System.out::println);\n    }\n}\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() { return Double.parseDouble(next());}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02819",
        "question": "Score: 300 points\n\nProblem Statement\nFind the minimum prime number greater than or equal to X.\n\nNotes\nA prime number is an integer greater than 1 that cannot be evenly divided by any positive integer except 1 and itself.\nFor example, 2, 3, and 5 are prime numbers, while 4 and 6 are not.\n\nConstraints\n\n 2 \\le X \\le 10^5 \nAll values in input are integers.\n\nInput\nInput is given from Standard Input in the following format:\nX\n\nOutput\nPrint the minimum prime number greater than or equal to X.\n\nSample Input 120\n\nSample Output 123\n\nThe minimum prime number greater than or equal to 20 is 23.\n\nSample Input 22\n\nSample Output 22\n\nX itself can be a prime number.\n\nSample Input 399992\n\nSample Output 3100003",
        "desc": "This Java problem assesses the ability to implement prime number detection and efficient search algorithms to find the smallest prime number that is greater than or equal to a given integer X. It tests concepts related to loops, conditionals, and optimization techniques, and is classified as a hard difficulty level.",
        "program": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\npublic class Main implements Runnable {\n    public static void main(String[] args) {\n        new Thread(null,new Main(), \"\" ,Runtime.getRuntime().maxMemory()).start();\n    }\n    public void run() {\n        FastScanner sc = new FastScanner();\n        int x = sc.nextInt();\n        while(true) {\n            if(x % 2 == 0) {\n                if(x == 2) {\n                    System.out.println(x);\n                    break;\n                }\n                else{\n                    x++;\n                    continue;\n                }\n            }\n            boolean isPrime = true;\n            for(int i = 3;i < x;i++) {\n                if(x % i == 0) {\n                    isPrime = false;\n                    break;\n                }\n            }\n            if(isPrime) {\n                System.out.println(x);\n                break;\n            }\n            else x++;\n        }\n    }\n}\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() { return Double.parseDouble(next());}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02675",
        "question": "Score: 100 points\n\nProblem Statement\nThe cat Snuke wants to play a popular Japanese game called ÅtCoder, so Iroha has decided to teach him Japanese.\nWhen counting pencils in Japanese, the counter word \"本\" follows the number. The pronunciation of this word varies depending on the number. Specifically, the pronunciation of \"本\" in the phrase \"N 本\" for a positive integer N not exceeding 999 is as follows:\n\nhon when the digit in the one's place of N is 2, 4, 5, 7, or 9;\npon when the digit in the one's place of N is 0, 1, 6 or 8;\nbon when the digit in the one's place of N is 3.\n\nGiven N, print the pronunciation of \"本\" in the phrase \"N 本\".\n\nConstraints\n\nN is a positive integer not exceeding 999.\n\nInput\nInput is given from Standard Input in the following format:\nN\n\nOutput\nPrint the answer.\n\nSample Input 116\n\nSample Output 1pon\n\nThe digit in the one's place of 16 is 6, so the \"本\" in \"16 本\" is pronounced pon.\n\nSample Input 22\n\nSample Output 2hon\n\nSample Input 3183\n\nSample Output 3bon",
        "desc": "This Java problem requires determining the correct pronunciation suffix (\"hon\", \"pon\", or \"bon\") for the Japanese counter \"本\" based on the last digit of a given integer \\( N \\) (≤999). It tests knowledge of input handling, conditional statements, and digit manipulation, and is classified as an easy-level challenge.",
        "program": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\npublic class Main implements Runnable {\n    public static void main(String[] args) {\n        new Thread(null,new Main(), \"\" ,Runtime.getRuntime().maxMemory()).start();\n    }\n    public void run() {\n        FastScanner sc = new FastScanner();\n        int n = sc.nextInt();\n        int one = n % 10;\n        String ans = \"\";\n        if(one == 2 || one == 4 || one == 5 || one == 7 || one == 9) ans = \"hon\";\n        else if(one == 0 || one == 1 || one == 6 || one == 8) ans = \"pon\";\n        else ans = \"bon\";\n        System.out.println(ans);\n    }\n}\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() { return Double.parseDouble(next());}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02676",
        "question": "Score: 200 points\n\nProblem Statement\nWe have a string S consisting of lowercase English letters.\nIf the length of S is at most K, print S without change.\nIf the length of S exceeds K, extract the first K characters in S, append ... to the end of them, and print the result.\n\nConstraints\n\nK is an integer between 1 and 100 (inclusive).\nS is a string consisting of lowercase English letters.\nThe length of S is between 1 and 100 (inclusive).\n\nInput\nInput is given from Standard Input in the following format:\nK\nS\n\nOutput\nPrint a string as stated in Problem Statement.\n\nSample Input 17\nnikoandsolstice\n\nSample Output 1nikoand...\n\nnikoandsolstice has a length of 15, which exceeds K=7.\nWe should extract the first 7 characters in this string, append ... to the end of them, and print the result nikoand....\n\nSample Input 240\nferelibenterhominesidquodvoluntcredunt\n\nSample Output 2ferelibenterhominesidquodvoluntcredunt\n\nThe famous quote from Gaius Julius Caesar.",
        "desc": "This Java problem assesses skills in string manipulation, conditional logic, and handling input/output operations. It is classified as an intermediate difficulty level, requiring familiarity with string methods and control structures.",
        "program": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\npublic class Main implements Runnable {\n    public static void main(String[] args) {\n        new Thread(null,new Main(), \"\" ,Runtime.getRuntime().maxMemory()).start();\n    }\n    public void run() {\n        FastScanner sc = new FastScanner();\n        int k = sc.nextInt();\n        String s = sc.next();\n        String ans = \"\";\n        if(s.length() <= k) {\n            ans = s;\n        }\n        else {\n            ans = s.substring(0, k) + \"...\";\n        }\n        System.out.println(ans);\n    }\n}\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() { return Double.parseDouble(next());}\n}",
        "error_desc": "No error."
    }
]