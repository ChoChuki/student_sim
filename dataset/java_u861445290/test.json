[
    {
        "problem_id": "p02677",
        "question": "Score: 300 points\n\nProblem Statement\nConsider an analog clock whose hour and minute hands are A and B centimeters long, respectively.\nAn endpoint of the hour hand and an endpoint of the minute hand are fixed at the same point, around which each hand rotates clockwise at constant angular velocity. It takes the hour and minute hands 12 hours and 1 hour to make one full rotation, respectively.\nAt 0 o'clock, the two hands overlap each other. H hours and M minutes later, what is the distance in centimeters between the unfixed endpoints of the hands?\n\nConstraints\n\nAll values in input are integers.\n1 \\leq A, B \\leq 1000\n0 \\leq H \\leq 11\n0 \\leq M \\leq 59\n\nInput\nInput is given from Standard Input in the following format:\nA B H M\n\nOutput\nPrint the answer without units. Your output will be accepted when its absolute or relative error from the correct value is at most 10^{-9}.\n\nSample Input 13 4 9 0\n\nSample Output 15.00000000000000000000\n\nThe two hands will be in the positions shown in the figure below, so the answer is 5 centimeters.\n\nSample Input 23 4 10 40\n\nSample Output 24.56425719433005567605\n\nThe two hands will be in the positions shown in the figure below. Note that each hand always rotates at constant angular velocity.",
        "desc": "This problem requires determining the distance between the endpoints of hour and minute hands on an analog clock after a given time, testing concepts such as angle calculation based on time, trigonometric functions, and precise floating-point computations. It is classified as a high-difficulty (300-point) Java programming challenge.",
        "program": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\npublic class Main implements Runnable {\n    public static void main(String[] args) {\n        new Thread(null,new Main(), \"\" ,Runtime.getRuntime().maxMemory()).start();\n    }\n    public void run() {\n        FastScanner sc = new FastScanner();\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        int h = sc.nextInt();\n        int m = sc.nextInt();\n        double newAx = Math.sin(Math.toRadians(360.0 - (360.0 * (h / 12.0) + 30.0 *(m / 60.0)))) * -1.0 * a;\n        double newAy = Math.cos(Math.toRadians(360.0 - (360.0 * (h / 12.0) + 30.0 *(m / 60.0)))) * a;\n        double newBx = Math.sin(Math.toRadians(360.0 - (360.0 * (m / 60.0)))) * -1.0 * b;\n        double newBy = Math.cos(Math.toRadians(360.0 - (360.0 * (m / 60.0)))) * b;\n        double ans = Math.sqrt(Math.pow(newAx - newBx, 2) + Math.pow(newAy - newBy, 2));\n        System.out.println(ans);\n    }\n}\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() { return Double.parseDouble(next());}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02786",
        "question": "Score : 400 points\n\nProblem StatementCaracal is fighting with a monster.\nThe health of the monster is H.\nCaracal can attack by choosing one monster. When a monster is attacked, depending on that monster's health, the following happens:\n\nIf the monster's health is 1, it drops to 0.\nIf the monster's health, X, is greater than 1, that monster disappears. Then, two new monsters appear, each with the health of \\lfloor X/2 \\rfloor.\n\n(\\lfloor r \\rfloor denotes the greatest integer not exceeding r.)\nCaracal wins when the healths of all existing monsters become 0 or below.\nFind the minimum number of attacks Caracal needs to make before winning.\n\nConstraints\n1 \\leq H \\leq 10^{12}\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nH\n\nOutputFind the minimum number of attacks Caracal needs to make before winning.\n\nSample Input 12\n\nSample Output 13\n\nWhen Caracal attacks the initial monster, it disappears, and two monsters appear, each with the health of 1.\nThen, Caracal can attack each of these new monsters once and win with a total of three attacks.\n\nSample Input 24\n\nSample Output 27\n\nSample Input 31000000000000\n\nSample Output 31099511627775",
        "desc": "This Java problem assesses the ability to implement recursive or divide-and-conquer strategies to determine the minimum number of attacks required to reduce a monster's health to zero, especially handling large input values efficiently. It is considered a challenging, high-difficulty level question suitable for experienced programmers.",
        "program": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\npublic class Main implements Runnable {\n    public static void main(String[] args) {\n        new Thread(null,new Main(), \"\" ,Runtime.getRuntime().maxMemory()).start();\n    }\n    public void run() {\n        FastScanner sc = new FastScanner();\n        long h = sc.nextLong();\n        long ans = 0;\n        long tmp = 1;\n        while(h > 0) {\n            ans += tmp;\n            tmp *= 2;\n            h /= 2;\n        }\n        PrintWriter out =  new PrintWriter(System.out);\n        out.println(ans);\n        out.flush();\n    }\n    long nCm(long n, long m) {\n        if(n < m) return 0l;\n        long c = 1l;\n        m = (n - m < m ? n - m : m);\n        for(long ns = n - m + 1, ms = 1;ms <= m;ns ++, ms++) {\n            c *= ns;\n            c /= ms;\n        }\n        return c;\n    }\n    long modnCm(int n, int m, int mod) {\n        if(n < m) return 0l;\n        long upper = 1l;\n        long downer = 1l;\n        m = (n - m < m ? n - m : m);\n        for(long ns = n - m + 1, ms = 1;ms <= m;ns ++, ms++) {\n            upper = upper * ns % mod;\n            downer = downer * ms % mod;\n        }\n        return upper * modInv(downer, mod) % mod;\n    }\n    long modInv(long a, long m) {\n        long b = m, u = 1, v = 0;\n        while(b > 0) {\n            long t = a / b;\n            a -= t * b;\n            long tmp = a;\n            a = b;\n            b = tmp;\n            u -= t * v;\n            tmp = u;\n            u = v;\n            v = tmp;\n        }\n        u %= m;\n        if (u < 0) u += m;\n        return u;\n    }\n    long modPow(long a, long n, long mod) {\n        long res = 1l;\n        while(n > 0l) {\n            if(n % 2l == 1l) res = res * a % mod;\n            a = a * a % mod;\n            n /= 2l;\n        }\n        return res;\n    }\n}\nclass UnionFind {\n    private int[] parent;\n    UnionFind(int n) {\n        parent = new int[n];\n        for(int i = 0;i < n;i++) parent[i] = i;\n    }\n    public int rootOf(int x) {\n        if(parent[x] == x) return x;\n        else return parent[x] = rootOf(parent[x]);\n    }\n    public boolean same(int x, int y) {\n        return rootOf(x) == rootOf(y);\n    }\n    public void unite(int x, int y) {\n        x = rootOf(x);\n        y = rootOf(y);\n        if(x == y) return;\n        parent[x] = y;\n        return;\n    }\n}\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() { return Double.parseDouble(next());}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02847",
        "question": "Score : 100 points\n\nProblem StatementGiven is a string S representing the day of the week today.\nS is SUN, MON, TUE, WED, THU, FRI, or SAT, for Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, and Saturday, respectively.\nAfter how many days is the next Sunday (tomorrow or later)?\n\nConstraints\nS is SUN, MON, TUE, WED, THU, FRI, or SAT.\n\nInputInput is given from Standard Input in the following format:\nS\n\nOutputPrint the number of days before the next Sunday.\n\nSample Input 1SAT\n\nSample Output 11\n\nIt is Saturday today, and tomorrow will be Sunday.\n\nSample Input 2SUN\n\nSample Output 27\n\nIt is Sunday today, and seven days later, it will be Sunday again.",
        "desc": "This Java problem assesses understanding of string manipulation, mapping enumerated values (days of the week) to numerical representations, and applying modular arithmetic to calculate intervals. It is considered to have an easy to medium difficulty level.",
        "program": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\npublic class Main implements Runnable {\n    public static void main(String[] args) {\n        new Thread(null,new Main(), \"\" ,Runtime.getRuntime().maxMemory()).start();\n    }\n    public void run() {\n        FastScanner sc = new FastScanner();\n        String s = sc.next();\n        int ans = 0;\n        if(s.equals(\"SUN\")) ans = 7;\n        else if(s.equals(\"MON\")) ans = 6;\n        else if(s.equals(\"TUE\")) ans = 5;\n        else if(s.equals(\"WED\")) ans = 4;\n        else if(s.equals(\"THU\")) ans = 3;\n        else if(s.equals(\"FRI\")) ans = 2;\n        else if(s.equals(\"SAT\")) ans = 1;\n        PrintWriter out =  new PrintWriter(System.out);\n        out.println(ans);\n        out.flush();\n    }\n    long nCm(long n, long m) {\n        if(n < m) return 0l;\n        long c = 1l;\n        m = (n - m < m ? n - m : m);\n        for(long ns = n - m + 1, ms = 1;ms <= m;ns ++, ms++) {\n            c *= ns;\n            c /= ms;\n        }\n        return c;\n    }\n    long modnCm(int n, int m, int mod) {\n        if(n < m) return 0l;\n        long upper = 1l;\n        long downer = 1l;\n        m = (n - m < m ? n - m : m);\n        for(long ns = n - m + 1, ms = 1;ms <= m;ns ++, ms++) {\n            upper = upper * ns % mod;\n            downer = downer * ms % mod;\n        }\n        return upper * modInv(downer, mod) % mod;\n    }\n    long modInv(long a, long m) {\n        long b = m, u = 1, v = 0;\n        while(b > 0) {\n            long t = a / b;\n            a -= t * b;\n            long tmp = a;\n            a = b;\n            b = tmp;\n            u -= t * v;\n            tmp = u;\n            u = v;\n            v = tmp;\n        }\n        u %= m;\n        if (u < 0) u += m;\n        return u;\n    }\n    long modPow(long a, long n, long mod) {\n        long res = 1l;\n        while(n > 0l) {\n            if(n % 2l == 1l) res = res * a % mod;\n            a = a * a % mod;\n            n /= 2l;\n        }\n        return res;\n    }\n}\nclass UnionFind {\n    private int[] parent;\n    UnionFind(int n) {\n        parent = new int[n];\n        for(int i = 0;i < n;i++) parent[i] = i;\n    }\n    public int rootOf(int x) {\n        if(parent[x] == x) return x;\n        else return parent[x] = rootOf(parent[x]);\n    }\n    public boolean same(int x, int y) {\n        return rootOf(x) == rootOf(y);\n    }\n    public void unite(int x, int y) {\n        x = rootOf(x);\n        y = rootOf(y);\n        if(x == y) return;\n        parent[x] = y;\n        return;\n    }\n}\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() { return Double.parseDouble(next());}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02723",
        "question": "Score : 100 points\n\nProblem StatementA string of length 6 consisting of lowercase English letters is said to be coffee-like if and only if its 3-rd and 4-th characters are equal and its 5-th and 6-th characters are also equal.\nGiven a string S, determine whether it is coffee-like.\n\nConstraints\nS is a string of length 6 consisting of lowercase English letters.\n\nInputInput is given from Standard Input in the following format:\nS\n\nOutputIf S is coffee-like, print Yes; otherwise, print No.\n\nSample Input 1sippuu\n\nSample Output 1Yes\n\nIn sippuu, the 3-rd and 4-th characters are equal, and the 5-th and 6-th characters are also equal.\n\nSample Input 2iphone\n\nSample Output 2No\n\nSample Input 3coffee\n\nSample Output 3Yes",
        "desc": "This Java problem assesses understanding of string manipulation and indexing by requiring verification of specific character positions within a fixed-length string. It is rated as an easy-level question, suitable for beginners practicing basic conditional logic and string operations.",
        "program": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\npublic class Main implements Runnable {\n    public static void main(String[] args) {\n        new Thread(null,new Main(), \"\" ,Runtime.getRuntime().maxMemory()).start();\n    }\n    public void run() {\n        FastScanner sc = new FastScanner();\n        char[] s = sc.next().toCharArray();\n        PrintWriter out =  new PrintWriter(System.out);\n        if(s[2] == s[3] && s[4] == s[5]) out.println(\"Yes\");\n        else out.println(\"No\");\n        out.flush();\n    }\n    long nCm(long n, long m) {\n        if(n < m) return 0l;\n        long c = 1l;\n        m = (n - m < m ? n - m : m);\n        for(long ns = n - m + 1, ms = 1;ms <= m;ns ++, ms++) {\n            c *= ns;\n            c /= ms;\n        }\n        return c;\n    }\n    long modnCm(int n, int m, int mod) {\n        if(n < m) return 0l;\n        long upper = 1l;\n        long downer = 1l;\n        m = (n - m < m ? n - m : m);\n        for(long ns = n - m + 1, ms = 1;ms <= m;ns ++, ms++) {\n            upper = upper * ns % mod;\n            downer = downer * ms % mod;\n        }\n        return upper * modInv(downer, mod) % mod;\n    }\n    long modInv(long a, long m) {\n        long b = m, u = 1, v = 0;\n        while(b > 0) {\n            long t = a / b;\n            a -= t * b;\n            long tmp = a;\n            a = b;\n            b = tmp;\n            u -= t * v;\n            tmp = u;\n            u = v;\n            v = tmp;\n        }\n        u %= m;\n        if (u < 0) u += m;\n        return u;\n    }\n    long modPow(long a, long n, long mod) {\n        long res = 1l;\n        while(n > 0l) {\n            if(n % 2l == 1l) res = res * a % mod;\n            a = a * a % mod;\n            n /= 2l;\n        }\n        return res;\n    }\n}\nclass UnionFind {\n    private int[] parent;\n    UnionFind(int n) {\n        parent = new int[n];\n        for(int i = 0;i < n;i++) parent[i] = i;\n    }\n    public int rootOf(int x) {\n        if(parent[x] == x) return x;\n        else return parent[x] = rootOf(parent[x]);\n    }\n    public boolean same(int x, int y) {\n        return rootOf(x) == rootOf(y);\n    }\n    public void unite(int x, int y) {\n        x = rootOf(x);\n        y = rootOf(y);\n        if(x == y) return;\n        parent[x] = y;\n        return;\n    }\n}\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() { return Double.parseDouble(next());}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02829",
        "question": "Score: 100 points\n\nProblem Statement\nTakahashi is solving quizzes. He has easily solved all but the last one.\nThe last quiz has three choices: 1, 2, and 3.\nWith his supernatural power, Takahashi has found out that the choices A and B are both wrong.\nPrint the correct choice for this problem.\n\nConstraints\n\nEach of the numbers A and B is 1, 2, or 3.\nA and B are different.\n\nInput\nInput is given from Standard Input in the following format:\nA\nB\n\nOutput\nPrint the correct choice.\n\nSample Input 13\n1\n\nSample Output 12\n\nWhen we know 3 and 1 are both wrong, the correct choice is 2.\n\nSample Input 21\n2\n\nSample Output 23",
        "desc": "This problem requires identifying the remaining correct choice from three options after two incorrect ones are provided, testing basic input handling and conditional logic in Java. It is classified as an easy-level programming challenge.",
        "program": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\npublic class Main implements Runnable {\n    public static void main(String[] args) {\n        new Thread(null,new Main(), \"\" ,Runtime.getRuntime().maxMemory()).start();\n    }\n    public void run() {\n        FastScanner sc = new FastScanner();\n        int x = sc.nextInt();\n        int y = sc.nextInt();\n        boolean[] ans = new boolean[3];\n        ans[x - 1] = true;\n        ans[y - 1] = true;\n        PrintWriter out =  new PrintWriter(System.out);\n        for(int i = 0;i < 3;i++) {\n            if(!ans[i]) out.println(i + 1);\n        }\n        out.flush();\n    }\n    long nCm(long n, long m) {\n        if(n < m) return 0l;\n        long c = 1l;\n        m = (n - m < m ? n - m : m);\n        for(long ns = n - m + 1, ms = 1;ms <= m;ns ++, ms++) {\n            c *= ns;\n            c /= ms;\n        }\n        return c;\n    }\n    long modnCm(int n, int m, int mod) {\n        if(n < m) return 0l;\n        long upper = 1l;\n        long downer = 1l;\n        m = (n - m < m ? n - m : m);\n        for(long ns = n - m + 1, ms = 1;ms <= m;ns ++, ms++) {\n            upper = upper * ns % mod;\n            downer = downer * ms % mod;\n        }\n        return upper * modInv(downer, mod) % mod;\n    }\n    long modInv(long a, long m) {\n        long b = m, u = 1, v = 0;\n        while(b > 0) {\n            long t = a / b;\n            a -= t * b;\n            long tmp = a;\n            a = b;\n            b = tmp;\n            u -= t * v;\n            tmp = u;\n            u = v;\n            v = tmp;\n        }\n        u %= m;\n        if (u < 0) u += m;\n        return u;\n    }\n    long modPow(long a, long n, long mod) {\n        long res = 1l;\n        while(n > 0l) {\n            if(n % 2l == 1l) res = res * a % mod;\n            a = a * a % mod;\n            n /= 2l;\n        }\n        return res;\n    }\n}\nclass UnionFind {\n    private int[] parent;\n    UnionFind(int n) {\n        parent = new int[n];\n        for(int i = 0;i < n;i++) parent[i] = i;\n    }\n    public int rootOf(int x) {\n        if(parent[x] == x) return x;\n        else return parent[x] = rootOf(parent[x]);\n    }\n    public boolean same(int x, int y) {\n        return rootOf(x) == rootOf(y);\n    }\n    public void unite(int x, int y) {\n        x = rootOf(x);\n        y = rootOf(y);\n        if(x == y) return;\n        parent[x] = y;\n        return;\n    }\n}\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() { return Double.parseDouble(next());}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02657",
        "question": "Score : 100 points\n\nProblem StatementCompute A \\times B.\n\nConstraints\n1 \\leq A \\leq 100\n1 \\leq B \\leq 100\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nA B\n\nOutputPrint the value A \\times B as an integer.\n\nSample Input 12 5\n\nSample Output 110\n\nWe have 2 \\times 5 = 10.\n\nSample Input 2100 100\n\nSample Output 210000",
        "desc": "This Java problem requires reading two integers from standard input and outputting their product, testing fundamental concepts like input handling, data types, and arithmetic operations. It is classified as an easy-level question suitable for beginners.",
        "program": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\npublic class Main implements Runnable {\n    public static void main(String[] args) {\n        new Thread(null,new Main(), \"\" ,Runtime.getRuntime().maxMemory()).start();\n    }\n    public void run() {\n        FastScanner sc = new FastScanner();\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        PrintWriter out =  new PrintWriter(System.out);\n        out.println(a * b);\n        out.flush();\n    }\n    long nCm(long n, long m) {\n        if(n < m) return 0l;\n        long c = 1l;\n        m = (n - m < m ? n - m : m);\n        for(long ns = n - m + 1, ms = 1;ms <= m;ns ++, ms++) {\n            c *= ns;\n            c /= ms;\n        }\n        return c;\n    }\n    long modnCm(long n, long m, long mod) {\n        if(n < m) return 0l;\n        long upper = 1l;\n        long downer = 1l;\n        m = (n - m < m ? n - m : m);\n        for(long ns = n - m + 1, ms = 1;ms <= m;ns ++, ms++) {\n            upper = upper * ns % mod;\n            downer = downer * ms % mod;\n        }\n        return upper * modInv(downer, mod) % mod;\n    }\n    long modInv(long a, long m) {\n        long b = m, u = 1, v = 0;\n        while(b > 0) {\n            long t = a / b;\n            a -= t * b;\n            long tmp = a;\n            a = b;\n            b = tmp;\n            u -= t * v;\n            tmp = u;\n            u = v;\n            v = tmp;\n        }\n        u %= m;\n        if (u < 0) u += m;\n        return u;\n    }\n    long modPow(long a, long n, long mod) {\n        long res = 1l;\n        while(n > 0l) {\n            if(n % 2l == 1l) res = res * a % mod;\n            a = a * a % mod;\n            n /= 2l;\n        }\n        return res;\n    }\n}\nclass UnionFind {\n    private int[] parent;\n    UnionFind(int n) {\n        parent = new int[n];\n        for(int i = 0;i < n;i++) parent[i] = i;\n    }\n    public int rootOf(int x) {\n        if(parent[x] == x) return x;\n        else return parent[x] = rootOf(parent[x]);\n    }\n    public boolean same(int x, int y) {\n        return rootOf(x) == rootOf(y);\n    }\n    public void unite(int x, int y) {\n        x = rootOf(x);\n        y = rootOf(y);\n        if(x == y) return;\n        parent[x] = y;\n        return;\n    }\n}\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() { return Double.parseDouble(next());}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02658",
        "question": "Score : 200 points\n\nProblem StatementGiven N integers A_1, ..., A_N, compute A_1 \\times ... \\times A_N.\nHowever, if the result exceeds 10^{18}, print -1 instead.\n\nConstraints\n2 \\leq N \\leq 10^5\n0 \\leq A_i \\leq 10^{18}\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nN\nA_1 ... A_N\n\nOutputPrint the value A_1 \\times ... \\times A_N as an integer, or -1 if the value exceeds 10^{18}.\n\nSample Input 12\n1000000000 1000000000\n\nSample Output 11000000000000000000\n\nWe have 1000000000 \\times 1000000000 = 1000000000000000000.\n\nSample Input 23\n101 9901 999999000001\n\nSample Output 2-1\n\nWe have 101 \\times 9901 \\times 999999000001 = 1000000000000000001, which exceeds 10^{18}, so we should print -1 instead.\n\nSample Input 331\n4 1 5 9 2 6 5 3 5 8 9 7 9 3 2 3 8 4 6 2 6 4 3 3 8 3 2 7 9 5 0\n\nSample Output 30",
        "desc": "This problem assesses the ability to efficiently process large input sizes and manage potential integer overflow by correctly handling large numerical computations in Java. It tests understanding of data types, loop optimization, and overflow detection mechanisms, and is classified as a medium to hard difficulty level.",
        "program": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\npublic class Main implements Runnable {\n    public static void main(String[] args) {\n        new Thread(null,new Main(), \"\" ,Runtime.getRuntime().maxMemory()).start();\n    }\n    public void run() {\n        FastScanner sc = new FastScanner();\n        int n = sc.nextInt();\n        long ans = 1;\n        for(int i = 0;i < n;i++) ans *= sc.nextLong();\n        if(ans < 0 || ans > 1000000000000000000l) ans = -1;\n        PrintWriter out =  new PrintWriter(System.out);\n        out.println(ans);\n        out.flush();\n    }\n    long nCm(long n, long m) {\n        if(n < m) return 0l;\n        long c = 1l;\n        m = (n - m < m ? n - m : m);\n        for(long ns = n - m + 1, ms = 1;ms <= m;ns ++, ms++) {\n            c *= ns;\n            c /= ms;\n        }\n        return c;\n    }\n    long modnCm(long n, long m, long mod) {\n        if(n < m) return 0l;\n        long upper = 1l;\n        long downer = 1l;\n        m = (n - m < m ? n - m : m);\n        for(long ns = n - m + 1, ms = 1;ms <= m;ns ++, ms++) {\n            upper = upper * ns % mod;\n            downer = downer * ms % mod;\n        }\n        return upper * modInv(downer, mod) % mod;\n    }\n    long modInv(long a, long m) {\n        long b = m, u = 1, v = 0;\n        while(b > 0) {\n            long t = a / b;\n            a -= t * b;\n            long tmp = a;\n            a = b;\n            b = tmp;\n            u -= t * v;\n            tmp = u;\n            u = v;\n            v = tmp;\n        }\n        u %= m;\n        if (u < 0) u += m;\n        return u;\n    }\n    long modPow(long a, long n, long mod) {\n        long res = 1l;\n        while(n > 0l) {\n            if(n % 2l == 1l) res = res * a % mod;\n            a = a * a % mod;\n            n /= 2l;\n        }\n        return res;\n    }\n}\nclass UnionFind {\n    private int[] parent;\n    UnionFind(int n) {\n        parent = new int[n];\n        for(int i = 0;i < n;i++) parent[i] = i;\n    }\n    public int rootOf(int x) {\n        if(parent[x] == x) return x;\n        else return parent[x] = rootOf(parent[x]);\n    }\n    public boolean same(int x, int y) {\n        return rootOf(x) == rootOf(y);\n    }\n    public void unite(int x, int y) {\n        x = rootOf(x);\n        y = rootOf(y);\n        if(x == y) return;\n        parent[x] = y;\n        return;\n    }\n}\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() { return Double.parseDouble(next());}\n}",
        "error_desc": "1. The product is stored in a `long`, which cannot handle values larger than 9,223,372,036,854,775,807, causing overflow.\n2. The condition `if(ans < 0 || ans > 1000000000000000000l)` fails to accurately detect when the product exceeds 10¹⁸ before overflow occurs.\n3. The code multiplies all integers without checking for potential overflow at each step, leading to incorrect results when the product exceeds the `long` limit."
    },
    {
        "problem_id": "p02659",
        "question": "Score : 300 points\n\nProblem StatementCompute A \\times B, truncate its fractional part, and print the result as an integer.\n\nConstraints\n0 \\leq A \\leq 10^{15}\n0 \\leq B &lt; 10\nA is an integer.\nB is a number with two digits after the decimal point.\n\nInputInput is given from Standard Input in the following format:\nA B\n\nOutputPrint the answer as an integer.\n\nSample Input 1198 1.10\n\nSample Output 1217\n\nWe have 198 \\times 1.10 = 217.8. After truncating the fractional part, we have the answer: 217.\n\nSample Input 21 0.01\n\nSample Output 20\n\nSample Input 31000000000000000 9.99\n\nSample Output 39990000000000000",
        "desc": "This Java problem requires multiplying a large integer A by a decimal B with two decimal places, handling potential precision issues and truncating the result to an integer. It tests understanding of numerical data types, precision management, and arithmetic operations, and is classified as a medium to hard difficulty level.",
        "program": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\npublic class Main implements Runnable {\n    public static void main(String[] args) {\n        new Thread(null,new Main(), \"\" ,Runtime.getRuntime().maxMemory()).start();\n    }\n    public void run() {\n        FastScanner sc = new FastScanner();\n        long a = sc.nextLong();\n        double b = sc.nextDouble();\n        PrintWriter out =  new PrintWriter(System.out);\n        out.println((long)(a * b));\n        out.flush();\n    }\n    long nCm(long n, long m) {\n        if(n < m) return 0l;\n        long c = 1l;\n        m = (n - m < m ? n - m : m);\n        for(long ns = n - m + 1, ms = 1;ms <= m;ns ++, ms++) {\n            c *= ns;\n            c /= ms;\n        }\n        return c;\n    }\n    long modnCm(long n, long m, long mod) {\n        if(n < m) return 0l;\n        long upper = 1l;\n        long downer = 1l;\n        m = (n - m < m ? n - m : m);\n        for(long ns = n - m + 1, ms = 1;ms <= m;ns ++, ms++) {\n            upper = upper * ns % mod;\n            downer = downer * ms % mod;\n        }\n        return upper * modInv(downer, mod) % mod;\n    }\n    long modInv(long a, long m) {\n        long b = m, u = 1, v = 0;\n        while(b > 0) {\n            long t = a / b;\n            a -= t * b;\n            long tmp = a;\n            a = b;\n            b = tmp;\n            u -= t * v;\n            tmp = u;\n            u = v;\n            v = tmp;\n        }\n        u %= m;\n        if (u < 0) u += m;\n        return u;\n    }\n    long modPow(long a, long n, long mod) {\n        long res = 1l;\n        while(n > 0l) {\n            if(n % 2l == 1l) res = res * a % mod;\n            a = a * a % mod;\n            n /= 2l;\n        }\n        return res;\n    }\n}\nclass UnionFind {\n    private int[] parent;\n    UnionFind(int n) {\n        parent = new int[n];\n        for(int i = 0;i < n;i++) parent[i] = i;\n    }\n    public int rootOf(int x) {\n        if(parent[x] == x) return x;\n        else return parent[x] = rootOf(parent[x]);\n    }\n    public boolean same(int x, int y) {\n        return rootOf(x) == rootOf(y);\n    }\n    public void unite(int x, int y) {\n        x = rootOf(x);\n        y = rootOf(y);\n        if(x == y) return;\n        parent[x] = y;\n        return;\n    }\n}\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() { return Double.parseDouble(next());}\n}",
        "error_desc": "1. The `Thread` constructor incorrectly uses `Runtime.getRuntime().maxMemory()` as the stack size, which can cause the program to fail.\n2. Using a `double` for variable `b` may introduce precision errors when multiplying and truncating the result.\n3. Including unnecessary utility classes and methods like `UnionFind` and combinatorial functions adds unnecessary complexity to the code."
    },
    {
        "problem_id": "p02725",
        "question": "Score : 300 points\n\nProblem StatementThere is a circular pond with a perimeter of K meters, and N houses around them.\nThe i-th house is built at a distance of A_i meters from the northmost point of the pond, measured clockwise around the pond.\nWhen traveling between these houses, you can only go around the pond.\nFind the minimum distance that needs to be traveled when you start at one of the houses and visit all the N houses.\n\nConstraints\n2 \\leq K \\leq 10^6\n2 \\leq N \\leq 2 \\times 10^5\n0 \\leq A_1 &lt; ... &lt; A_N &lt; K\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nK N\nA_1 A_2 ... A_N\n\nOutputPrint the minimum distance that needs to be traveled when you start at one of the houses and visit all the N houses.\n\nSample Input 120 3\n5 10 15\n\nSample Output 110\n\nIf you start at the 1-st house and go to the 2-nd and 3-rd houses in this order, the total distance traveled will be 10.\n\nSample Input 220 3\n0 5 15\n\nSample Output 210\n\nIf you start at the 2-nd house and go to the 1-st and 3-rd houses in this order, the total distance traveled will be 10.",
        "desc": "This problem involves calculating the shortest path to visit all houses positioned around a circular perimeter, testing concepts such as circular distance calculations and efficient algorithm design for handling large inputs. It is classified as a medium to hard difficulty level, suitable for competitive programming and algorithmic challenges.",
        "program": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\npublic class Main implements Runnable {\n    public static void main(String[] args) {\n        new Thread(null,new Main(), \"\" ,Runtime.getRuntime().maxMemory()).start();\n    }\n    public void run() {\n        FastScanner sc = new FastScanner();\n        int k = sc.nextInt();\n        int n = sc.nextInt();\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++) a[i] = sc.nextInt();\n        long ans = Long.MAX_VALUE;\n        for(int i = 0;i < n;i++) {\n            int terminal1, terminal2;\n            int distance1 = 0, distance2 = 0;\n            if(i == 0) {\n                terminal1 = n - 1;\n                distance1 = a[terminal1] - a[i];\n            }\n            else {\n                terminal1 = i - 1;\n                distance1 = a[n - 1] - a[i] + (k - a[n - 1]) + a[terminal1];\n            }\n            if(i == n - 1) {\n                terminal2 = 0;\n                distance2 = a[n - 1] - a[terminal2];\n            }\n            else {\n                terminal2 = i + 1;\n                distance2 = a[i] + (k - a[terminal2]);\n            }\n            ans = Long.min(ans, Long.min(distance1, distance2));\n        }\n        PrintWriter out =  new PrintWriter(System.out);\n        out.println(ans);\n        out.flush();\n    }\n    Set<long[]> primeFactorize(long n){\n        Set<long[]> ret = new HashSet<>(500);\n        for(long p = 2;p * p <= n;p++) {\n            if(n % p != 0) continue;\n            long num = 0;\n            while(n % p == 0) {\n                ++num;\n                n /= p;\n            }\n            long[] arr = {p, num};\n            ret.add(arr);\n        }\n        if(n != 1) {\n            long[] arr = {n, 1};\n            ret.add(arr);\n        }\n        return ret;\n    }\n    Set<Long> searchDivisor(long n){\n        Set<Long> ret = new HashSet<>(200);\n        for(long i = 1;i * i <= n;i++) {\n            if(n % i == 0) {\n                ret.add(Long.valueOf(i));\n                if(i * i != n) ret.add(Long.valueOf(n / i));\n            }\n        }\n        return ret;\n    }\n    public static boolean isPrime(long num) {\n        if (num < 2) return false;\n        else if (num == 2) return true;\n        else if (num % 2 == 0) return false;\n        double sqrtNum = Math.sqrt(num);\n        for (int i = 3; i <= sqrtNum; i += 2) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n    long nCm(long n, long m) {\n        if(n < m) return 0l;\n        long c = 1l;\n        m = (n - m < m ? n - m : m);\n        for(long ns = n - m + 1, ms = 1;ms <= m;ns ++, ms++) {\n            c *= ns;\n            c /= ms;\n        }\n        return c;\n    }\n    long modnCm(long n, long m, long mod) {\n        if(n < m) return 0l;\n        long upper = 1l;\n        long downer = 1l;\n        m = (n - m < m ? n - m : m);\n        for(long ns = n - m + 1, ms = 1;ms <= m;ns ++, ms++) {\n            upper = upper * ns % mod;\n            downer = downer * ms % mod;\n        }\n        return upper * modInv(downer, mod) % mod;\n    }\n    long modInv(long a, long m) {\n        long b = m, u = 1, v = 0;\n        while(b > 0) {\n            long t = a / b;\n            a -= t * b;\n            long tmp = a;\n            a = b;\n            b = tmp;\n            u -= t * v;\n            tmp = u;\n            u = v;\n            v = tmp;\n        }\n        u %= m;\n        if (u < 0) u += m;\n        return u;\n    }\n    long modPow(long a, long n, long mod) {\n        long res = 1l;\n        while(n > 0l) {\n            if(n % 2l == 1l) res = res * a % mod;\n            a = a * a % mod;\n            n /= 2l;\n        }\n        return res;\n    }\n}\nclass UnionFind {\n    private int[] parent;\n    UnionFind(int n) {\n        parent = new int[n];\n        for(int i = 0;i < n;i++) parent[i] = i;\n    }\n    public int rootOf(int x) {\n        if(parent[x] == x) return x;\n        else return parent[x] = rootOf(parent[x]);\n    }\n    public boolean same(int x, int y) {\n        return rootOf(x) == rootOf(y);\n    }\n    public void unite(int x, int y) {\n        x = rootOf(x);\n        y = rootOf(y);\n        if(x == y) return;\n        parent[x] = y;\n        return;\n    }\n}\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() { return Double.parseDouble(next());}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02771",
        "question": "Score: 100 points\n\nProblem Statement\nA triple of numbers is said to be poor when two of those numbers are equal but the other number is different from those two numbers.\nYou will be given three integers A, B, and C. If this triple is poor, print Yes; otherwise, print No.\n\nConstraints\n\nA, B, and C are all integers between 1 and 9 (inclusive).\n\nInput\nInput is given from Standard Input in the following format:\nA B C\n\nOutput\nIf the given triple is poor, print Yes; otherwise, print No.\n\nSample Input 15 7 5\n\nSample Output 1Yes\n\nA and C are equal, but B is different from those two numbers, so this triple is poor.\n\nSample Input 24 4 4\n\nSample Output 2No\n\nA, B, and C are all equal, so this triple is not poor.\n\nSample Input 34 9 6\n\nSample Output 3No\n\nSample Input 43 3 4\n\nSample Output 4Yes",
        "desc": "This Java problem requires determining if exactly two out of three given integers are equal while the third is different, testing the programmer’s ability to use conditional statements and equality checks. It is classified as an easy-level exercise suitable for beginners.",
        "program": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\npublic class Main implements Runnable {\n    public static void main(String[] args) {\n        new Thread(null,new Main(), \"\" ,Runtime.getRuntime().maxMemory()).start();\n    }\n    public void run() {\n        FastScanner sc = new FastScanner();\n        int[] count = new int[11];\n        int max = -1;\n        for(int i = 0;i < 3;i++) {\n            int n = sc.nextInt();\n            ++count[n];\n            max = Integer.max(max, count[n]);\n        }\n        PrintWriter out =  new PrintWriter(System.out);\n        if(max == 2) out.println(\"Yes\");\n        else out.println(\"No\");\n        out.flush();\n    }\n    Set<long[]> primeFactorize(long n){\n        Set<long[]> ret = new HashSet<>(500);\n        for(long p = 2;p * p <= n;p++) {\n            if(n % p != 0) continue;\n            long num = 0;\n            while(n % p == 0) {\n                ++num;\n                n /= p;\n            }\n            long[] arr = {p, num};\n            ret.add(arr);\n        }\n        if(n != 1) {\n            long[] arr = {n, 1};\n            ret.add(arr);\n        }\n        return ret;\n    }\n    Set<Long> searchDivisor(long n){\n        Set<Long> ret = new HashSet<>(200);\n        for(long i = 1;i * i <= n;i++) {\n            if(n % i == 0) {\n                ret.add(Long.valueOf(i));\n                if(i * i != n) ret.add(Long.valueOf(n / i));\n            }\n        }\n        return ret;\n    }\n    public static boolean isPrime(long num) {\n        if (num < 2) return false;\n        else if (num == 2) return true;\n        else if (num % 2 == 0) return false;\n        double sqrtNum = Math.sqrt(num);\n        for (int i = 3; i <= sqrtNum; i += 2) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n    long nCm(long n, long m) {\n        if(n < m) return 0l;\n        long c = 1l;\n        m = (n - m < m ? n - m : m);\n        for(long ns = n - m + 1, ms = 1;ms <= m;ns ++, ms++) {\n            c *= ns;\n            c /= ms;\n        }\n        return c;\n    }\n    long modnCm(long n, long m, long mod) {\n        if(n < m) return 0l;\n        long upper = 1l;\n        long downer = 1l;\n        m = (n - m < m ? n - m : m);\n        for(long ns = n - m + 1, ms = 1;ms <= m;ns ++, ms++) {\n            upper = upper * ns % mod;\n            downer = downer * ms % mod;\n        }\n        return upper * modInv(downer, mod) % mod;\n    }\n    long modInv(long a, long m) {\n        long b = m, u = 1, v = 0;\n        while(b > 0) {\n            long t = a / b;\n            a -= t * b;\n            long tmp = a;\n            a = b;\n            b = tmp;\n            u -= t * v;\n            tmp = u;\n            u = v;\n            v = tmp;\n        }\n        u %= m;\n        if (u < 0) u += m;\n        return u;\n    }\n    long modPow(long a, long n, long mod) {\n        long res = 1l;\n        while(n > 0l) {\n            if(n % 2l == 1l) res = res * a % mod;\n            a = a * a % mod;\n            n /= 2l;\n        }\n        return res;\n    }\n}\nclass UnionFind {\n    private int[] parent;\n    UnionFind(int n) {\n        parent = new int[n];\n        for(int i = 0;i < n;i++) parent[i] = i;\n    }\n    public int rootOf(int x) {\n        if(parent[x] == x) return x;\n        else return parent[x] = rootOf(parent[x]);\n    }\n    public boolean same(int x, int y) {\n        return rootOf(x) == rootOf(y);\n    }\n    public void unite(int x, int y) {\n        x = rootOf(x);\n        y = rootOf(y);\n        if(x == y) return;\n        parent[x] = y;\n        return;\n    }\n}\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() { return Double.parseDouble(next());}\n}",
        "error_desc": "No error."
    }
]