[
    {
        "problem_id": "p02594",
        "question": "Score : 100 points\n\nProblem StatementYou will turn on the air conditioner if, and only if, the temperature of the room is 30 degrees Celsius or above.\nThe current temperature of the room is X degrees Celsius. Will you turn on the air conditioner?\n\nConstraints\n-40 \\leq X \\leq 40\nX is an integer.\n\nInputInput is given from Standard Input in the following format:\nX\n\nOutputPrint Yes if you will turn on the air conditioner; print No otherwise.\n\nSample Input 125\n\nSample Output 1No\n\nSample Input 230\n\nSample Output 2Yes",
        "desc": "This C++ problem evaluates the ability to perform input/output operations and apply conditional statements to make decisions based on numerical comparisons. It is classified as an easy-level question, suitable for beginners practicing basic programming fundamentals.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main () {\n    int X;\n    cin >> X;\n    if (X>=30) {\n        cout << \"Yes\" << endl;\n    }\n    else {\n        cout << \"No\" << endl;\n    }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02595",
        "question": "Score : 200 points\n\nProblem StatementWe have N points in the two-dimensional plane. The coordinates of the i-th point are (X_i,Y_i).\nAmong them, we are looking for the points such that the distance from the origin is at most D. How many such points are there?\nWe remind you that the distance between the origin and the point (p, q) can be represented as \\sqrt{p^2+q^2}.\n\nConstraints\n1 \\leq N \\leq 2\\times 10^5\n0 \\leq D \\leq 2\\times 10^5\n|X_i|,|Y_i| \\leq 2\\times 10^5\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nN D\nX_1 Y_1\n\\vdots\nX_N Y_N\n\nOutputPrint an integer representing the number of points such that the distance from the origin is at most D.\n\nSample Input 14 5\n0 5\n-2 4\n3 4\n4 -4\n\nSample Output 13\n\nThe distance between the origin and each of the given points is as follows:\n\n\\sqrt{0^2+5^2}=5\n\\sqrt{(-2)^2+4^2}=4.472\\ldots\n\\sqrt{3^2+4^2}=5\n\\sqrt{4^2+(-4)^2}=5.656\\ldots\n\nThus, we have three points such that the distance from the origin is at most 5.\n\nSample Input 212 3\n1 1\n1 1\n1 1\n1 1\n1 2\n1 3\n2 1\n2 2\n2 3\n3 1\n3 2\n3 3\n\nSample Output 27\n\nMultiple points may exist at the same coordinates.\n\nSample Input 320 100000\n14309 -32939\n-56855 100340\n151364 25430\n103789 -113141\n147404 -136977\n-37006 -30929\n188810 -49557\n13419 70401\n-88280 165170\n-196399 137941\n-176527 -61904\n46659 115261\n-153551 114185\n98784 -6820\n94111 -86268\n-30401 61477\n-55056 7872\n5901 -163796\n138819 -185986\n-69848 -96669\n\nSample Output 36",
        "desc": "This C++ problem requires counting how many of up to 200,000 two-dimensional points lie within a specified Euclidean distance from the origin, testing concepts such as efficient iteration, distance calculation, and handling large inputs. It is considered to have a medium to high difficulty level.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main () {\n    int N, D;\n    cin >> N >> D;\n    vector <int> vec(N);\n    for (int i=0; i<N; i++) {\n        cin >> vec.at(i);\n    }\n    vector <int> date(N);\n    for (int i=0; i<N; i++) {\n        cin >> date.at(i);\n    }\n    int count=0;\n    for (int i=0; i<N; i++) {\n        if (sqrt(vec.at(i)*vec.at(i)+date.at(i)*date.at(i)))<=D) {\n            count++;\n        }\n    }\n    cout << count << endl;\n}",
        "error_desc": "1. There is an extra closing parenthesis in the `if` statement, causing a syntax error.\n2. The comparison operator `<= D` is placed outside the `sqrt` function's parentheses.\n3. The variables `vec` and `date` are used to store X and Y coordinates separately, which can lead to confusion.\n4. Using `int` for coordinates may cause integer overflow when squaring large values."
    },
    {
        "problem_id": "p02596",
        "question": "Score : 300 points\n\nProblem StatementTakahashi loves the number 7 and multiples of K.\nWhere is the first occurrence of a multiple of K in the sequence 7,77,777,\\ldots? (Also see Output and Sample Input/Output below.)\nIf the sequence contains no multiples of K, print -1 instead.\n\nConstraints\n1 \\leq K \\leq 10^6\nK is an integer.\n\nInputInput is given from Standard Input in the following format:\nK\n\nOutputPrint an integer representing the position of the first occurrence of a multiple of K. (For example, if the first occurrence is the fourth element of the sequence, print 4.)\n\nSample Input 1101\n\nSample Output 14\n\nNone of 7, 77, and 777 is a multiple of 101, but 7777 is.\n\nSample Input 22\n\nSample Output 2-1\n\nAll elements in the sequence are odd numbers; there are no multiples of 2.\n\nSample Input 3999983\n\nSample Output 3999982",
        "desc": "This C++ problem requires finding the first position in a sequence of numbers composed of repeated digit '7' that is divisible by a given integer K, testing concepts such as modular arithmetic, number construction without overflow, and efficient search techniques. It is categorized as a medium to hard difficulty level problem due to the need for optimized algorithms to handle large values of K (up to 10⁶).",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main () {\n    int K;\n    cin >> K;\n    if (K%2==0) {\n        cout << \"-1\" << endl;\n    }\n    else {\n        for (int i=7;; i+=7) {\n            if (i%K==0) {\n                int cnt=0;\n                for (int j=K; j>0; j/=10) {\n                    cnt+=j%10;\n                }\n                cout << cnt/7 << endl;\n                break;\n            }\n            i*=10;       \n        }\n    }\n}",
        "error_desc": "1. The loop incorrectly modifies `i` by both adding 7 and multiplying by 10, which does not generate the proper sequence of 7, 77, 777, etc.\n2. The position is wrongly calculated by summing the digits of `K` and dividing by 7 instead of tracking the number of digits in the sequence.\n3. The program does not handle cases where no multiple of `K` exists in the sequence beyond checking if `K` is even."
    },
    {
        "problem_id": "p03106",
        "question": "Score : 200 points\n\nProblem StatementYou are given positive integers A and B.\nFind the K-th largest positive integer that divides both A and B.\nThe input guarantees that there exists such a number.\n\nConstraints\nAll values in input are integers.\n1 \\leq A, B \\leq 100\nThe K-th largest positive integer that divides both A and B exists.\nK \\geq 1\n\nInputInput is given from Standard Input in the following format:\nA B K\n\nOutputPrint the K-th largest positive integer that divides both A and B.\n\nSample Input 18 12 2\n\nSample Output 12\n\nThree positive integers divides both 8 and 12: 1, 2 and 4.\nAmong them, the second largest is 2.\n\nSample Input 2100 50 4\n\nSample Output 25\n\nSample Input 31 1 1\n\nSample Output 31",
        "desc": "This C++ problem asks for finding the K-th largest common divisor of two given integers, testing concepts such as determining common factors and implementing sorting or ordered selection. It is considered to be of moderate difficulty.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main () {\n    int A, B, K;\n    cin >> A >> B >> K;\n    int small= min (A, B);\n    int saidaikouyakusuu;\n    for (int i=small; i>=1; i--) {\n        if (i%A==0 && i%B==0) {\n             saidaikouyakusuu=i;\n            int count=0;\n            for (int j=1; j<=saidaikouyakusuu; j++) {\n                if (saidaikouyakusuu%j==0 ) {\n                    count++;\n                    if (count==K){\n                        cout << j << endl;\n                    }\n                }\n            }\n        }\n    }\n}",
        "error_desc": "1. The condition `i%A==0 && i%B==0` is incorrect; it should be `A%i == 0 && B%i == 0` to check if `i` divides both `A` and `B`.\n2. The variable `count` is reset inside the loop for each common divisor, preventing proper counting of the K-th largest divisor.\n3. The program incorrectly uses a nested loop to count divisors of `i` instead of tracking the K-th common divisor directly.\n4. The program may output multiple values since it doesn't terminate after finding the K-th largest common divisor."
    },
    {
        "problem_id": "p02848",
        "question": "Score : 200 points\n\nProblem StatementWe have a string S consisting of uppercase English letters. Additionally, an integer N will be given.\nShift each character of S by N in alphabetical order (see below), and print the resulting string.\nWe assume that A follows Z. For example, shifting A by 2 results in C (A \\to B \\to C), and shifting Y by 3 results in B (Y \\to Z \\to A \\to B).\n\nConstraints\n0 \\leq N \\leq 26\n1 \\leq |S| \\leq 10^4\nS consists of uppercase English letters.\n\nInputInput is given from Standard Input in the following format:\nN\nS\n\nOutputPrint the string resulting from shifting each character of S by N in alphabetical order.\n\nSample Input 12\nABCXYZ\n\nSample Output 1CDEZAB\n\nNote that A follows Z.\n\nSample Input 20\nABCXYZ\n\nSample Output 2ABCXYZ\n\nSample Input 313\nABCDEFGHIJKLMNOPQRSTUVWXYZ\n\nSample Output 3NOPQRSTUVWXYZABCDEFGHIJKLM",
        "desc": "This C++ problem assesses string manipulation and character arithmetic, specifically shifting uppercase letters with wrap-around using modular operations. It is classified as a medium difficulty level, suitable for programmers with intermediate knowledge of string handling and basic algorithm implementation.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main () {\n    int N;\n    cin >> N;\n    string alphabet=ABCDEFGHIJKLMNOPQRSTUVWXYZ;\n    string S;\n    cin >> S;\n    for (int i=0; i<S.size(); i++) {\n        for (int j=0; j<26; j++) {\n            if (alphabet.at(i)==S.at(j)) {\n                cout << (alphabet.at(j+N))%26;\n            }\n        }\n    }\n    cout << endl;\n}",
        "error_desc": "1. Missing quotation marks around the string `ABCDEFGHIJKLMNOPQRSTUVWXYZ`.\n2. Incorrectly using index `i` instead of `j` when accessing `alphabet` in the condition `alphabet.at(i) == S.at(j)`.\n3. Accessing `S.at(j)` instead of `S.at(i)` inside the loop.\n4. Potential out-of-bounds access by using `alphabet.at(j+N)` without handling wrap-around.\n5. Misuse of the modulo operator on a character in `cout << (alphabet.at(j+N))%26`."
    },
    {
        "problem_id": "p03281",
        "question": "Score: 200 points\n\nProblem Statement\nThe number 105 is quite special - it is odd but still it has eight divisors.\nNow, your task is this: how many odd numbers with exactly eight positive divisors are there between 1 and N (inclusive)?\n\nConstraints\n\nN is an integer between 1 and 200 (inclusive).\n\nInput\nInput is given from Standard Input in the following format:\nN\n\nOutput\nPrint the count.\n\nSample Input 1105\n\nSample Output 11\n\nAmong the numbers between 1 and 105, the only number that is odd and has exactly eight divisors is 105.\n\nSample Input 27\n\nSample Output 20\n\n1 has one divisor. 3, 5 and 7 are all prime and have two divisors. Thus, there is no number that satisfies the condition.",
        "desc": "This C++ problem requires understanding of number theory concepts such as divisor counting and prime factorization to identify odd numbers with exactly eight divisors within a range. It is classified as medium difficulty, testing the ability to implement efficient iteration and conditional logic within given constraints.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main () {\n    int N;\n    cin >> N;\n    int bread;\n    if (N%2==0) {\n        bread=N-1;\n    }\n    else {\n        bread=N;\n    }\n    int kaage=0;\n    int define=0;\n    for (int i=1; i<bread; i+=2) {\n        for (int j=1; j<bread+1; j++) {\n            if (i%j==0) {\n                kaage++;\n            }\n            else if (j==i-1 && kaage!=8) {\n                kaage=0;\n            }\n        }\n        if (j==i-1 && kaage==8) {\n            define++;\n        }\n    }\n    cout << define << endl;\n}\n            }",
        "error_desc": "1. Variable `j` is used outside its scope in the `if (j==i-1 && kaage==8)` statement after the inner loop.\n2. There is an extra closing brace at the end of the code, causing a syntax error.\n3. The loop condition `i < bread` excludes the case when `i` equals `bread`, potentially missing the number `N` if it is odd.\n4. The divisor count `kaage` is not reset to zero at the start of each outer loop iteration.\n5. The condition `j == i-1` incorrectly attempts to check the end of the loop instead of verifying if exactly eight divisors were found."
    },
    {
        "problem_id": "p03086",
        "question": "Score : 200 points\n\nProblem StatementYou are given a string S consisting of uppercase English letters. Find the length of the longest ACGT string that is a substring (see Notes) of S.\nHere, a ACGT string is a string that contains no characters other than A, C, G and T.\n\nNotesA substring of a string T is a string obtained by removing zero or more characters from the beginning and the end of T.\nFor example, the substrings of ATCODER include TCO, AT, CODER, ATCODER and  (the empty string), but not AC.\n\nConstraints\nS is a string of length between 1 and 10 (inclusive).\nEach character in S is an uppercase English letter.\n\nInputInput is given from Standard Input in the following format:\nS\n\nOutputPrint the length of the longest ACGT string that is a substring of S.\n\nSample Input 1ATCODER\n\nSample Output 13\n\nAmong the ACGT strings that are substrings of ATCODER, the longest one is ATC.\n\nSample Input 2HATAGAYA\n\nSample Output 25\n\nAmong the ACGT strings that are substrings of HATAGAYA, the longest one is ATAGA.\n\nSample Input 3SHINJUKU\n\nSample Output 30\n\nAmong the ACGT strings that are substrings of SHINJUKU, the longest one is  (the empty string).",
        "desc": "This problem assesses knowledge of string manipulation, substring extraction, and character filtering in C++. It is classified as a medium difficulty challenge, requiring the ability to iterate through the string to identify and determine the longest contiguous substring containing only the characters A, C, G, and T.",
        "program": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    string S;\n    cin >> S;\n    vector<int> count(10);\n    int ans = 0;\n    for(int i = 0; i < S.size(); i++){\n        int pre = 0;\n        if(S[i] == 'A' || S[i] == 'T' || S[i] == 'G' || S[i] == 'C'){\n            pre++;\n            for(int j = 1; j < S.size(); j++){\n                if(S[i+j] == 'A' || S[i+j] == 'T' || S[i+j] == 'G' || S[i+j] == 'C'){\n                    pre++;\n                }\n                else{\n                    break;\n                }\n           }\n      }\n       ans = max(ans, pre);\n       cout << ans << endl;\n}",
        "error_desc": "1. The inner loop does not check if `i + j` exceeds the string size, causing potential out-of-bounds access.\n2. The `cout << ans << endl;` statement is inside the main loop, resulting in multiple outputs instead of a single final answer.\n3. The `vector<int> count(10);` is declared but never utilized in the code."
    },
    {
        "problem_id": "p02754",
        "question": "Score : 200 points\n\nProblem StatementTakahashi has many red balls and blue balls. Now, he will place them in a row.\nInitially, there is no ball placed.\nTakahashi, who is very patient, will do the following operation 10^{100} times:\n\nPlace A blue balls at the end of the row of balls already placed. Then, place B red balls at the end of the row.\n\nHow many blue balls will be there among the first N balls in the row of balls made this way?\n\nConstraints\n1 \\leq N \\leq 10^{18}\nA, B \\geq 0\n0 &lt; A + B \\leq 10^{18}\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nN A B\n\nOutputPrint the number of blue balls that will be there among the first N balls in the row of balls.\n\nSample Input 18 3 4\n\nSample Output 14\n\nLet b denote a blue ball, and r denote a red ball. The first eight balls in the row will be bbbrrrrb, among which there are four blue balls.\n\nSample Input 28 0 4\n\nSample Output 20\n\nHe placed only red balls from the beginning.\n\nSample Input 36 2 4\n\nSample Output 32\n\nAmong bbrrrr, there are two blue balls.",
        "desc": "This C++ problem assesses the ability to handle large integers and apply mathematical concepts like cycle computation and integer division to efficiently determine the count of specific elements within a sequence. With high constraints (N up to 10¹⁸) and requiring optimal algorithm design, it is classified as a medium to hard difficulty level.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main () {\n    int n, b, r;\n    cin >> n >> b >> r;\n    int group=b+r;\n    if (n%group<=b) {\n        cout << n/group*b+n%group << endl;\n    }\n    else {\n        cout << n/group*b+b << endl;\n    }\n}",
        "error_desc": "1. Variables `n`, `b`, and `r` are declared as `int` instead of `long long`, causing overflow for large input values.\n2. The `group` variable is also declared as `int`, which cannot accommodate the sum of `b` and `r` when they are large.\n3. The expression `n/group*b + n%group` may result in incorrect calculations due to integer overflow and insufficient data type size."
    },
    {
        "problem_id": "p03448",
        "question": "Score : 200 points\n\nProblem StatementYou have A 500-yen coins, B 100-yen coins and C 50-yen coins (yen is the currency of Japan).\nIn how many ways can we select some of these coins so that they are X yen in total?\nCoins of the same kind cannot be distinguished. Two ways to select coins are distinguished when, for some kind of coin, the numbers of that coin are different.\n\nConstraints\n0 \\leq A, B, C \\leq 50\nA + B + C \\geq 1\n50 \\leq X \\leq 20 000\nA, B and C are integers.\nX is a multiple of 50.\n\nInputInput is given from Standard Input in the following format:\nA\nB\nC\nX\n\nOutputPrint the number of ways to select coins.\n\nSample Input 12\n2\n2\n100\n\nSample Output 12\n\nThere are two ways to satisfy the condition:\n\nSelect zero 500-yen coins, one 100-yen coin and zero 50-yen coins.\nSelect zero 500-yen coins, zero 100-yen coins and two 50-yen coins.\n\nSample Input 25\n1\n0\n150\n\nSample Output 20\n\nNote that the total must be exactly X yen.\n\nSample Input 330\n40\n50\n6000\n\nSample Output 3213",
        "desc": "This C++ problem assesses the ability to implement combinatorial enumeration and utilize nested loops or dynamic programming to count the number of distinct ways to reach a specific sum using limited quantities of different coin denominations. It is classified as a medium-difficulty problem, suitable for testing fundamental algorithmic and problem-solving skills.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main () {\n    int A, B, C, X;\n    cin >> A >> B >> C >> X;\n    int count=0;\n    for (int i=0; i<=A; i++) {\n        for (int j=0; j<=B; j++) {\n            for (int k=0; k<=C; k++) {\n                if (i*500+j*100+k*50==X) {\n                    count++;\n                }\n            }\n        }\n    }\n    cout << count << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p03478",
        "question": "Score : 200 points\n\nProblem StatementFind the sum of the integers between 1 and N (inclusive), whose sum of digits written in base 10 is between A and B (inclusive).\n\nConstraints\n1 \\leq N \\leq 10^4\n1 \\leq A \\leq B \\leq 36\nAll input values are integers.\n\nInputInput is given from Standard Input in the following format:\nN A B\n\nOutputPrint the sum of the integers between 1 and N (inclusive), whose sum of digits written in base 10 is between A and B (inclusive).\n\nSample Input 120 2 5\n\nSample Output 184\n\nAmong the integers not greater than 20, the ones whose sums of digits are between 2 and 5, are: 2,3,4,5,11,12,13,14 and 20. We should print the sum of these, 84.\n\nSample Input 210 1 2\n\nSample Output 213\n\nSample Input 3100 4 16\n\nSample Output 34554",
        "desc": "This C++ problem requires iterating through integers up to N, calculating each number’s digit sum in base 10, and summing those numbers whose digit sums fall within the range [A, B]. It tests fundamental concepts such as loops, digit manipulation, and conditional logic, and is categorized as a medium-difficulty problem.",
        "program": "#include <bits/stdc++.h>\nusing namespace std;\nint main () {\n    int N, A, B;\n    cin >> N >> A >> B;\n    int count=0;\n    int sum=0;\n    for (int i=1; i<=N; i++) {\n        for (int k=i; k>0; k/=10) {\n            count+=k%10;\n            if (count>=A && count<=B) {\n                sum+=count;\n            }\n        }\n    }\n    cout << sum << endl;\n}",
        "error_desc": "1. The `count` variable is not reset to zero for each new integer `i`, causing incorrect cumulative digit sums.\n2. The program adds `count` (the digit sum) to `sum` instead of adding the integer `i` when the digit sum is within the range.\n3. The condition to check if the digit sum is between `A` and `B` is placed inside the digit processing loop, leading to multiple incorrect additions for each number."
    }
]