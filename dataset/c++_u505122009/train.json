[
    {
        "problem_id": "p02684",
        "question": "Score: 400 points\n\nProblem Statement\nThe Kingdom of Takahashi has N towns, numbered 1 through N.\nThere is one teleporter in each town. The teleporter in Town i (1 \\leq i \\leq N) sends you to Town A_i.\nTakahashi, the king, loves the positive integer K. The selfish king wonders what town he will be in if he starts at Town 1 and uses a teleporter exactly K times from there.\nHelp the king by writing a program that answers this question.\n\nConstraints\n\n2 \\leq N \\leq 2 \\times 10^5\n1 \\leq A_i \\leq N\n1 \\leq K \\leq 10^{18}\n\nInput\nInput is given from Standard Input in the following format:\nN K\nA_1 A_2 \\dots A_N\n\nOutput\nPrint the integer representing the town the king will be in if he starts at Town 1 and uses a teleporter exactly K times from there.\n\nSample Input 14 5\n3 2 4 1\n\nSample Output 14\n\nIf we start at Town 1 and use the teleporter 5 times, our travel will be as follows: 1 \\to 3 \\to 4 \\to 1 \\to 3 \\to 4.\n\nSample Input 26 727202214173249351\n6 5 2 5 3 2\n\nSample Output 22",
        "desc": "The problem asks for the town reached after exactly K teleporter jumps starting from Town 1, where each town directs to another via a predefined array A. It tests concepts like cycle detection and efficient computation techniques (such as binary lifting) to handle large K values, and is classified as a high-difficulty (400 points) C++ programming challenge.",
        "program": "#include <iostream>\n#include <cassert>\nusing namespace std;\nint A[2 * 100000];\nint visited[2 * 100000];\nint main() {\n  int N;\n  long long K;\n  cin >> N >> K;\n  for (int i = 0; i < N; ++i) {\n    cin >> A[i];\n  }\n  int city = 0;\n  int cycle_start = -1;\n  int cycle_length = -1;\n  for (int i = 0; i < N; ++i) {\n    visited[i] = -1;\n  }\n  visited[0] = 0;\n  for (int i = 0; i < N; ++i) {\n    city = A[city] - 1;\n    if (visited[city] != -1) {\n      cycle_start = visited[city];\n      cycle_length = i + 1 - visited[city];\n      break;\n    }\n    visited[city] = i + 1;\n  }\n  assert(cycle_start != -1);\n  if (K >= cycle_start) {\n    K = (K - cycle_start) % cycle_length + cycle_start;\n  }\n  int c = 0;\n  for (int k = 0; k < K; ++k) {\n    c = A[c] - 1;\n  }\n  cout << c + 1 << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02683",
        "question": "Score : 300 points\n\nProblemTakahashi, who is a novice in competitive programming, wants to learn M algorithms.\nInitially, his understanding level of each of the M algorithms is 0.\nTakahashi is visiting a bookstore, where he finds N books on algorithms.\nThe i-th book (1\\leq i\\leq N) is sold for C_i yen (the currency of Japan). If he buys and reads it, his understanding level of the j-th algorithm will increase by A_{i,j} for each j (1\\leq j\\leq M).\nThere is no other way to increase the understanding levels of the algorithms.\nTakahashi's objective is to make his understanding levels of all the M algorithms X or higher. Determine whether this objective is achievable. If it is achievable, find the minimum amount of money needed to achieve it.\n\nConstraints\nAll values in input are integers.\n1\\leq N, M\\leq 12\n1\\leq X\\leq 10^5\n1\\leq C_i \\leq 10^5\n0\\leq A_{i, j} \\leq 10^5\n\nInputInput is given from Standard Input in the following format:\nN M X\nC_1 A_{1,1} A_{1,2} \\cdots A_{1,M}\nC_2 A_{2,1} A_{2,2} \\cdots A_{2,M}\n\\vdots\nC_N A_{N,1} A_{N,2} \\cdots A_{N,M}\n\nOutputIf the objective is not achievable, print -1; otherwise, print the minimum amount of money needed to achieve it.\n\nSample Input 13 3 10\n60 2 2 4\n70 8 7 9\n50 2 3 9\n\nSample Output 1120\n\nBuying the second and third books makes his understanding levels of all the algorithms 10 or higher, at the minimum cost possible.\n\nSample Input 23 3 10\n100 3 1 4\n100 1 5 9\n100 2 6 5\n\nSample Output 2-1\n\nBuying all the books is still not enough to make his understanding levels of all the algorithms 10 or higher.\n\nSample Input 38 5 22\n100 3 7 5 3 1\n164 4 5 2 7 8\n334 7 2 7 2 9\n234 4 7 2 8 2\n541 5 4 3 3 6\n235 4 8 6 9 7\n394 3 6 1 6 2\n872 8 4 3 7 2\n\nSample Output 31067",
        "desc": "This C++ problem assesses knowledge of combinatorial optimization and subset selection, requiring the determination of the minimal cost combination of books to achieve specified algorithm understanding levels. With constraints allowing up to 12 books and algorithms, it is categorized as a medium to hard difficulty level in competitive programming.",
        "program": "#include <iostream>\nusing namespace std;\nint C[12];\nint A[12][12];\nint main() {\n  int N, M, X;\n  cin >> N >> M >> X;\n  for (int i = 0; i < N; ++i) {\n    cin >> C[i];\n    for (int j = 0; j < M; ++j) {\n      cin >> A[i][j];\n    }\n  }\n  int min = -1;\n  for (int i = 0; i < (1 << N); ++i) {\n    int cost = 0;\n    int a[12];\n    for (int j = 0; j < 12; ++j) {\n      a[j] = 0;\n    }\n    for (int j = 0; j < N; ++j) {\n      if ((i >> j) & 1) {\n        cost += C[j];\n        for (int k = 0; k < M; ++k) {\n          a[k] += A[j][k];\n        }\n      }\n    }\n    bool ok = true;\n    for (int j = 0; j < M; ++j) {\n      if (a[j] < X) {\n        ok = false;\n      }\n    }\n    if (ok && (min == -1 || min > cost)) {\n      min = cost;\n    }\n  }\n  cout << min << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02682",
        "question": "Score : 200 points\n\nProblem StatementWe have A cards, each of which has an integer 1 written on it. Similarly, we also have B cards with 0s and C cards with -1s.\nWe will pick up K among these cards. What is the maximum possible sum of the numbers written on the cards chosen?\n\nConstraints\nAll values in input are integers.\n0 \\leq A, B, C\n1 \\leq K \\leq A + B + C \\leq 2 \\times 10^9\n\nInputInput is given from Standard Input in the following format:\nA B C K\n\nOutputPrint the maximum possible sum of the numbers written on the cards chosen.\n\nSample Input 12 1 1 3\n\nSample Output 12\n\nConsider picking up two cards with 1s and one card with a 0.\nIn this case, the sum of the numbers written on the cards is 2, which is the maximum possible value.\n\nSample Input 21 2 3 4\n\nSample Output 20\n\nSample Input 32000000000 0 0 2000000000\n\nSample Output 32000000000",
        "desc": "This C++ problem involves selecting **K** cards from three groups containing **A** cards with `1`, **B** cards with `0`, and **C** cards with `-1` to maximize the total sum. It tests understanding of greedy algorithms and efficient computation with large numerical constraints, and is classified as a **medium difficulty** level problem.",
        "program": "#include <iostream>\nusing namespace std;\nint main() {\n  int A, B, C, K;\n  cin >> A >> B >> C >> K;\n  if (K <= A) {\n    cout << K << endl;\n  } else if (K <= B) {\n    cout << A << endl;\n  } else {\n    cout << A - (K - A - B) << endl;\n  }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02681",
        "question": "Score : 100 points\n\nProblem StatementTakahashi wants to be a member of some web service.\nHe tried to register himself with the ID S, which turned out to be already used by another user.\nThus, he decides to register using a string obtained by appending one character at the end of S as his ID.\nHe is now trying to register with the ID T. Determine whether this string satisfies the property above.\n\nConstraints\nS and T are strings consisting of lowercase English letters.\n1 \\leq |S| \\leq 10\n|T| = |S| + 1\n\nInputInput is given from Standard Input in the following format:\nS\nT\n\nOutputIf T satisfies the property in Problem Statement, print Yes; otherwise, print No.\n\nSample Input 1chokudai\nchokudaiz\n\nSample Output 1Yes\n\nchokudaiz can be obtained by appending z at the end of chokudai.\n\nSample Input 2snuke\nsnekee\n\nSample Output 2No\n\nsnekee cannot be obtained by appending one character at the end of snuke.\n\nSample Input 3a\naa\n\nSample Output 3Yes",
        "desc": "This C++ problem assesses the ability to manipulate and compare strings, specifically by checking if one string is formed by appending a single character to another. It tests fundamental string operations and conditional logic, and is considered to have an easy difficulty level.",
        "program": "#include <iostream>\nusing namespace std;\nint main() {\n  string S, T;\n  cin >> S >> T;\n  if (S.size() + 1 == T.size() &&\n      T.substr(S.size()) == S) {\n    cout << \"Yes\" << endl;\n  } else {\n    cout << \"No\"<< endl;\n  }\n}",
        "error_desc": "1. The condition `T.substr(S.size()) == S` incorrectly compares the substring from the end of `T` with the entire string `S` instead of comparing the prefix of `T` with `S`.\n2. The program fails to verify that the appended character is exactly one character, leading to incorrect comparisons."
    },
    {
        "problem_id": "p02691",
        "question": "Score: 500 points\n\nProblem Statement\nYou are the top spy of AtCoder Kingdom. To prevent the stolen secret from being handed to AlDebaran Kingdom, you have sneaked into the party where the transaction happens.\nThere are N attendees in the party, and they are given attendee numbers from 1 through N. The height of Attendee i is A_i.\nAccording to an examination beforehand, you know that a pair of attendees satisfying the condition below will make the transaction.\n\nThe absolute difference of their attendee numbers is equal to the sum of their heights.\n\nThere are \\frac{N(N-1)}{2} ways to choose two from the N attendees and make a pair. Among them, how many satisfy the condition above?\nP.S.: We cannot let you know the secret.\n\nConstraints\n\nAll values in input are integers.\n2 \\leq N \\leq 2 \\times 10^5\n1 \\leq A_i \\leq 10^9\\ (1 \\leq i \\leq N)\n\nInput\nInput is given from Standard Input in the following format:\nN\nA_1 A_2 \\dots A_N\n\nOutput\nPrint the number of pairs satisfying the condition.\n\nSample Input 16\n2 3 3 1 3 1\n\nSample Output 13\n\nA_1 + A_4 = 3, so the pair of Attendee 1 and 4 satisfy the condition.\nA_2 + A_6 = 4, so the pair of Attendee 2 and 6 satisfy the condition.\nA_4 + A_6 = 2, so the pair of Attendee 4 and 6 satisfy the condition.\n\nNo other pair satisfies the condition, so you should print 3.\n\nSample Input 26\n5 2 4 2 8 8\n\nSample Output 20\n\nNo pair satisfies the condition, so you should print 0.\n\nSample Input 332\n3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 2 3 8 4 6 2 6 4 3 3 8 3 2 7 9 5\n\nSample Output 322",
        "desc": "This problem asks for the number of attendee pairs where the absolute difference of their indices equals the sum of their heights, requiring efficient handling of large datasets and optimized pair-counting techniques. It tests knowledge of hash maps or frequency counting and is categorized as a hard-level C++ programming challenge.",
        "program": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <map>\nusing namespace std;\nstruct SegmentTree {\n  SegmentTree(int n) : n_(n) {\n    int twos = 1;\n    while (twos < n) twos <<= 1;\n    v_.resize(twos * 2 - 1);\n  }\n  int parent(int node) {\n    assert(node > 0);\n    return (node - 1) / 2;\n  }\n  int left(int node) {\n    return node * 2 + 1;\n  }\n  int right(int node) {\n    return node * 2 + 2;\n  }\n  void Increment(int pos, int val) {\n    int index = v_.size() / 2 + pos;\n    while (true) {\n      v_[index][val]++;\n      if (index == 0) {\n        break;\n      }\n      index = (index - 1) / 2;\n    }\n  }\n  int Count(int begin, int end, int x) {\n    return doCount(begin, end, x, 0, 0, n_);\n  }\n  int doCount(int begin, int end, int x, int node, int node_begin, int node_end) {\n    if (node_begin <= begin && end <= node_end) {\n      return v_[node][x];\n    }\n    if (end <= node_begin || node_end <= begin) {\n      return 0;\n    }\n    int mid = (node_begin + node_end) / 2;\n    return doCount(begin, end, x, left(node), node_begin, mid) +\n        doCount(begin, end, x, right(node), mid, node_end);\n  }\n  int n_;\n  vector<map<int, int>> v_;\n};\nint A[2 * 100000];\nint main() {\n  int N;\n  cin >> N;\n  SegmentTree tree(N);\n  for (int i = 0; i < N; ++i) {\n    cin >> A[i];\n    tree.Increment(i, A[i] - i);\n  }\n  int count = 0;\n  for (int i = 0; i < N; ++i) {\n    count += tree.Count(i + 1, N, -A[i] - i);\n  }\n  cout << count << endl;\n}",
        "error_desc": "1. The attendee numbers in the problem start from 1, but the code uses 0-based indexing, causing incorrect calculations.\n2. The `SegmentTree` increments with `A[i] - i` instead of considering the sum `A[i] + i` as required by the condition.\n3. The `Count` function searches for `-A[i] - i`, which does not correctly represent the condition `|i - j| = A_i + A_j`.\n4. The condition for absolute difference is not properly implemented, leading to incorrect pair counting.\n5. The array `A` is declared with a size of `2 * 100000`, which may not accommodate the maximum value of `N` (2 × 10⁵) properly."
    },
    {
        "problem_id": "p02690",
        "question": "Score : 400 points\n\nProblem StatementGive a pair of integers (A, B) such that A^5-B^5 = X.\nIt is guaranteed that there exists such a pair for the given integer X.\n\nConstraints\n1 \\leq X \\leq 10^9\nX is an integer.\nThere exists a pair of integers (A, B) satisfying the condition in Problem Statement.\n\nInputInput is given from Standard Input in the following format:\nX\n\nOutputPrint A and B, with space in between.\nIf there are multiple pairs of integers (A, B) satisfying the condition, you may print any of them.\nA B\n\nSample Input 133\n\nSample Output 12 -1\n\nFor A=2 and B=-1, A^5-B^5 = 33.\n\nSample Input 21\n\nSample Output 20 -1",
        "desc": "This C++ problem requires finding integer pairs (A, B) such that A⁵ minus B⁵ equals a given X, testing concepts like exponentiation, efficient searching algorithms, and integer manipulation. It is classified as a challenging, high-difficulty (400-point) problem.",
        "program": "#include <iostream>\nusing namespace std;\nlong long pow5(long long x) {\n  return x * x * x * x * x;\n}\nint main() {\n  int X;\n  cin >> X;\n  for (long long A = 1; A <= 150; ++A) {\n    for (long long B = 0; B < A; ++B) {\n      if (pow5(A) + pow5(B) == X) {\n        cout << A << \" \" << -B << endl;\n        return 0;\n      }\n      if (pow5(A) - pow5(B) == X) {\n        cout << A << \" \" << B << endl;\n        return 0;\n      }\n    }\n  }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02689",
        "question": "Score : 300 points\n\nProblem StatementThere are N observatories in AtCoder Hill, called Obs. 1, Obs. 2, ..., Obs. N. The elevation of Obs. i is H_i.\nThere are also M roads, each connecting two different observatories. Road j connects Obs. A_j and Obs. B_j.\nObs. i is said to be good when its elevation is higher than those of all observatories that can be reached from Obs. i using just one road.\nNote that Obs. i is also good when no observatory can be reached from Obs. i using just one road.\nHow many good observatories are there?\n\nConstraints\n2 \\leq N \\leq 10^5\n1 \\leq M \\leq 10^5\n1 \\leq H_i \\leq 10^9\n1 \\leq A_i,B_i \\leq N\nA_i \\neq B_i\nMultiple roads may connect the same pair of observatories.\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nN M\nH_1 H_2 ... H_N\nA_1 B_1\nA_2 B_2\n:\nA_M B_M\n\nOutputPrint the number of good observatories.\n\nSample Input 14 3\n1 2 3 4\n1 3\n2 3\n2 4\n\nSample Output 12\n\nFrom Obs. 1, you can reach Obs. 3 using just one road. The elevation of Obs. 1 is not higher than that of Obs. 3, so Obs. 1 is not good.\n\nFrom Obs. 2, you can reach Obs. 3 and 4 using just one road. The elevation of Obs. 2 is not higher than that of Obs. 3, so Obs. 2 is not good.\n\nFrom Obs. 3, you can reach Obs. 1 and 2 using just one road. The elevation of Obs. 3 is higher than those of Obs. 1 and 2, so Obs. 3 is good.\n\nFrom Obs. 4, you can reach Obs. 2 using just one road. The elevation of Obs. 4 is higher than that of Obs. 2, so Obs. 4 is good.\n\nThus, the good observatories are Obs. 3 and 4, so there are two good observatories.\n\nSample Input 26 5\n8 6 9 1 2 1\n1 3\n4 2\n4 3\n4 6\n4 6\n\nSample Output 23",
        "desc": "The problem requires determining how many observatories have elevations higher than all directly connected neighbors in a large undirected graph, testing knowledge of graph representation and efficient traversal techniques. It is classified as a medium-level C++ problem due to its need for handling up to 10⁵ nodes and edges efficiently.",
        "program": "#include <iostream>\nusing namespace std;\nconst int kMax = 100000;\nint H[kMax];\nint A[kMax];\nint B[kMax];\nbool bad[kMax];\nint main() {\n  int N, M;\n  cin >> N >> M;\n  for (int i = 0; i < N; ++i) {\n    cin >> H[i];\n  }\n  for (int i = 0; i < M; ++i) {\n    cin >> A[i] >> B[i];\n  }\n  for (int i = 0; i < M; ++i) {\n    int a = A[i] - 1;\n    int b = B[i] - 1;\n    if (H[b] < H[a]) {\n      swap(a, b);\n    }\n    if (H[a] < H[b]) {\n      bad[a] = true;\n    }\n    if (H[a] == H[b]) {\n      bad[b] = true;\n    }\n  }\n  int good = 0;\n  for (int i = 0; i < N; ++i) {\n    if (!bad[i]) {\n      ++good;\n    }\n  }\n  cout << good << endl;\n}",
        "error_desc": "1. The code only marks one observatory as bad when two observatories have equal elevations, instead of marking both.\n2. The array size `kMax` is set to 100000, which may lead to out-of-bounds access when `N` is exactly 100000.\n3. The logic incorrectly handles multiple roads between the same pair of observatories, potentially causing incorrect markings in the `bad` array."
    },
    {
        "problem_id": "p02688",
        "question": "Score : 200 points\n\nProblem StatementN Snukes called Snuke 1, Snuke 2, ..., Snuke N live in a town.\nThere are K kinds of snacks sold in this town, called Snack 1, Snack 2, ..., Snack K. The following d_i Snukes have Snack i: Snuke A_{i, 1}, A_{i, 2}, \\cdots, A_{i, {d_i}}.\nTakahashi will walk around this town and make mischief on the Snukes who have no snacks. How many Snukes will fall victim to Takahashi's mischief?\n\nConstraints\nAll values in input are integers.\n1 \\leq N \\leq 100\n1 \\leq K \\leq 100\n1 \\leq d_i \\leq N\n1 \\leq A_{i, 1} &lt; \\cdots &lt; A_{i, d_i} \\leq N\n\nInputInput is given from Standard Input in the following format:\nN K\nd_1\nA_{1, 1} \\cdots A_{1, d_1}\n\\vdots\nd_K\nA_{K, 1} \\cdots A_{K, d_K}\n\nOutputPrint the answer.\n\nSample Input 13 2\n2\n1 3\n1\n3\n\nSample Output 11\n\nSnuke 1 has Snack 1.\nSnuke 2 has no snacks.\nSnuke 3 has Snack 1 and 2.\n\nThus, there will be one victim: Snuke 2.\n\nSample Input 23 3\n1\n3\n1\n3\n1\n3\n\nSample Output 22",
        "desc": "This C++ problem assesses the ability to manipulate arrays or boolean flags to track ownership across multiple groups. It tests fundamental set operations and counting techniques, and is classified as an easy-level challenge.",
        "program": "#include <iostream>\nusing namespace std;\nbool sunuke[100];\nint main() {\n  int N, K;\n  cin >> N >> K;\n  for (int i = 0; i< K; ++i) {\n    int d;\n    cin >> d;\n    for (int j = 0; j < d; ++j) {\n      int A;\n      cin >> A;\n      sunuke[A-1] = true;\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i < N; ++i) {\n    if (!sunuke[i]) {\n      ++ans;\n    }\n  }\n  cout << ans << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02697",
        "question": "Score : 500 points\n\nProblem StatementYou are going to hold a competition of one-to-one game called AtCoder Janken. (Janken is the Japanese name for Rock-paper-scissors.)\nN players will participate in this competition, and they are given distinct integers from 1 through N.\nThe arena has M playing fields for two players. You need to assign each playing field two distinct integers between 1 and N (inclusive).\nYou cannot assign the same integer to multiple playing fields.\nThe competition consists of N rounds, each of which proceeds as follows:\n\nFor each player, if there is a playing field that is assigned the player's integer, the player goes to that field and fight the other player who comes there.\nThen, each player adds 1 to its integer. If it becomes N+1, change it to 1.\n\nYou want to ensure that no player fights the same opponent more than once during the N rounds.\nPrint an assignment of integers to the playing fields satisfying this condition.\nIt can be proved that such an assignment always exists under the constraints given.\n\nConstraints\n1 \\leq M\nM \\times 2 +1 \\leq N \\leq 200000\n\nInputInput is given from Standard Input in the following format:\nN M\n\nOutputPrint M lines in the format below.\nThe i-th line should contain the two integers a_i and b_i assigned to the i-th playing field.\na_1 b_1\na_2 b_2\n:\na_M b_M\n\nSample Input 14 1\n\nSample Output 12 3\n\nLet us call the four players A, B, C, and D, and assume that they are initially given the integers 1, 2, 3, and 4, respectively.\n\nThe 1-st round is fought by B and C, who has the integers 2 and 3, respectively. After this round, A, B, C, and D have the integers 2, 3, 4, and 1, respectively.\n\nThe 2-nd round is fought by A and B, who has the integers 2 and 3, respectively. After this round, A, B, C, and D have the integers 3, 4, 1, and 2, respectively.\n\nThe 3-rd round is fought by D and A, who has the integers 2 and 3, respectively. After this round, A, B, C, and D have the integers 4, 1, 2, and 3, respectively.\n\nThe 4-th round is fought by C and D, who has the integers 2 and 3, respectively. After this round, A, B, C, and D have the integers 1, 2, 3, and 4, respectively.\n\nNo player fights the same opponent more than once during the four rounds, so this solution will be accepted.\n\nSample Input 27 3\n\nSample Output 21 6\n2 5\n3 4",
        "desc": "This problem requires assigning pairs of distinct integers to multiple playing fields to ensure that, over N cyclic rounds where each player’s number increments modulo N, no two players compete against each other more than once. It tests combinatorial assignment, cyclic scheduling, and efficient algorithm design, and is classified as a hard-level C++ programming challenge.",
        "program": "#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\nconst int kMax = 200000;\nbool used[kMax];\nint main() {\n  int N, M;\n  cin >> N >> M;\n  for (int i = 0; i < M; ++i) {\n    for (int j = 0; j < N; ++j) {\n      int k = (j + i + 1);\n      assert(k < N);\n      if (!used[j] && !used[k]) {\n        cout << (j + 1) << \" \" << (k + 1) << endl;\n        used[j] = true;\n        used[k] = true;\n        break;\n      }\n    }\n  }\n}",
        "error_desc": "1. The assertion `assert(k < N)` can fail when `k` equals `N`, causing the program to terminate unexpectedly.\n2. The `used` array is declared with a size of `200000`, which leads to out-of-bounds access when `k` is equal to `200000`.\n3. The logic for calculating `k` as `(j + i + 1)` does not ensure that all required pairs are assigned, potentially leaving some playing fields without valid assignments."
    },
    {
        "problem_id": "p02696",
        "question": "Score : 400 points\n\nProblem StatementGiven are integers A, B, and N.\nFind the maximum possible value of floor(Ax/B) - A × floor(x/B) for a non-negative integer x not greater than N.\nHere floor(t) denotes the greatest integer not greater than the real number t.\n\nConstraints\n1 ≤ A ≤ 10^{6}\n1 ≤ B ≤ 10^{12}\n1 ≤ N ≤ 10^{12}\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nA B N\n\nOutputPrint the maximum possible value of floor(Ax/B) - A × floor(x/B) for a non-negative integer x not greater than N, as an integer.\n\nSample Input 15 7 4\n\nSample Output 12\n\nWhen x=3, floor(Ax/B)-A×floor(x/B) = floor(15/7) - 5×floor(3/7) = 2. This is the maximum value possible.\n\nSample Input 211 10 9\n\nSample Output 29",
        "desc": "This C++ problem challenges programmers to compute the maximum value of the expression ⎣Ax/B⎦ – A × ⎣x/B⎦ for any non-negative integer x up to N, requiring a solid understanding of integer division and floor operations. It tests concepts in number theory and optimization under large constraints, presenting a high difficulty level suitable for advanced competitive programming.",
        "program": "#include <iostream>\nusing namespace std;\nint main() {\n  long long A, B, N;\n  cin >> A >> B >> N;\n  long long x = min(N, B - 1);\n  cout << ((A * x / B) - A * (x / B)) << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02695",
        "question": "Score : 300 points\n\nProblem StatementGiven are positive integers N, M, Q, and Q quadruples of integers ( a_i , b_i , c_i , d_i ).\nConsider a sequence A satisfying the following conditions:\n\nA is a sequence of N positive integers.\n1 \\leq A_1 \\leq A_2 \\le \\cdots \\leq A_N \\leq M.\n\nLet us define a score of this sequence as follows:\n\nThe score is the sum of d_i over all indices i such that A_{b_i} - A_{a_i} = c_i. (If there is no such i, the score is 0.)\n\nFind the maximum possible score of A.\n\nConstraints\nAll values in input are integers.\n2 ≤ N ≤ 10\n1 \\leq M \\leq 10\n1 \\leq Q \\leq 50\n1 \\leq a_i &lt; b_i \\leq N ( i = 1, 2, ..., Q )\n0 \\leq c_i \\leq M - 1 ( i = 1, 2, ..., Q )\n(a_i, b_i, c_i) \\neq (a_j, b_j, c_j) (where i \\neq j)\n1 \\leq d_i \\leq 10^5 ( i = 1, 2, ..., Q )\n\nInputInput is given from Standard Input in the following format:\nN M Q\na_1 b_1 c_1 d_1\n:\na_Q b_Q c_Q d_Q\n\nOutputPrint the maximum possible score of A.\n\nSample Input 13 4 3\n1 3 3 100\n1 2 2 10\n2 3 2 10\n\nSample Output 1110\n\nWhen A = \\{1, 3, 4\\}, its score is 110. Under these conditions, no sequence has a score greater than 110, so the answer is 110.\n\nSample Input 24 6 10\n2 4 1 86568\n1 4 0 90629\n2 3 0 90310\n3 4 1 29211\n3 4 3 78537\n3 4 2 8580\n1 2 1 96263\n1 4 2 2156\n1 2 0 94325\n1 4 3 94328\n\nSample Output 2357500\n\nSample Input 310 10 1\n1 10 9 1\n\nSample Output 31",
        "desc": "This problem involves generating all non-decreasing sequences of length N with elements up to M and selecting the sequence that maximizes a score based on specific difference constraints between elements, effectively testing combinatorial enumeration and optimization skills. It is classified as a high-difficulty C++ programming challenge, suitable for advanced algorithmic problem-solving.",
        "program": "#include <iostream>\n#include <vector>\nusing namespace std;\nint a[50], b[50], c[50], d[50];\nint dfs(int depth, int N, int M, int Q, vector<int>* A) {\n  if (depth == N) {\n    int ret = 0;\n    for (int i = 0; i < Q; ++i) {\n      if ((*A)[b[i] - 1] - (*A)[a[i] - 1] == c[i]) {\n        ret += d[i];\n      }\n    }\n    return ret;\n  }\n  int ret = 0;\n  for (int i = A->empty() ? 1 : A->back(); i <= M; ++i) {\n    A->push_back(i);\n    ret = max(ret, dfs(depth + 1, N, M, Q, A));\n    A->pop_back();\n  }\n  return ret;\n}\nint main() {\n  int N, M, Q;\n  cin >> N >> M >> Q;\n  for (int i = 0; i < Q; ++i) {\n    cin >> a[i] >> b[i] >> c[i] >> d[i];\n  }\n  vector<int> A;\n  cout << dfs(0, N, M, Q, &A) << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02694",
        "question": "Score : 200 points\n\nProblem Statement\nTakahashi has a deposit of 100 yen (the currency of Japan) in AtCoder Bank.\nThe bank pays an annual interest rate of 1 % compounded annually. (A fraction of less than one yen is discarded.)\nAssuming that nothing other than the interest affects Takahashi's balance, in how many years does the balance reach X yen or above for the first time?\n\nConstraints\n\n 101 \\le X \\le 10^{18} \nAll values in input are integers.\n\nInput\nInput is given from Standard Input in the following format:\nX\n\nOutput\nPrint the number of years it takes for Takahashi's balance to reach X yen or above for the first time.\n\nSample Input 1103\n\nSample Output 13\n\nThe balance after one year is 101 yen.\nThe balance after two years is 102 yen.\nThe balance after three years is 103 yen.\n\nThus, it takes three years for the balance to reach 103 yen or above.\n\nSample Input 21000000000000000000\n\nSample Output 23760\n\nSample Input 31333333333\n\nSample Output 31706",
        "desc": "This C++ problem requires implementing a loop to simulate annually compounded interest with integer truncation, handling very large numbers up to 10¹⁸. It tests fundamental programming concepts like iterative calculations and arithmetic operations, and is classified as a medium difficulty level problem.",
        "program": "#include <iostream>\nusing namespace std;\nint main() {\n  int X;\n  cin >> X;\n  long long x = 100;\n  for (int i = 0; ; ++i) {\n    x = x * 101 / 100;\n    if (x >= X) {\n      cout << i + 1 << endl;\n      break;\n    }\n  }\n}",
        "error_desc": "1. The input variable `X` is declared as `int` instead of `long long`, which cannot handle values up to \\(10^{18}\\).\n\n2. Using `int` for `X` may cause overflow for large input values, leading to incorrect comparisons in the loop."
    },
    {
        "problem_id": "p02693",
        "question": "Score: 100 points\n\nProblem Statement\nTakahashi the Jumbo will practice golf.\nHis objective is to get a carry distance that is a multiple of K, while he can only make a carry distance of between A and B (inclusive).\nIf he can achieve the objective, print OK; if he cannot, print NG.\n\nConstraints\n\nAll values in input are integers.\n1 \\leq A \\leq B \\leq 1000\n1 \\leq K \\leq 1000\n\nInput\nInput is given from Standard Input in the following format:\nK\nA B\n\nOutput\nIf he can achieve the objective, print OK; if he cannot, print NG.\n\nSample Input 17\n500 600\n\nSample Output 1OK\n\nAmong the multiples of 7, for example, 567 lies between 500 and 600.\n\nSample Input 24\n5 7\n\nSample Output 2NG\n\nNo multiple of 4 lies between 5 and 7.\n\nSample Input 31\n11 11\n\nSample Output 3OK",
        "desc": "This C++ problem requires determining whether there exists a multiple of a given integer K within the inclusive range [A, B]. It tests fundamental arithmetic operations and range evaluation concepts, making it suitable for beginner-level programmers.",
        "program": "#include <iostream>\nusing namespace std;\nint main() {\n  int K, A, B;\n  cin >> K >> A >> B;\n  cout << ((A / K != B / K) ? \"OK\" : \"NG\") << endl;\n}",
        "error_desc": "1. Incorrectly uses `(A / K != B / K)` to determine if a multiple of K exists between A and B.\n2. Fails to account for cases where A is exactly a multiple of K.\n3. Does not correctly handle scenarios where a multiple of K is at the upper bound B.\n4. Relies on integer division, which can lead to inaccurate comparisons for determining multiples."
    },
    {
        "problem_id": "p02699",
        "question": "Score : 100 points\n\nProblem StatementThere are S sheep and W wolves.\nIf the number of wolves is greater than or equal to that of sheep, the wolves will attack the sheep.\nIf the wolves will attack the sheep, print unsafe; otherwise, print safe.\n\nConstraints\n1 \\leq S \\leq 100\n1 \\leq W \\leq 100\n\nInputInput is given from Standard Input in the following format:\nS W\n\nOutputIf the wolves will attack the sheep, print unsafe; otherwise, print safe.\n\nSample Input 14 5\n\nSample Output 1unsafe\n\nThere are four sheep and five wolves. The number of wolves is not less than that of sheep, so they will attack them.\n\nSample Input 2100 2\n\nSample Output 2safe\n\nMany a sheep drive away two wolves.\n\nSample Input 310 10\n\nSample Output 3unsafe",
        "desc": "This C++ problem tests fundamental concepts such as handling input/output operations, using conditional statements, and performing comparison operations. It is categorized as an easy difficulty level.",
        "program": "#include <iostream>\nusing namespace std;\nint main() {\n  int S, W;\n  cin >> S >> W;\n  cout << (S <= W ? \"unsafe\" : \"safe\") << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02700",
        "question": "Score : 200 points\n\nProblem StatementTakahashi and Aoki will have a battle using their monsters.\nThe health and strength of Takahashi's monster are A and B, respectively, and those of Aoki's monster are C and D, respectively.\nThe two monsters will take turns attacking, in the order Takahashi's, Aoki's, Takahashi's, Aoki's, ...\nHere, an attack decreases the opponent's health by the value equal to the attacker's strength.\nThe monsters keep attacking until the health of one monster becomes 0 or below. The person with the monster whose health becomes 0 or below loses, and the other person wins.\nIf Takahashi will win, print Yes; if he will lose, print No.\n\nConstraints\n1 \\leq A,B,C,D \\leq 100\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nA B C D\n\nOutputIf Takahashi will win, print Yes; if he will lose, print No.\n\nSample Input 110 9 10 10\n\nSample Output 1No\n\nFirst, Takahashi's monster attacks Aoki's monster, whose health is now 10-9=1.\nNext, Aoki's monster attacks Takahashi's monster, whose health is now 10-10=0.\nTakahashi's monster is the first to have 0 or less health, so Takahashi loses.\n\nSample Input 246 4 40 5\n\nSample Output 2Yes",
        "desc": "This C++ problem involves simulating a turn-based battle between two monsters by performing iterative arithmetic operations and conditional checks to determine the winner. It tests understanding of loops, basic arithmetic, and control flow, and is categorized as an easy to intermediate difficulty level.",
        "program": "#include <iostream>\nusing namespace std;\nint main() {\n  int A, B, C, D;\n  cin >> A >> B >> C >> D;\n  for (int i = 0; ; ++i) {\n    if (i % 2 == 0) {\n      C -= B;\n      if (C <= 0) {\n        cout << \"Yes\" << endl;\n        break;\n      }\n    } else {\n      A -= D;\n      if (A <= 0) {\n        cout << \"No\" << endl;\n        break;\n      }\n    }\n  }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02701",
        "question": "Score : 300 points\n\nProblem StatementYou drew lottery N times. In the i-th draw, you got an item of the kind represented by a string S_i.\nHow many kinds of items did you get?\n\nConstraints\n1 \\leq N \\leq 2\\times 10^5\nS_i consists of lowercase English letters and has a length between 1 and 10 (inclusive).\n\nInputInput is given from Standard Input in the following format:\nN\nS_1\n:\nS_N\n\nOutputPrint the number of kinds of items you got.\n\nSample Input 13\napple\norange\napple\n\nSample Output 12\n\nYou got two kinds of items: apple and orange.\n\nSample Input 25\ngrape\ngrape\ngrape\ngrape\ngrape\n\nSample Output 21\n\nSample Input 34\naaaa\na\naaa\naa\n\nSample Output 34",
        "desc": "This C++ problem asks you to determine the number of distinct strings from N lottery draws, testing your ability to efficiently handle large datasets using data structures like `unordered_set` or `std::set` for uniqueness checks. It is categorized as a medium difficulty level, suitable for programmers familiar with handling large inputs and optimizing for time and space complexity.",
        "program": "#include <iostream>\n#include <set>\nusing namespace std;\nint main() {\n  set<string> s;\n  int N;\n  cin >> N;\n  for (int i = 0; i < N; ++i) {\n    string item;\n    cin >> item;\n    s.insert(item);\n  }\n  cout << s.size() << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02702",
        "question": "Score : 400 points\n\nProblem StatementGiven is a string S consisting of digits from 1 through 9.\nFind the number of pairs of integers (i,j) (1 ≤ i ≤ j ≤ |S|) that satisfy the following condition:\nCondition: In base ten, the i-th through j-th characters of S form an integer that is a multiple of 2019.\n\nConstraints\n1 ≤ |S| ≤ 200000\nS is a string consisting of digits from 1 through 9.\n\nInputInput is given from Standard Input in the following format:\nS\n\nOutputPrint the number of pairs of integers (i,j) (1 ≤ i ≤ j ≤ |S|) that satisfy the condition.\n\nSample Input 11817181712114\n\nSample Output 13\n\nThree pairs - (1,5), (5,9), and (9,13) - satisfy the condition.\n\nSample Input 214282668646\n\nSample Output 22\n\nSample Input 32119\n\nSample Output 30\n\nNo pairs satisfy the condition.",
        "desc": "This C++ problem involves processing a large string to count all valid substring pairs where the numerical value is divisible by 2019, testing concepts such as string manipulation, modular arithmetic, and efficient algorithm design for handling large inputs. It is classified as a challenging, high-difficulty problem typically suited for advanced competitive programming scenarios.",
        "program": "#include <iostream>\nusing namespace std;\nint dp[200000][2019];\nint main() {\n  string S;\n  cin >> S;\n  long long ans = 0;\n  for (int i = 0; i < S.size(); ++i) {\n    int digit = S[i] - '0';\n    dp[i][digit] = 1;\n\tif (i > 0) {\n      for (int j = 0; j < 2019; ++j) {\n        dp[i][(j * 10 + digit) % 2019] += dp[i - 1][j];\n      }\n    }\n    ans += dp[i][0];\n  }\n  cout << ans << endl;\n}",
        "error_desc": "1. The `dp` array is declared with size `[200000][2019]`, which exceeds the memory limit.\n2. Using a two-dimensional array instead of a space-optimized one-dimensional approach leads to excessive memory consumption.\n3. The nested loop iterates over all 2019 possible remainders for each character, further increasing memory usage."
    },
    {
        "problem_id": "p02705",
        "question": "Score : 100 points\n\nProblem StatementPrint the circumference of a circle of radius R.\n\nConstraints\n1 \\leq R \\leq 100\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nR\n\nOutputPrint the circumference of the circle.\nYour output is considered correct if and only if its absolute or relative error from our answer is at most 10^{-2}.\n\nSample Input 11\n\nSample Output 16.28318530717958623200\n\nSince we accept an absolute or relative error of at most 10^{-2}, 6.28 is also an acceptable output, but 6 is not.\n\nSample Input 273\n\nSample Output 2458.67252742410977361942",
        "desc": "This C++ problem asks contestants to calculate the circumference of a circle given an integer radius, testing their ability to apply mathematical formulas, handle floating-point precision, and perform basic input/output operations. It is categorized as an easy-level question, suitable for beginners to demonstrate fundamental programming and mathematical skills.",
        "program": "#include <iostream>\nusing namespace std;\nint main() {\n  double R;\n  cin >> R;\n  cout << R * 6.28318530717958623200 << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02724",
        "question": "Score : 200 points\n\nProblem StatementTakahashi loves gold coins. He gains 1000 happiness points for each 500-yen coin he has and gains 5 happiness points for each 5-yen coin he has. (Yen is the currency of Japan.)\nTakahashi has X yen. If he exchanges his money so that he will gain the most happiness points, how many happiness points will he earn?\n(We assume that there are six kinds of coins available: 500-yen, 100-yen, 50-yen, 10-yen, 5-yen, and 1-yen coins.)\n\nConstraints\n0 \\leq X \\leq 10^9\nX is an integer.\n\nInputInput is given from Standard Input in the following format:\nX\n\nOutputPrint the maximum number of happiness points that can be earned.\n\nSample Input 11024\n\nSample Output 12020\n\nBy exchanging his money so that he gets two 500-yen coins and four 5-yen coins, he gains 2020 happiness points, which is the maximum number of happiness points that can be earned.\n\nSample Input 20\n\nSample Output 20\n\nHe is penniless - or yenless.\n\nSample Input 31000000000\n\nSample Output 32000000000\n\nHe is a billionaire - in yen.",
        "desc": "This C++ problem assesses understanding of greedy algorithms and efficient arithmetic operations to maximize a specific value based on given constraints. It is categorized as medium difficulty, requiring the ability to optimize resource allocation using integer division and modulo techniques.",
        "program": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\nusing namespace std;\nint main() {\n  int X;\n  cin >> X;\n  cout << (X / 500 * 1000 + X % 500 / 5 * 5) << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02706",
        "question": "Score : 200 points\n\nProblem StatementTakahashi has N days of summer vacation.\nHis teacher gave him M summer assignments. It will take A_i days for him to do the i-th assignment.\nHe cannot do multiple assignments on the same day, or hang out on a day he does an assignment.\nWhat is the maximum number of days Takahashi can hang out during the vacation if he finishes all the assignments during this vacation?\nIf Takahashi cannot finish all the assignments during the vacation, print -1 instead.\n\nConstraints\n1 \\leq N \\leq 10^6\n1 \\leq M \\leq 10^4\n1 \\leq A_i \\leq 10^4\n\nInputInput is given from Standard Input in the following format:\nN M\nA_1 ... A_M\n\nOutputPrint the maximum number of days Takahashi can hang out during the vacation, or -1.\n\nSample Input 141 2\n5 6\n\nSample Output 130\n\nFor example, he can do the first assignment on the first 5 days, hang out on the next 30 days, and do the second assignment on the last 6 days of the vacation. In this way, he can safely spend 30 days hanging out.\n\nSample Input 210 2\n5 6\n\nSample Output 2-1\n\nHe cannot finish his assignments.\n\nSample Input 311 2\n5 6\n\nSample Output 30\n\nHe can finish his assignments, but he will have no time to hang out.\n\nSample Input 4314 15\n9 26 5 35 8 9 79 3 23 8 46 2 6 43 3\n\nSample Output 49",
        "desc": "This C++ problem evaluates algorithmic scheduling and optimization skills by requiring the determination of whether all assignments can be completed within a given timeframe and calculating the maximum possible leisure days. It tests concepts such as greedy algorithms and efficient input handling, and is considered to be of medium to high difficulty level.",
        "program": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\nusing namespace std;\nint A[10000];\nint main() {\n  int N, M;\n  cin >> N >> M;\n  REP(i, M) cin >> A[i];\n  int sum = 0;\n  REP(i, M) sum += A[i];\n  if (sum > N) {\n    cout << -1 << endl;\n  } else {\n    cout << N - sum << endl;\n  }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02707",
        "question": "Score : 300 points\n\nProblem StatementA company has N members, who are assigned ID numbers 1, ..., N.\nEvery member, except the member numbered 1, has exactly one immediate boss with a smaller ID number.\nWhen a person X is the immediate boss of a person Y, the person Y is said to be an immediate subordinate of the person X.\nYou are given the information that the immediate boss of the member numbered i is the member numbered A_i. For each member, find how many immediate subordinates it has.\n\nConstraints\n2 \\leq N \\leq 2 \\times 10^5\n1 \\leq A_i &lt; i\n\nInputInput is given from Standard Input in the following format:\nN\nA_2 ... A_N\n\nOutputFor each of the members numbered 1, 2, ..., N, print the number of immediate subordinates it has, in its own line.\n\nSample Input 15\n1 1 2 2\n\nSample Output 12\n2\n0\n0\n0\n\nThe member numbered 1 has two immediate subordinates: the members numbered 2 and 3.\nThe member numbered 2 has two immediate subordinates: the members numbered 4 and 5.\nThe members numbered 3, 4, and 5 do not have immediate subordinates.\n\nSample Input 210\n1 1 1 1 1 1 1 1 1\n\nSample Output 29\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\nSample Input 37\n1 2 3 4 5 6\n\nSample Output 31\n1\n1\n1\n1\n1\n0",
        "desc": "This problem involves constructing a tree to represent the company hierarchy based on given boss-subordinate relationships and counting the immediate subordinates for each member. It tests understanding of tree data structures, efficient array manipulation, and handling large input sizes, positioning it at a medium to high difficulty level.",
        "program": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\nusing namespace std;\nint A[2 * 100000];\nint B[2 * 100000];\nint main() {\n  int N;\n  cin >> N;\n  REP(i, N) {\n    cin >> A[i];\n    B[A[i]-1]++;\n  }\n  REP(i, N) cout << B[i] << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02708",
        "question": "Score : 400 points\n\nProblem StatementWe have N+1 integers: 10^{100}, 10^{100}+1, ..., 10^{100}+N.\nWe will choose K or more of these integers. Find the number of possible values of the sum of the chosen numbers, modulo (10^9+7).\n\nConstraints\n1 \\leq N \\leq 2\\times 10^5\n1 \\leq K \\leq N+1\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nN K\n\nOutputPrint the number of possible values of the sum, modulo (10^9+7).\n\nSample Input 13 2\n\nSample Output 110\n\nThe sum can take 10 values, as follows:\n\n(10^{100})+(10^{100}+1)=2\\times 10^{100}+1\n(10^{100})+(10^{100}+2)=2\\times 10^{100}+2\n(10^{100})+(10^{100}+3)=(10^{100}+1)+(10^{100}+2)=2\\times 10^{100}+3\n(10^{100}+1)+(10^{100}+3)=2\\times 10^{100}+4\n(10^{100}+2)+(10^{100}+3)=2\\times 10^{100}+5\n(10^{100})+(10^{100}+1)+(10^{100}+2)=3\\times 10^{100}+3\n(10^{100})+(10^{100}+1)+(10^{100}+3)=3\\times 10^{100}+4\n(10^{100})+(10^{100}+2)+(10^{100}+3)=3\\times 10^{100}+5\n(10^{100}+1)+(10^{100}+2)+(10^{100}+3)=3\\times 10^{100}+6\n(10^{100})+(10^{100}+1)+(10^{100}+2)+(10^{100}+3)=4\\times 10^{100}+6\n\nSample Input 2200000 200001\n\nSample Output 21\n\nWe must choose all of the integers, so the sum can take just 1 value.\n\nSample Input 3141421 35623\n\nSample Output 3220280457",
        "desc": "This problem assesses understanding of combinatorial mathematics and efficient algorithms for calculating subset sums under constraints, particularly with large input sizes. It is classified as a highly challenging (400 points) competitive programming problem.",
        "program": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\nusing namespace std;\ntemplate <std::uint_fast64_t Modulus> class modint {\n  using u64 = std::uint_fast64_t;\n public:\n  u64 a;\n  constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\nusing mint = modint<1000000007>;\nint main() {\n  int N, K;\n  cin >> N >> K;\n  mint minimum = 0;\n  mint maximum = 0;\n  REP(i, K) {\n    minimum += i;\n    maximum += N - i;\n  }\n  mint ans = 0;\n  for (int i = K; i <= N + 1; ++i) {\n    ans += maximum - minimum + 1;\n    minimum += i;\n    maximum += N - i;\n  }\n  cout << ans.value() << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02709",
        "question": "Score : 500 points\n\nProblem StatementThere are N children standing in a line from left to right. The activeness of the i-th child from the left is A_i.\nYou can rearrange these children just one time in any order you like.\nWhen a child who originally occupies the x-th position from the left in the line moves to the y-th position from the left, that child earns A_x \\times |x-y| happiness points.\nFind the maximum total happiness points the children can earn.\n\nConstraints\n2 \\leq N \\leq 2000\n1 \\leq A_i \\leq 10^9\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nN\nA_1 A_2 ... A_N\n\nOutputPrint the maximum total happiness points the children can earn.\n\nSample Input 14\n1 3 4 2\n\nSample Output 120\n\nIf we move the 1-st child from the left to the 3-rd position from the left, the 2-nd child to the 4-th position, the 3-rd child to the 1-st position, and the 4-th child to the 2-nd position, the children earns 1 \\times |1-3|+3 \\times |2-4|+4 \\times |3-1|+2 \\times |4-2|=20 happiness points in total.\n\nSample Input 26\n5 5 6 1 1 1\n\nSample Output 258\n\nSample Input 36\n8 6 9 1 2 1\n\nSample Output 385",
        "desc": "This C++ problem requires determining the optimal one-time rearrangement of N children to maximize total happiness, where happiness is calculated based on each child's activeness and movement distance. It tests knowledge of dynamic programming or advanced greedy algorithms for optimization under constraints and is considered to have a high difficulty level.",
        "program": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\nusing namespace std;\nlong long A[2000];\nlong long absolute(long long x) {\n  if (x < 0) {\n    return -x;\n  }\n  return x;\n}\nint main() {\n  int N;\n  cin >> N;\n  REP(i, N) cin >> A[i];\n  long long ans = 0;\n  for (int i = 0; i <= N; ++i) {\n    vector<pair<int, int>> left;\n    for (int j = 0; j < i; ++j) {\n      left.push_back(make_pair(A[j], j));\n    }\n    sort(left.begin(), left.end());\n    vector<pair<int, int>> right;\n    for (int j = i; j < N; ++j) {\n      right.push_back(make_pair(-A[j], j));\n    }\n    sort(right.begin(), right.end());\n    long long sum = 0;\n    for (int i = 0; i < left.size(); ++i) {\n      sum += left[i].first * absolute(left[i].second - (right.size() + i));\n    }\n    for (int i = 0; i < right.size(); ++i) {\n      sum += -right[i].first * absolute(right[i].second - i);\n    }\n    if (ans < sum) {\n      ans = sum;\n    }\n  }\n  cout << ans << endl;\n}",
        "error_desc": "1. The main loop uses `i <= N`, which causes an out-of-bounds access when `i` equals `N`; it should be `i < N`.\n2. The inner `for` loops reuse the loop variable `i`, leading to variable shadowing and incorrect index calculations.\n3. The `absolute` function is unnecessary since the standard `abs` function from `<cmath>` can be used.\n4. The happiness points calculation incorrectly uses `right.size() + i` to determine the new position, resulting in inaccurate total happiness."
    },
    {
        "problem_id": "p02711",
        "question": "Score : 100 points\n\nProblem StatementGiven is a three-digit integer N. Does N contain the digit 7?\nIf so, print Yes; otherwise, print No.\n\nConstraints\n100 \\leq N \\leq 999\n\nInputInput is given from Standard Input in the following format:\nN\n\nOutputIf N contains the digit 7, print Yes; otherwise, print No.\n\nSample Input 1117\n\nSample Output 1Yes\n\n117 contains 7 as its last digit.\n\nSample Input 2123\n\nSample Output 2No\n\n123 does not contain the digit 7.\n\nSample Input 3777\n\nSample Output 3Yes",
        "desc": "This C++ problem asks the programmer to determine if a given three-digit integer contains the digit '7', testing fundamental concepts like integer manipulation and digit extraction. It is classified as an easy-level question, suitable for beginners learning basic programming and conditional logic.",
        "program": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\nusing namespace std;\nint main() {\n  string N;\n  cin >> N;\n  for (int i = 0; i < N.size(); ++i) {\n    if (N[i] == '7') {\n      cout << \"Yes\" << endl;\n      return 0;\n    }\n  }\n  cout << \"No\" << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02712",
        "question": "Score : 200 points\n\nProblem StatementLet us define the FizzBuzz sequence a_1,a_2,... as follows:\n\nIf both 3 and 5 divides i, a_i=\\mbox{FizzBuzz}.\nIf the above does not hold but 3 divides i, a_i=\\mbox{Fizz}.\nIf none of the above holds but 5 divides i, a_i=\\mbox{Buzz}.\nIf none of the above holds, a_i=i.\n\nFind the sum of all numbers among the first N terms of the FizzBuzz sequence.\n\nConstraints\n1 \\leq N \\leq 10^6\n\nInputInput is given from Standard Input in the following format:\nN\n\nOutputPrint the sum of all numbers among the first N terms of the FizzBuzz sequence.\n\nSample Input 115\n\nSample Output 160\n\nThe first 15 terms of the FizzBuzz sequence are:\n1,2,\\mbox{Fizz},4,\\mbox{Buzz},\\mbox{Fizz},7,8,\\mbox{Fizz},\\mbox{Buzz},11,\\mbox{Fizz},13,14,\\mbox{FizzBuzz}\nAmong them, numbers are 1,2,4,7,8,11,13,14, and the sum of them is 60.\n\nSample Input 21000000\n\nSample Output 2266666333332\n\nWatch out for overflow.",
        "desc": "This C++ problem assesses understanding of loops, conditional logic using modulo operations, and efficient summation techniques while handling potential integer overflow. It is classified as a medium difficulty level, suitable for testing fundamental algorithmic skills within the constraints of handling up to one million elements.",
        "program": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\nusing namespace std;\nint main() {\n  int N;\n  cin >> N;\n  long long ans = 0;\n  for (int i = 1; i <= N; ++i) {\n    if (i % 3 != 0 && i % 5 != 0) {\n      ans += i;\n    }\n  }\n  cout << ans << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02713",
        "question": "Score : 300 points\n\nProblem StatementFind \\displaystyle{\\sum_{a=1}^{K}\\sum_{b=1}^{K}\\sum_{c=1}^{K} \\gcd(a,b,c)}.\nHere \\gcd(a,b,c) denotes the greatest common divisor of a, b, and c.\n\nConstraints\n1 \\leq K \\leq 200\nK is an integer.\n\nInputInput is given from Standard Input in the following format:\nK\n\nOutputPrint the value of \\displaystyle{\\sum_{a=1}^{K}\\sum_{b=1}^{K}\\sum_{c=1}^{K} \\gcd(a,b,c)}.\n\nSample Input 12\n\nSample Output 19\n\n\\gcd(1,1,1)+\\gcd(1,1,2)+\\gcd(1,2,1)+\\gcd(1,2,2)\n+\\gcd(2,1,1)+\\gcd(2,1,2)+\\gcd(2,2,1)+\\gcd(2,2,2)\n=1+1+1+1+1+1+1+2=9\nThus, the answer is 9.\n\nSample Input 2200\n\nSample Output 210813692",
        "desc": "This problem asks for the sum of the greatest common divisors (GCD) of all possible triplets (a, b, c) where each variable ranges from 1 to K. It tests understanding of nested loops, efficient GCD calculation, and optimization techniques, and is classified as a challenging (300-point) problem.",
        "program": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\nusing namespace std;\nint gcd(int a, int b) {\n  if (a > b) {\n    return gcd(b, a);\n  }\n  if (b % a == 0) {\n    return a;\n  }\n  return gcd(b % a, a);\n}\nint main() {\n  int K;\n  cin >> K;\n  int sum = 0;\n  for (int a = 1; a <= K; ++a) {\n    for (int b = 1; b <= K; ++b) {\n      for (int c = 1; c <= K; ++c) {\n        sum += gcd(a, gcd(b, c));\n      }\n    }\n  }\n  cout << sum << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02714",
        "question": "Score : 400 points\n\nProblem StatementWe have a string S of length N consisting of R, G, and B.\nFind the number of triples (i,~j,~k)~(1 \\leq i &lt; j &lt; k \\leq N) that satisfy both of the following conditions:\n\nS_i \\neq S_j, S_i \\neq S_k, and S_j \\neq S_k.\nj - i \\neq k - j.\n\nConstraints\n1 \\leq N \\leq 4000\nS is a string of length N consisting of R, G, and B.\n\nInputInput is given from Standard Input in the following format:\nN\nS\n\nOutputPrint the number of triplets in question.\n\nSample Input 14\nRRGB\n\nSample Output 11\n\nOnly the triplet (1,~3,~4) satisfies both conditions. The triplet (2,~3,~4) satisfies the first condition but not the second, so it does not count.\n\nSample Input 239\nRBRBGRBGGBBRRGBBRRRBGGBRBGBRBGBRBBBGBBB\n\nSample Output 21800",
        "desc": "This C++ problem tasks programmers with counting distinct-character triplets in a string where the indices are not equally spaced, testing skills in combinatorial analysis, efficient looping, and string manipulation. With a difficulty level of 400 points, it requires optimized algorithmic approaches to handle input sizes up to 4000 efficiently.",
        "program": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\nusing namespace std;\nint dp[4000][3];\nint toInt(int c) {\n  string s = \"RGB\";\n  REP(i, 3) if (s[i] == c) return i;\n  return -1;\n}\nint rem(char a, char b) {\n  string s = \"RGB\";\n  REP(i, 3) if (s[i] != a && s[i] != b) return i;\n}\nint main() {\n  int N;\n  string S;\n  cin >> N >> S;\n  for (int i = N - 1; i >= 0; --i) {\n    int c = toInt(S[i]);\n    REP(j, 3) {\n      dp[i][j] = (i == N - 1 ? 0 : dp[i + 1][j]) + (c == j ? 1 : 0);\n    }\n  }\n  long long ans = 0;\n  REP(i, N) {\n    for (int j = i + 1; j + 1 < N; ++j) {\n      if (S[i] == S[j]) {\n        continue;\n      }\n      int c = rem(S[i], S[j]);\n      int cnt = dp[j + 1][c];\n      int k = j + (j - i);\n      if (k < N && toInt(S[k]) == c) {\n        --cnt;\n      }\n      ans += cnt;\n    }\n  }\n  cout << ans << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02675",
        "question": "Score: 100 points\n\nProblem Statement\nThe cat Snuke wants to play a popular Japanese game called ÅtCoder, so Iroha has decided to teach him Japanese.\nWhen counting pencils in Japanese, the counter word \"本\" follows the number. The pronunciation of this word varies depending on the number. Specifically, the pronunciation of \"本\" in the phrase \"N 本\" for a positive integer N not exceeding 999 is as follows:\n\nhon when the digit in the one's place of N is 2, 4, 5, 7, or 9;\npon when the digit in the one's place of N is 0, 1, 6 or 8;\nbon when the digit in the one's place of N is 3.\n\nGiven N, print the pronunciation of \"本\" in the phrase \"N 本\".\n\nConstraints\n\nN is a positive integer not exceeding 999.\n\nInput\nInput is given from Standard Input in the following format:\nN\n\nOutput\nPrint the answer.\n\nSample Input 116\n\nSample Output 1pon\n\nThe digit in the one's place of 16 is 6, so the \"本\" in \"16 本\" is pronounced pon.\n\nSample Input 22\n\nSample Output 2hon\n\nSample Input 3183\n\nSample Output 3bon",
        "desc": "The problem asks for determining the correct pronunciation suffix (\"hon\", \"pon\", or \"bon\") for the Japanese counter \"本\" based on the units digit of a given integer \\( N \\) (≤ 999). It tests understanding of input/output handling, digit extraction using modulo operations, and the implementation of conditional logic, and is considered an easy-level C++ programming challenge.",
        "program": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\nusing namespace std;\nint main() {\n  int N;\n  cin >> N;\n  switch (N % 10) {\n    case 2:\n    case 4:\n    case 5:\n    case 7:\n    case 9:\n      cout << \"hon\";\n      break;\n    case 0:\n    case 1:\n    case 6:\n    case 8:\n      cout << \"pon\";\n      break;\n    default:\n      cout << \"bon\";\n      break;\n  }\n  cout << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02676",
        "question": "Score: 200 points\n\nProblem Statement\nWe have a string S consisting of lowercase English letters.\nIf the length of S is at most K, print S without change.\nIf the length of S exceeds K, extract the first K characters in S, append ... to the end of them, and print the result.\n\nConstraints\n\nK is an integer between 1 and 100 (inclusive).\nS is a string consisting of lowercase English letters.\nThe length of S is between 1 and 100 (inclusive).\n\nInput\nInput is given from Standard Input in the following format:\nK\nS\n\nOutput\nPrint a string as stated in Problem Statement.\n\nSample Input 17\nnikoandsolstice\n\nSample Output 1nikoand...\n\nnikoandsolstice has a length of 15, which exceeds K=7.\nWe should extract the first 7 characters in this string, append ... to the end of them, and print the result nikoand....\n\nSample Input 240\nferelibenterhominesidquodvoluntcredunt\n\nSample Output 2ferelibenterhominesidquodvoluntcredunt\n\nThe famous quote from Gaius Julius Caesar.",
        "desc": "This C++ problem evaluates string manipulation skills, specifically measuring string length, extracting substrings, and applying conditional logic to format output. It is classified as an easy-level task, suitable for beginners.",
        "program": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\nusing namespace std;\nint main() {\n  int K;\n  string S;\n  cin >> K >> S;\n  if (S.size() <= K) {\n    cout << S << endl;\n  } else {\n    cout << S.substr(0, K);\n    cout << \"...\";\n    cout << endl;\n  }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02677",
        "question": "Score: 300 points\n\nProblem Statement\nConsider an analog clock whose hour and minute hands are A and B centimeters long, respectively.\nAn endpoint of the hour hand and an endpoint of the minute hand are fixed at the same point, around which each hand rotates clockwise at constant angular velocity. It takes the hour and minute hands 12 hours and 1 hour to make one full rotation, respectively.\nAt 0 o'clock, the two hands overlap each other. H hours and M minutes later, what is the distance in centimeters between the unfixed endpoints of the hands?\n\nConstraints\n\nAll values in input are integers.\n1 \\leq A, B \\leq 1000\n0 \\leq H \\leq 11\n0 \\leq M \\leq 59\n\nInput\nInput is given from Standard Input in the following format:\nA B H M\n\nOutput\nPrint the answer without units. Your output will be accepted when its absolute or relative error from the correct value is at most 10^{-9}.\n\nSample Input 13 4 9 0\n\nSample Output 15.00000000000000000000\n\nThe two hands will be in the positions shown in the figure below, so the answer is 5 centimeters.\n\nSample Input 23 4 10 40\n\nSample Output 24.56425719433005567605\n\nThe two hands will be in the positions shown in the figure below. Note that each hand always rotates at constant angular velocity.",
        "desc": "This C++ problem assesses understanding of angular motion, trigonometric calculations, and precise floating-point computations by requiring the determination of the distance between clock hand endpoints after a given time. It is classified as a medium to high difficulty level due to the combination of geometric reasoning and precision handling needed.",
        "program": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\nusing namespace std;\ndouble sq(double x) {\n  return x * x;\n}\nint main() {\n  double A, B, H, M;\n  cin >> A >> B >> H >> M;\n  double pi = 3.141592653589793;\n  double at = (H + M / 60) / 12 * 2 * pi;\n  double ax = cos(at) * A;\n  double ay = sin(at) * A;\n  double bt = (M / 60) * 2 * pi;\n  double bx = cos(bt) * B;\n  double by = sin(bt) * B;\n  cout << sqrt(sq(ax - bx) + sq(ay - by)) << endl;\n}",
        "error_desc": "1. The minute hand angle is calculated using only `M` instead of the total elapsed time `H + M / 60`.\n2. The program does not set the required precision, resulting in insufficient decimal places in the output."
    },
    {
        "problem_id": "p02678",
        "question": "Score: 400 points\n\nProblem Statement\nThere is a cave.\nThe cave has N rooms and M passages. The rooms are numbered 1 to N, and the passages are numbered 1 to M. Passage i connects Room A_i and Room B_i bidirectionally. One can travel between any two rooms by traversing passages. Room 1 is a special room with an entrance from the outside.\nIt is dark in the cave, so we have decided to place a signpost in each room except Room 1. The signpost in each room will point to one of the rooms directly connected to that room with a passage.\nSince it is dangerous in the cave, our objective is to satisfy the condition below for each room except Room 1.\n\nIf you start in that room and repeatedly move to the room indicated by the signpost in the room you are in, you will reach Room 1 after traversing the minimum number of passages possible.\n\nDetermine whether there is a way to place signposts satisfying our objective, and print one such way if it exists.\n\nConstraints\n\nAll values in input are integers.\n2 \\leq N \\leq 10^5\n1 \\leq M \\leq 2 \\times 10^5\n1 \\leq A_i, B_i \\leq N\\ (1 \\leq i \\leq M)\nA_i \\neq B_i\\ (1 \\leq i \\leq M)\nOne can travel between any two rooms by traversing passages.\n\nInput\nInput is given from Standard Input in the following format:\nN M\nA_1 B_1\n:\nA_M B_M\n\nOutput\nIf there is no way to place signposts satisfying the objective, print No.\nOtherwise, print N lines. The first line should contain Yes, and the i-th line (2 \\leq i \\leq N) should contain the integer representing the room indicated by the signpost in Room i.\n\nSample Input 14 4\n1 2\n2 3\n3 4\n4 2\n\nSample Output 1Yes\n1\n2\n2\n\nIf we place the signposts as described in the sample output, the following happens:\n\nStarting in Room 2, you will reach Room 1 after traversing one passage: (2) \\to 1. This is the minimum number of passages possible.\nStarting in Room 3, you will reach Room 1 after traversing two passages: (3) \\to 2 \\to 1. This is the minimum number of passages possible.\nStarting in Room 4, you will reach Room 1 after traversing two passages: (4) \\to 2 \\to 1. This is the minimum number of passages possible.\n\nThus, the objective is satisfied.\n\nSample Input 26 9\n3 4\n6 1\n2 4\n5 3\n4 6\n1 5\n6 2\n4 5\n5 6\n\nSample Output 2Yes\n6\n5\n5\n1\n1\n\nIf there are multiple solutions, any of them will be accepted.",
        "desc": "This problem requires constructing directional signposts in a connected undirected graph to ensure that following the signposts from any room leads to Room 1 via the shortest possible path, testing knowledge of graph traversal (BFS), shortest path algorithms, and graph construction. It is classified as a high-difficulty (400 points) problem suitable for advanced competitive programming.",
        "program": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\nusing namespace std;\nint A[2 * 100000];\nint B[2 * 100000];\nint main() {\n  int N, M;\n  cin >> N >> M;\n  vector<vector<int>> edges(N);\n  REP(i, M) {\n    int A, B;\n    cin >> A >> B;\n    --A, --B;\n    edges[A].push_back(B);\n    edges[B].push_back(A);\n  }\n  map<int, int> prev;\n  prev[0] = -1;\n  queue<int> que;\n  que.push(0);\n  while (!que.empty()) {\n    int here = que.front();\n    que.pop();\n    for (int there : edges[here]) {\n      if (prev.count(there) > 0) {\n        continue;\n      }\n      prev[there] = here;\n      que.push(there);\n    }\n  }\n  bool ok = true;\n  for (int i = 2; i < N; ++i) {\n    if (prev.count(i) == 0) {\n      ok = false;\n      break;\n    }\n  }\n  if (!ok) {\n    cout << \"No\" << endl;\n    return 0;\n  }\n  cout << \"Yes\" << endl;\n  for (int i = 1; i < N; ++i) {\n    cout << prev[i] + 1 << endl;\n  }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02718",
        "question": "Score : 200 points\n\nProblem StatementWe have held a popularity poll for N items on sale. Item i received A_i votes.\nFrom these N items, we will select M as popular items. However, we cannot select an item with less than \\dfrac{1}{4M} of the total number of votes.\nIf M popular items can be selected, print Yes; otherwise, print No.\n\nConstraints\n1 \\leq M \\leq N \\leq 100\n1 \\leq A_i \\leq 1000\nA_i are distinct.\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nN M\nA_1 ... A_N\n\nOutputIf M popular items can be selected, print Yes; otherwise, print No.\n\nSample Input 14 1\n5 4 2 1\n\nSample Output 1Yes\n\nThere were 12 votes in total. The most popular item received 5 votes, and we can select it.\n\nSample Input 23 2\n380 19 1\n\nSample Output 2No\n\nThere were 400 votes in total. The second and third most popular items received less than \\dfrac{1}{4\\times 2} of the total number of votes, so we cannot select them. Thus, we cannot select two popular items.\n\nSample Input 312 3\n4 56 78 901 2 345 67 890 123 45 6 789\n\nSample Output 3Yes",
        "desc": "This C++ problem evaluates skills in array manipulation, sorting, and conditional logic to determine if a subset of items meets a specified vote threshold. It is classified as medium difficulty, suitable for intermediate programmers tackling conditional selection and threshold-based criteria.",
        "program": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\nusing namespace std;\nint A[100];\nint main() {\n  int N, M;\n  cin >> N >> M;\n  int sum = 0;\n  REP(i, N) {\n    cin >> A[i];\n    sum += A[i];\n  }\n  sort(A, A + N);\n  if (A[N - 1 - (M - 1)] >= sum / (4 * M)) {\n    cout << \"Yes\" << endl;\n  } else {\n    cout << \"No\" << endl;\n  }\n}",
        "error_desc": "1. The program calculates the vote threshold using integer division (`sum / (4 * M)`), which can lead to incorrect comparisons.\n2. It does not account for fractional parts in the threshold, potentially allowing selection of items with insufficient votes.\n3. The output includes an extra newline due to the use of `endl`, which may not match the expected output format."
    },
    {
        "problem_id": "p02719",
        "question": "Score : 300 points\n\nProblem StatementGiven any integer x, Aoki can do the operation below.\nOperation: Replace x with the absolute difference of x and K.\nYou are given the initial value of an integer N. Find the minimum possible value taken by N after Aoki does the operation zero or more times.\n\nConstraints\n0 ≤ N ≤ 10^{18}\n1 ≤ K ≤ 10^{18}\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nN K\n\nOutputPrint the minimum possible value taken by N after Aoki does the operation zero or more times.\n\nSample Input 17 4\n\nSample Output 11\n\nInitially, N=7.\nAfter one operation, N becomes |7-4| = 3.\nAfter two operations, N becomes |3-4| = 1, which is the minimum value taken by N.\n\nSample Input 22 6\n\nSample Output 22\n\nN=2 after zero operations is the minimum.\n\nSample Input 31000000000000000000 1\n\nSample Output 30",
        "desc": "This C++ problem involves repeatedly applying an absolute difference operation to minimize a given integer, testing concepts such as iterative algorithms, mathematical pattern recognition, and efficient handling of large numerical constraints. It is considered to be of **hard** difficulty level.",
        "program": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\nusing namespace std;\nint main() {\n  long long N, K;\n  cin >> N >> K;\n  N %= K;\n  cout << min(abs(N - K), N) << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02720",
        "question": "Score : 400 points\n\nProblem Statement\nA positive integer X is said to be a lunlun number if and only if the following condition is satisfied:\n\nIn the base ten representation of X (without leading zeros), for every pair of two adjacent digits, the absolute difference of those digits is at most 1.\n\nFor example, 1234, 1, and 334 are lunlun numbers, while none of 31415, 119, or 13579 is.\nYou are given a positive integer K. Find the K-th smallest lunlun number.\n\nConstraints\n\n1 \\leq K \\leq 10^5\nAll values in input are integers.\n\nInput\nInput is given from Standard Input in the following format:\nK\n\nOutput\nPrint the answer.\n\nSample Input 115\n\nSample Output 123\n\nWe will list the 15 smallest lunlun numbers in ascending order:\n1,\n2,\n3,\n4,\n5,\n6,\n7,\n8,\n9,\n10,\n11,\n12,\n21,\n22,\n23.\nThus, the answer is 23.\n\nSample Input 21\n\nSample Output 21\n\nSample Input 313\n\nSample Output 321\n\nSample Input 4100000\n\nSample Output 43234566667\n\nNote that the answer may not fit into the 32-bit signed integer type.",
        "desc": "This C++ problem asks for finding the K-th smallest \"lunlun number\"—a positive integer where each pair of adjacent digits differs by at most one. It tests concepts such as breadth-first search (BFS) for number generation and handling large integers, and is classified as a high-difficulty (400-point) programming challenge.",
        "program": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\nusing namespace std;\nlong long increment(long long x) {\n  if (x < 10) {\n    return x + 1;\n  }\n  long long a = x % 10;\n  long long b = x / 10 % 10;\n  if (a + 1 < 10 && a + 1 <= b + 1) {\n    return x + 1;\n  }\n  long long res = increment(x / 10);\n  if (res % 10 == 0) {\n    return res * 10;\n  }\n  return res * 10 + (res % 10 - 1);\n}\nint main() {\n  int K;\n  cin >> K;\n  long long x = 0;\n  for (int i = 0; i < K; ++i) {\n    x = increment(x);\n  }\n  cout << x << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02725",
        "question": "Score : 300 points\n\nProblem StatementThere is a circular pond with a perimeter of K meters, and N houses around them.\nThe i-th house is built at a distance of A_i meters from the northmost point of the pond, measured clockwise around the pond.\nWhen traveling between these houses, you can only go around the pond.\nFind the minimum distance that needs to be traveled when you start at one of the houses and visit all the N houses.\n\nConstraints\n2 \\leq K \\leq 10^6\n2 \\leq N \\leq 2 \\times 10^5\n0 \\leq A_1 &lt; ... &lt; A_N &lt; K\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nK N\nA_1 A_2 ... A_N\n\nOutputPrint the minimum distance that needs to be traveled when you start at one of the houses and visit all the N houses.\n\nSample Input 120 3\n5 10 15\n\nSample Output 110\n\nIf you start at the 1-st house and go to the 2-nd and 3-rd houses in this order, the total distance traveled will be 10.\n\nSample Input 220 3\n0 5 15\n\nSample Output 210\n\nIf you start at the 2-nd house and go to the 1-st and 3-rd houses in this order, the total distance traveled will be 10.",
        "desc": "This C++ problem challenges participants to compute the minimum travel distance around a circular pond to visit all given houses, testing concepts such as circular array handling, greedy algorithms, and efficient computation under large constraints. It is considered to have a medium to high difficulty level due to the need for optimal algorithm design to handle up to 200,000 houses efficiently.",
        "program": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\nusing namespace std;\nint A[2 * 100000];\nint main() {\n  int K, N;\n  cin >> K >> N;\n  REP(i, N) cin >> A[i];\n  int maximum = 0;\n  REP(i, N - 1) maximum = max(maximum, A[i + 1] - A[i]);\n  cout << max(maximum, K - A[N - 1] + A[0]) << endl;\n}",
        "error_desc": "1. The program outputs the maximum gap between houses instead of calculating `K` minus the maximum gap to determine the minimum distance.\n\n2. It incorrectly interprets the problem by not subtracting the maximum gap from the total perimeter `K`.\n\n3. The output does not align with the required minimum distance to be traveled as demonstrated in the second sample test case."
    },
    {
        "problem_id": "p02726",
        "question": "Score : 400 points\n\nProblem Statement\nWe have an undirected graph G with N vertices numbered 1 to N and N edges as follows:\n\nFor each i=1,2,...,N-1, there is an edge between Vertex i and Vertex i+1.\nThere is an edge between Vertex X and Vertex Y.\n\nFor each k=1,2,...,N-1, solve the problem below:\n\nFind the number of pairs of integers (i,j) (1 \\leq i &lt; j \\leq N) such that the shortest distance between Vertex i and Vertex j in G is k.\n\nConstraints\n\n3 \\leq N \\leq 2 \\times 10^3\n1 \\leq X,Y \\leq N\nX+1 &lt; Y\nAll values in input are integers.\n\nInput\nInput is given from Standard Input in the following format:\nN X Y\n\nOutput\nFor each k=1, 2, ..., N-1 in this order, print a line containing the answer to the problem.\n\nSample Input 15 2 4\n\nSample Output 15\n4\n1\n0\n\nThe graph in this input is as follows:\n\nThere are five pairs (i,j) (1 \\leq i &lt; j \\leq N) such that the shortest distance between Vertex i and Vertex j is 1: (1,2)\\,,(2,3)\\,,(2,4)\\,,(3,4)\\,,(4,5).\n\nThere are four pairs (i,j) (1 \\leq i &lt; j \\leq N) such that the shortest distance between Vertex i and Vertex j is 2: (1,3)\\,,(1,4)\\,,(2,5)\\,,(3,5).\n\nThere is one pair (i,j) (1 \\leq i &lt; j \\leq N) such that the shortest distance between Vertex i and Vertex j is 3: (1,5).\n\nThere are no pairs (i,j) (1 \\leq i &lt; j \\leq N) such that the shortest distance between Vertex i and Vertex j is 4.\n\nSample Input 23 1 3\n\nSample Output 23\n0\n\nThe graph in this input is as follows:\n\nSample Input 37 3 7\n\nSample Output 37\n8\n4\n2\n0\n0\n\nSample Input 410 4 8\n\nSample Output 410\n12\n10\n8\n4\n1\n0\n0\n0",
        "desc": "This C++ problem requires determining the number of vertex pairs at each specific shortest path distance in a nearly linear graph augmented with an additional edge, testing concepts in graph theory, shortest path algorithms, and combinatorial analysis. It is classified as a high-difficulty (400 points) challenge suitable for advanced programmers.",
        "program": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\nusing namespace std;\nint dist[2 * 1000];\nint abs(int x) { return x < 0 ? -x : x; }\nint main() {\n  int N, X, Y;\n  cin >> N >> X >> Y;\n  --X, --Y;\n  for (int j = 1; j < N; ++j) {\n    for (int i = 0; i < j; ++i) {\n      dist[min(j - i,\n               min(abs(X - i) + 1 + abs(Y - j),\n                   abs(Y - i) + 1 + abs(X - j)))]++;\n    }\n  }\n  for (int i = 1; i <= N - 1; ++i) {\n    cout << dist[i] << endl;\n  }\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02727",
        "question": "Score : 500 points\n\nProblem StatementYou are going to eat X red apples and Y green apples.\nYou have A red apples of deliciousness p_1,p_2, \\dots, p_A, B green apples of deliciousness q_1,q_2, \\dots, q_B, and C colorless apples of deliciousness r_1,r_2, \\dots, r_C.\nBefore eating a colorless apple, you can paint it red or green, and it will count as a red or green apple, respectively.\nFrom the apples above, you will choose the apples to eat while making the sum of the deliciousness of the eaten apples as large as possible.\nFind the maximum possible sum of the deliciousness of the eaten apples that can be achieved when optimally coloring zero or more colorless apples.\n\nConstraints\n1 \\leq X \\leq A \\leq 10^5\n1 \\leq Y \\leq B \\leq 10^5\n1 \\leq C \\leq 10^5\n1 \\leq p_i \\leq 10^9\n1 \\leq q_i \\leq 10^9\n1 \\leq r_i \\leq 10^9\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nX Y A B C\np_1 p_2 ... p_A\nq_1 q_2 ... q_B\nr_1 r_2 ... r_C\n\nOutputPrint the maximum possible sum of the deliciousness of the eaten apples.\n\nSample Input 11 2 2 2 1\n2 4\n5 1\n3\n\nSample Output 112\n\nThe maximum possible sum of the deliciousness of the eaten apples can be achieved as follows:\n\nEat the 2-nd red apple.\nEat the 1-st green apple.\nPaint the 1-st colorless apple green and eat it.\n\nSample Input 22 2 2 2 2\n8 6\n9 1\n2 1\n\nSample Output 225\n\nSample Input 32 2 4 4 4\n11 12 13 14\n21 22 23 24\n1 2 3 4\n\nSample Output 374",
        "desc": "This C++ problem challenges participants to maximize the sum of deliciousness by optimally selecting and optionally painting colorless apples as red or green, effectively testing greedy algorithms, sorting techniques, and efficient handling of large datasets. It is classified as a high-difficulty (500-point) problem, suitable for advanced competitive programming scenarios.",
        "program": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\nusing namespace std;\nint p[100000];\nint q[100000];\nint r[100000];\nint main() {\n  int X, Y, A, B, C;\n  cin >> X >> Y >> A >> B >> C;\n  REP(i, A) cin >> p[i];\n  REP(i, B) cin >> q[i];\n  REP(i, C) cin >> r[i];\n  sort(p, p + A);\n  sort(q, q + B);\n  sort(r, r + C);\n  int ai = A - X;\n  int bi = B - Y;\n  int ci = C;\n  while (true) {\n    if (ci == 0) {\n      break;\n    }\n    bool a = ai < A && p[ai] < r[ci - 1];\n    bool b = bi < B && q[bi] < r[ci - 1];\n    if (!a && !b) {\n      break;\n    }\n    if (a && (!b || p[ai] < q[bi])) {\n      ++ai;\n    } else {\n      ++bi;\n    }\n    --ci;\n  }\n  long long ans = 0;\n  for (int i = ai; i < A; ++i) {\n    ans += p[i];\n  }\n  for (int i = bi; i < B; ++i) {\n    ans += q[i];\n  }\n  for (int i = ci; i < C; ++i) {\n    ans += r[i];\n  }\n  cout << ans << endl;\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02716",
        "question": "Score : 600 points\n\nProblem StatementGiven is an integer sequence A_1, ..., A_N of length N.\nWe will choose exactly \\left\\lfloor \\frac{N}{2} \\right\\rfloor elements from this sequence so that no two adjacent elements are chosen.\nFind the maximum possible sum of the chosen elements.\nHere \\lfloor x \\rfloor denotes the greatest integer not greater than x.\n\nConstraints\n2 \\leq N \\leq 2\\times 10^5\n|A_i|\\leq 10^9\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nN\nA_1 ... A_N\n\nOutputPrint the maximum possible sum of the chosen elements.\n\nSample Input 16\n1 2 3 4 5 6\n\nSample Output 112\n\nChoosing 2, 4, and 6 makes the sum 12, which is the maximum possible value.\n\nSample Input 25\n-1000 -100 -10 0 10\n\nSample Output 20\n\nChoosing -10 and 10 makes the sum 0, which is the maximum possible value.\n\nSample Input 310\n1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000\n\nSample Output 35000000000\n\nWatch out for overflow.\n\nSample Input 427\n18 -28 18 28 -45 90 -45 23 -53 60 28 -74 -71 35 -26 -62 49 -77 57 24 -70 -93 69 -99 59 57 -49\n\nSample Output 4295",
        "desc": "This C++ problem requires selecting exactly ⌊N/2⌋ non-adjacent elements from a sequence to maximize their sum, testing concepts in dynamic programming and efficient algorithm design for large input sizes. It is classified as a challenging, high-difficulty problem suitable for advanced programmers.",
        "program": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\nusing namespace std;\nlong long A[2 * 100000];\nlong long dp[2 * 100000][2][3];\nvoid setmax(long long &best, long long cand) {\n  if (best < cand) best = cand;\n}\nint main() {\n  int N;\n  cin >> N;\n  REP(i, N) cin >> A[i];\n  const long long INF = 100000000000000000;\n  REP(i, N) REP(j, 2) REP(k, 3) dp[i][j][k] = -INF;\n  dp[0][0][1] = 0;\n  dp[0][1][0] = A[0];\n  int maxskip = N % 2 == 0 ? 1 : 2;\n  for (int i = 1; i < N; ++i) {\n    for (int skipped = 0; skipped <= maxskip; ++skipped) {\n      setmax(dp[i][0][skipped], dp[i - 1][1][skipped]);\n      setmax(dp[i][1][skipped], dp[i - 1][0][skipped] + A[i]);\n      if (skipped < maxskip) {\n        setmax(dp[i][0][skipped+1], dp[i - 1][0][skipped]);\n      }\n    }\n  }\n  long long ans = 0;\n  REP(i, 2) setmax(ans, dp[N - 1][i][maxskip]);\n  cout << ans << endl;\n}",
        "error_desc": "1. The `dp` array is declared with a third dimension size of 3, which is insufficient for handling up to floor(N/2) elements.\n2. The `maxskip` variable is incorrectly set based on whether N is even or odd instead of using floor(N/2).\n3. The DP state does not ensure exactly floor(N/2) elements are chosen, leading to incorrect sum calculations.\n4. The final answer is derived using `dp[N-1][i][maxskip]`, which does not correctly represent the required number of selected elements.\n5. The program initializes `ans` to 0, which may be incorrect if the maximum possible sum is negative."
    },
    {
        "problem_id": "p02722",
        "question": "Score : 600 points\n\nProblem StatementGiven is a positive integer N.\nWe will choose an integer K between 2 and N (inclusive), then we will repeat the operation below until N becomes less than K.\n\nOperation: if K divides N, replace N with N/K; otherwise, replace N with N-K.\n\nIn how many choices of K will N become 1 in the end?\n\nConstraints\n2 \\leq N \\leq 10^{12}\nN is an integer.\n\nInputInput is given from Standard Input in the following format:\nN\n\nOutputPrint the number of choices of K in which N becomes 1 in the end.\n\nSample Input 16\n\nSample Output 13\n\nThere are three choices of K in which N becomes 1 in the end: 2, 5, and 6.\nIn each of these choices, N will change as follows:\n\nWhen K=2: 6 \\to 3 \\to 1\nWhen K=5: 6 \\to 1\nWhen K=6: 6 \\to 1\n\nSample Input 23141\n\nSample Output 213\n\nSample Input 3314159265358\n\nSample Output 39",
        "desc": "This C++ problem requires determining how many integers \\( K \\) (ranging from 2 to \\( N \\)) can reduce a given \\( N \\) to 1 through a specific iterative process involving division and subtraction. It tests understanding of number theory, efficient algorithm design for large inputs (up to \\( 10^{12} \\)), and optimization techniques, categorizing it as a **hard** difficulty level question.",
        "program": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\nusing ll = long long;\nusing namespace std;\nbool OK(ll N, ll K) {\n  while (N != 1) {\n    if (N % K == 0) {\n      N /= K;\n      continue;\n    } else if (N > K) {\n      N %= K;\n      continue;\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\nvector<ll> factorize(ll x) {\n  vector<ll> v;\n  for (ll i = 2; i * i <= x;) {\n    if (x % i == 0) {\n      v.push_back(i);\n      x /= i;\n    } else {\n      ++i;\n    }\n  }\n  if (x > 1) v.push_back(x);\n  return v;\n}\nvoid dfs(set<ll>& s, int depth, ll K, const vector<ll>& factors) {\n  if (depth == factors.size()) {\n    if (K > 1) {\n      s.insert(K);\n    }\n    return;\n  }\n  dfs(s, depth + 1, K, factors);\n  dfs(s, depth + 1, K * factors[depth], factors);\n}\nvoid dfs2(set<ll>& s, int depth, ll K, const vector<ll>& factors) {\n  if (depth == factors.size()) {\n    if (K > 1) {\n      s.insert(K);\n    }\n    return;\n  }\n  dfs(s, depth + 1, K, factors);\n  dfs(s, depth + 1, K * factors[depth], factors);\n}\nint main() {\n  ll N;\n  cin >> N;\n  set<ll> solutions;\n  dfs(solutions, 0, 1, factorize(N - 1));\n  set<ll> s2;\n  dfs2(s2, 0, 1, factorize(N));\n  ll ans = solutions.size();\n  for (ll x : s2) {\n    if (OK(N, x)) {\n      ++ans;\n    }\n  }\n  cout << ans << endl;\n}",
        "error_desc": "1. The `OK` function incorrectly uses `N %= K` instead of `N - K` when `K` does not divide `N`.\n2. The program only considers `K` values derived from factors of `N` and `N-1`, missing other valid choices.\n3. The `factorize` function is inefficient for large `N` up to `10^12`, causing excessive computation time.\n4. Redundant `dfs` and `dfs2` functions lead to unnecessary recursive calls and increased runtime.\n5. The main function combines sets in a way that results in an excessive number of `K` candidates to check."
    },
    {
        "problem_id": "p03061",
        "question": "Score : 300 points\n\nProblem StatementThere are N integers, A_1, A_2, ..., A_N, written on the blackboard.\nYou will choose one of them and replace it with an integer of your choice between 1 and 10^9 (inclusive), possibly the same as the integer originally written.\nFind the maximum possible greatest common divisor of the N integers on the blackboard after your move.\n\nConstraints\nAll values in input are integers.\n2 \\leq N \\leq 10^5\n1 \\leq A_i \\leq 10^9\n\nOutputInput is given from Standard Input in the following format:\nN\nA_1 A_2 ... A_N\n\nOutputPrint the maximum possible greatest common divisor of the N integers on the blackboard after your move.\n\nSample Input 13\n7 6 8\n\nSample Output 12\n\nIf we replace 7 with 4, the greatest common divisor of the three integers on the blackboard will be 2, which is the maximum possible value.\n\nSample Input 23\n12 15 18\n\nSample Output 26\n\nSample Input 32\n1000000000 1000000000\n\nSample Output 31000000000\n\nWe can replace an integer with itself.",
        "desc": "This C++ problem requires determining the maximum possible greatest common divisor (GCD) of an array after replacing one element, testing understanding of number theory, efficient GCD algorithms, and handling large datasets. It is classified as a hard-level problem due to its constraints and the need for optimized solutions.",
        "program": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\nusing namespace std;\nint Gcd(int a, int b) {\n  if (a == 0) return b;\n  if (b == 0) return a;\n  assert(a != 0 && b != 0);\n  return gcd(a, b);\n}\nclass SegmentTree {\n public:\n  SegmentTree(int size) {\n    int two = 1;\n    while (two < size) {\n      two <<= 1;\n    }\n    v_.resize(two * 2 - 1);\n  }\n  void Add(int i, int v) {\n    int index = v_.size() / 2 + i;\n    while (true) {\n      v_[index] = v;\n      if (index == 0) break;\n      v = Gcd(v, v_[index + index % 2 == 0 ? -1 : 1]);\n      index = (index - 1) / 2;\n    }\n  }\n  int Sum(int begin, int end) const {\n    return sum(begin, end, 0, (v_.size() + 1) / 2, 0);\n  }\n  int sum(int begin, int end, int cbegin, int cend, int index) const {\n    if (begin <= cbegin && cend <= end) {\n      return v_[index];\n    }\n    if (cend <= begin || end <= cbegin) {\n      return 0;\n    }\n    int cmid = (cbegin + cend) / 2;\n    return Gcd(sum(begin, end, cbegin, cmid, index * 2 + 1),\n               sum(begin, end, cmid, cend, index * 2 + 2));\n  }\n  std::vector<int> v_;\n};\nint main() {\n  int N;\n  cin >> N;\n  vector<int> A(N);\n  REP(i, N) cin >> A[i];\n  SegmentTree t(N);\n  REP(i, N) {\n    t.Add(i, A[i]);\n  }\n  int ans = 0;\n  REP(i, N) {\n    ans = max(ans, Gcd(t.Sum(0, i), t.Sum(i + 1, N)));\n  }\n  cout << ans << endl;\n}",
        "error_desc": "1. Operator precedence issues in the ternary operator inside the `Add` method cause incorrect indexing.\n2. The `Gcd` function uses `int` which can lead to overflow with large input values.\n3. The `Sum` method incorrectly calculates the end range as `(v_.size() + 1) / 2` instead of the actual size.\n4. The `sum` function returns 0 for non-overlapping ranges, which is invalid for GCD operations."
    }
]