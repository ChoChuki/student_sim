[
    {
        "problem_id": "p02784",
        "question": "Score : 200 points\n\nProblem StatementRaccoon is fighting with a monster.\nThe health of the monster is H.\nRaccoon can use N kinds of special moves. Using the i-th move decreases the monster's health by A_i.\nThere is no other way to decrease the monster's health.\nRaccoon wins when the monster's health becomes 0 or below.\nIf Raccoon can win without using the same move twice or more, print Yes; otherwise, print No.\n\nConstraints\n1 \\leq H \\leq 10^9\n1 \\leq N \\leq 10^5\n1 \\leq A_i \\leq 10^4\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nH N\nA_1 A_2 ... A_N\n\nOutputIf Raccoon can win without using the same move twice or more, print Yes; otherwise, print No.\n\nSample Input 110 3\n4 5 6\n\nSample Output 1Yes\n\nThe monster's health will become 0 or below after, for example, using the second and third moves.\n\nSample Input 220 3\n4 5 6\n\nSample Output 2No\n\nSample Input 3210 5\n31 41 59 26 53\n\nSample Output 3Yes\n\nSample Input 4211 5\n31 41 59 26 53\n\nSample Output 4No",
        "desc": "This Java problem tests the ability to apply greedy algorithms and efficiently handle large input sizes to determine if a subset of unique moves can reduce a monster's health to zero or below. It is classified as intermediate to hard in difficulty due to the requirement for optimized solutions within tight computational constraints.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint H = sc.nextInt();\n\t\tfor (int i = 0; i < sc.nextInt(); i++) {\n\t\t\tH -= sc.nextInt();\n\t\t}\n\t\tSystem.out.println(H <= 0 ? \"Yes\" : \"No\");\n\t}\n}",
        "error_desc": "1. The loop condition uses `sc.nextInt()` instead of storing the value of `N`, causing multiple reads and incorrect loop bounds.\n2. The program incorrectly attempts to read additional integers inside the loop condition, leading to input mismatch and runtime exceptions."
    },
    {
        "problem_id": "p02767",
        "question": "Score : 300 points\n\nProblem StatementThere are N people living on a number line.\nThe i-th person lives at coordinate X_i.\nYou are going to hold a meeting that all N people have to attend.\nThe meeting can be held at any integer coordinate. If you choose to hold the meeting at coordinate P, the i-th person will spend (X_i - P)^2 points of stamina to attend the meeting.\nFind the minimum total points of stamina the N people have to spend.\n\nConstraints\nAll values in input are integers.\n1 \\leq N \\leq 100\n1 \\leq X_i \\leq 100\n\nInputInput is given from Standard Input in the following format:\nN\nX_1 X_2 ... X_N\n\nOutputPrint the minimum total stamina the N people have to spend.\n\nSample Input 12\n1 4\n\nSample Output 15\n\nAssume the meeting is held at coordinate 2. In this case, the first person will spend (1 - 2)^2 points of stamina, and the second person will spend (4 - 2)^2 = 4 points of stamina, for a total of 5 points of stamina. This is the minimum total stamina that the 2 people have to spend.\nNote that you can hold the meeting only at an integer coordinate.\n\nSample Input 27\n14 14 2 13 56 2 37\n\nSample Output 22354",
        "desc": "This Java problem requires determining the optimal integer meeting point on a number line that minimizes the sum of squared distances for N people, testing concepts such as brute-force search and optimization of quadratic functions. It is categorized as medium difficulty due to the need for efficient iteration within given constraints.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tint total = 0;\n\t\tint pow = 0;\n\t\tint[] X = new int[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tX[i] = sc.nextInt();\n\t\t\ttotal += X[i];\n\t\t}\n\t\tint av = total/N;\n\t\tfor (int x : X) {\n\t\t\tint p = x - av;\n\t\t\tpow += p*p;\n\t\t}\n\t\tSystem.out.println(pow);\n\t}\n}",
        "error_desc": "1. The average position `av` is calculated using integer division, which may not accurately represent the optimal meeting coordinate.\n2. The program assumes the meeting should be held exactly at the average position without checking other integer coordinates for a lower total stamina.\n3. By only using the average to determine `P`, the program does not ensure that the minimum total stamina is achieved."
    },
    {
        "problem_id": "p02785",
        "question": "Score : 300 points\n\nProblem StatementFennec is fighting with N monsters.\nThe health of the i-th monster is H_i.\nFennec can do the following two actions:\n\nAttack: Fennec chooses one monster. That monster's health will decrease by 1.\nSpecial Move: Fennec chooses one monster. That monster's health will become 0.\n\nThere is no way other than Attack and Special Move to decrease the monsters' health.\nFennec wins when all the monsters' healths become 0 or below.\nFind the minimum number of times Fennec needs to do Attack (not counting Special Move) before winning when she can use Special Move at most K times.\n\nConstraints\n1 \\leq N \\leq 2 \\times 10^5\n0 \\leq K \\leq 2 \\times 10^5\n1 \\leq H_i \\leq 10^9\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nN K\nH_1 ... H_N\n\nOutputPrint the minimum number of times Fennec needs to do Attack (not counting Special Move) before winning.\n\nSample Input 13 1\n4 1 5\n\nSample Output 15\n\nBy using Special Move on the third monster, and doing Attack four times on the first monster and once on the second monster, Fennec can win with five Attacks.\n\nSample Input 28 9\n7 9 3 2 3 8 4 6\n\nSample Output 20\n\nShe can use Special Move on all the monsters.\n\nSample Input 33 0\n1000000000 1000000000 1000000000\n\nSample Output 33000000000\n\nWatch out for overflow.",
        "desc": "This Java problem assesses understanding of greedy algorithms and efficient data handling, requiring the optimization of attack and special move actions to minimize total attacks on monsters with varying health. With constraints up to 2×10⁵ elements and large health values, it is classified as a challenging (hard) level problem.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tlong count = 0;\n\t\tInteger[] enemy = new Integer[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tenemy[i]= sc.nextInt();\n\t\t}\n\t\tArrays.sort(enemy, Collections.reverseOrder());\n\t\tfor (int i = K; i < N; i++) {\n\t\t\tcount += enemy[i];\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02790",
        "question": "Score : 200 points\n\nProblem StatementGiven are 1-digit positive integers a and b. Consider these two strings: the concatenation of b copies of the digit a, and the concatenation of a copies of the digit b. Which of these is lexicographically smaller?\n\nConstraints\n1 \\leq a \\leq 9\n1 \\leq b \\leq 9\na and b are integers.\n\nInputInput is given from Standard Input in the following format:\na b\n\nOutputPrint the lexicographically smaller of the two strings. (If the two strings are equal, print one of them.)\n\nSample Input 14 3\n\nSample Output 13333\n\nWe have two strings 444 and 3333. Between them, 3333 is the lexicographically smaller.\n\nSample Input 27 7\n\nSample Output 27777777",
        "desc": "This Java problem assesses the ability to construct strings by repeating single-digit integers and compare them lexicographically. It tests knowledge of string manipulation and comparison operations, and is considered to have a medium difficulty level.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint a = sc.nextInt();\n\t\tint b = sc.nextInt();\n\t\tStringBuilder A = new StringBuilder();\n\t\tStringBuilder B = new StringBuilder();\n\t\tfor (int i = 0; i < b; i++) A.append(a);\n\t\tfor (int i = 0; i < a; i++) B.append(b);\n\t\tSystem.out.println(a < b ? A : B);\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02791",
        "question": "Score : 300 points\n\nProblem Statement\nGiven is a permutation P_1, \\ldots, P_N of 1, \\ldots, N.\nFind the number of integers i (1 \\leq i \\leq N) that satisfy the following condition:  \n\nFor any integer j (1 \\leq j \\leq i), P_i \\leq P_j.\n\nConstraints\n\n1 \\leq N \\leq 2 \\times 10^5\nP_1, \\ldots, P_N is a permutation of 1, \\ldots, N.  \nAll values in input are integers.\n\nInput\nInput is given from Standard Input in the following format:\nN\nP_1 ... P_N\n\nOutput\nPrint the number of integers i that satisfy the condition.\n\nSample Input 15\n4 2 5 1 3\n\nSample Output 13\n\ni=1, 2, and 4 satisfy the condition, but i=3 does not - for example, P_i &gt; P_j holds for j = 1.\nSimilarly, i=5 does not satisfy the condition, either. Thus, there are three integers that satisfy the condition.\n\nSample Input 24\n4 3 2 1\n\nSample Output 24\n\nAll integers i (1 \\leq i \\leq N) satisfy the condition.\n\nSample Input 36\n1 2 3 4 5 6\n\nSample Output 31\n\nOnly i=1 satisfies the condition.\n\nSample Input 48\n5 7 4 2 6 8 1 3\n\nSample Output 44\n\nSample Input 51\n1\n\nSample Output 51",
        "desc": "This Java problem assesses understanding of permutations, efficient iteration, and condition-based index counting under large input constraints, requiring optimized algorithms to handle up to 200,000 elements. It is classified as a hard-level question, suitable for testing advanced problem-solving and algorithmic skills.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tint count = 1;\n\t\tint min = sc.nextInt();\n\t\tfor (int i = 1; i < N; i++) {\n\t\t\tint now = sc.nextInt();\n\t\t\tif (now <= min) {\n\t\t\t\tmin = now;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02801",
        "question": "Score : 100 points\n\nProblem StatementGiven is a lowercase English letter C that is not z. Print the letter that follows C in alphabetical order.\n\nConstraints\nC is a lowercase English letter that is not z.\n\nInputInput is given from Standard Input in the following format:\nC\n\nOutputPrint the letter that follows C in alphabetical order.\n\nSample Input 1a\n\nSample Output 1b\n\na is followed by b.\n\nSample Input 2y\n\nSample Output 2z\n\ny is followed by z.",
        "desc": "This Java problem tests understanding of character manipulation and ASCII value operations by requiring the programmer to identify and print the next lowercase English letter following a given input character. It is classified as an easy-level question.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tString N = sc.next();\n\t\tSystem.out.println((char) (N.charAt(0) + 1));\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02802",
        "question": "Score : 300 points\n\nProblem StatementTakahashi participated in a contest on AtCoder.\nThe contest had N problems.\nTakahashi made M submissions during the contest.\nThe i-th submission was made for the p_i-th problem and received the verdict S_i (AC or WA).\nThe number of Takahashi's correct answers is the number of problems on which he received an AC once or more.\nThe number of Takahashi's penalties is the sum of the following count for the problems on which he received an AC once or more: the number of WAs received before receiving an AC for the first time on that problem.\nFind the numbers of Takahashi's correct answers and penalties.\n\nConstraints\nN, M, and p_i are integers.\n1 \\leq N \\leq 10^5\n0 \\leq M \\leq 10^5\n1 \\leq p_i \\leq N\nS_i is AC or WA.\n\nInputInput is given from Standard Input in the following format:\nN M\np_1 S_1\n:\np_M S_M\n\nOutputPrint the number of Takahashi's correct answers and the number of Takahashi's penalties.\n\nSample Input 12 5\n1 WA\n1 AC\n2 WA\n2 AC\n2 WA\n\nSample Output 12 2\n\nIn his second submission, he received an AC on the first problem for the first time. Before this, he received one WA on this problem.\nIn his fourth submission, he received an AC on the second problem for the first time. Before this, he received one WA on this problem.\nThus, he has two correct answers and two penalties.\n\nSample Input 2100000 3\n7777 AC\n7777 AC\n7777 AC\n\nSample Output 21 0\n\nNote that it is pointless to get an AC more than once on the same problem.\n\nSample Input 36 0\n\nSample Output 30 0",
        "desc": "This Java problem involves efficiently tracking multiple problem submissions using data structures (like arrays or hash maps) to count correct answers and associated penalties based on submission outcomes. It assesses understanding of data processing, state management, and optimization techniques, and is classified as a high-difficulty (300 points) challenge.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tMain main = new Main();\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tint M = sc.nextInt();\n\t\tMap<Integer, Answer> map = new HashMap<>();\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint p = sc.nextInt();\n\t\t\tString ans = sc.next();\n\t\t\tif (map.containsKey(p)) {\n\t\t\t\tif (ans.equals(\"AC\")) {\n\t\t\t\t\tmap.get(p).setAc(true);\n\t\t\t\t} else {\n\t\t\t\t\tmap.get(p).Add();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tAnswer answer = main.new Answer(ans);\n\t\t\t\tmap.put(p, answer);\n\t\t\t}\n\t\t}\n\t\tint acCount = 0;\n\t\tint waCount = 0;\n\t\tfor (Integer key : map.keySet()) {\n\t\t\tAnswer nowAns = map.get(key);\n\t\t\tif (nowAns.getAc()) {\n\t\t\t\tacCount++;\n\t\t\t\twaCount += nowAns.getWa();\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(acCount + \" \" + waCount);\n\t}\n\tpublic class Answer {\n\t\tpublic Answer(String key) {\n\t\t\tif (key.equals(\"AC\")) {\n\t\t\t\tthis.ac =true;\n\t\t\t} else {\n\t\t\t\tthis.wa++;\n\t\t\t}\n\t\t}\n\t\tpublic boolean ac = false;\n\t\tpublic int wa = 0;\n\t\tpublic boolean getAc() {\n\t\t\treturn this.ac;\n\t\t}\n\t\tpublic void setAc(boolean b) {\n\t\t\tthis.ac = true;\n\t\t}\n\t\tpublic void Add() {\n\t\t\tthis.wa++;\n\t\t}\n\t\tpublic int getWa() {\n\t\t\treturn this.wa;\n\t\t}\n\t}\n}",
        "error_desc": "1. The program counts wrong answers (WAs) even after a problem has received its first AC, which should not be included in penalties.\n2. It does not stop incrementing the WA count once an AC has been recorded for a problem.\n3. The `setAc` method ignores the input parameter and always sets `ac` to true, which can lead to incorrect state management."
    },
    {
        "problem_id": "p02812",
        "question": "Score : 200 points\n\nProblem StatementWe have a string S of length N consisting of uppercase English letters.\nHow many times does ABC occur in S as contiguous subsequences (see Sample Inputs and Outputs)?\n\nConstraints\n3 \\leq N \\leq 50\nS consists of uppercase English letters.\n\nInputInput is given from Standard Input in the following format:\nN\nS\n\nOutputPrint number of occurrences of ABC in S as contiguous subsequences.\n\nSample Input 110\nZABCDBABCQ\n\nSample Output 12\n\nTwo contiguous subsequences of S are equal to ABC: the 2-nd through 4-th characters, and the 7-th through 9-th characters.\n\nSample Input 219\nTHREEONEFOURONEFIVE\n\nSample Output 20\n\nNo contiguous subsequences of S are equal to ABC.\n\nSample Input 333\nABCCABCBABCCABACBCBBABCBCBCBCABCB\n\nSample Output 35",
        "desc": "This Java problem tests understanding of string manipulation and pattern recognition by requiring the counting of contiguous \"ABC\" subsequences within a given uppercase string. It is categorized as a medium difficulty level challenge.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tMain main = new Main();\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tString S = sc.next();\n\t\tString zeroS = S.replace(\"ABC\", \"0\");\n\t\tint count = 0;\n\t\tfor (char c : zeroS.toCharArray()) {\n\t\t\tif (c == '0') {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02699",
        "question": "Score : 100 points\n\nProblem StatementThere are S sheep and W wolves.\nIf the number of wolves is greater than or equal to that of sheep, the wolves will attack the sheep.\nIf the wolves will attack the sheep, print unsafe; otherwise, print safe.\n\nConstraints\n1 \\leq S \\leq 100\n1 \\leq W \\leq 100\n\nInputInput is given from Standard Input in the following format:\nS W\n\nOutputIf the wolves will attack the sheep, print unsafe; otherwise, print safe.\n\nSample Input 14 5\n\nSample Output 1unsafe\n\nThere are four sheep and five wolves. The number of wolves is not less than that of sheep, so they will attack them.\n\nSample Input 2100 2\n\nSample Output 2safe\n\nMany a sheep drive away two wolves.\n\nSample Input 310 10\n\nSample Output 3unsafe",
        "desc": "This Java problem tests basic input handling, integer parsing, and the use of conditional statements to compare two values. It assesses beginner-level programming skills by requiring the determination of whether the number of wolves is greater than or equal to the number of sheep and outputting \"unsafe\" or \"safe\" accordingly.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint S = sc.nextInt();\n\t\tint W = sc.nextInt();\n\t\tSystem.out.println( S <= W ? \"unsafe\" : \"safe\");\n\t}\n}",
        "error_desc": "No error."
    },
    {
        "problem_id": "p02700",
        "question": "Score : 200 points\n\nProblem StatementTakahashi and Aoki will have a battle using their monsters.\nThe health and strength of Takahashi's monster are A and B, respectively, and those of Aoki's monster are C and D, respectively.\nThe two monsters will take turns attacking, in the order Takahashi's, Aoki's, Takahashi's, Aoki's, ...\nHere, an attack decreases the opponent's health by the value equal to the attacker's strength.\nThe monsters keep attacking until the health of one monster becomes 0 or below. The person with the monster whose health becomes 0 or below loses, and the other person wins.\nIf Takahashi will win, print Yes; if he will lose, print No.\n\nConstraints\n1 \\leq A,B,C,D \\leq 100\nAll values in input are integers.\n\nInputInput is given from Standard Input in the following format:\nA B C D\n\nOutputIf Takahashi will win, print Yes; if he will lose, print No.\n\nSample Input 110 9 10 10\n\nSample Output 1No\n\nFirst, Takahashi's monster attacks Aoki's monster, whose health is now 10-9=1.\nNext, Aoki's monster attacks Takahashi's monster, whose health is now 10-10=0.\nTakahashi's monster is the first to have 0 or less health, so Takahashi loses.\n\nSample Input 246 4 40 5\n\nSample Output 2Yes",
        "desc": "This problem evaluates the ability to perform arithmetic calculations and apply conditional logic to simulate a turn-based battle scenario. It tests concepts such as integer division and decision-making, and is classified as an easy-level Java programming challenge.",
        "program": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint A = sc.nextInt();\n\t\tint B = sc.nextInt();\n\t\tint C = sc.nextInt();\n\t\tint D = sc.nextInt();\n\t\twhile (true) {\n\t\t\tC -= B;\n\t\t\tif (C <= 0) {\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tA -= D;\n\t\t\tif (A <= 0) {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}",
        "error_desc": "No error."
    }
]